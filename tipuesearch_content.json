{"pages":[{"text":"Please contact me via Email cjhou1984@gmail.com or the links in the blog. Thanks! class Solution : # @param {string} s # @return {string} def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix","tags":"pages","loc":"www.houcj.net/pages/About.html","title":"About"},{"text":"面试部门是阿里巴巴的国际事业部，主要业务是SEO，广告推荐以及翻译和搜索。 一面（7/8 30mins） 自我介绍 项目的相关 语言细节： Python中pyc文件的作用 Python元组与列表的区别，什么时候会用到元组？ Python中yiled关键字，同时描述生成器的作用 Python中GIL，以及如何在Python中实现多线程编程 算法相关： 求两个链表的第一个交点(没有环) 求包含字串所有字母的母串的最小窗口长度 Leetcode 一面主要是很多基础相关的，语言细节和算法。一般情况下会30分钟左右， 算法相关由于是电面一般只要描述基本思路和时间空间复杂度。 二面 (7/9 40mins) 自我介绍 项目的介绍（根据你项目的描述进行提问） DNS是如何进行查询的 什么是DNS污染，如何防止DNS污染 DNS里的一个条目大小是多少？（这个真不知道） 具体描述下你访问 www.taobao.com 时的DNS查询过程 CPP中成员初始化列表为何要与成员数据的声明次序相同（当场告诉我回答的不对，让再看下） 输入关键字的时候，建立什么样的数学模型能够使错误的关键字转化为正确的关键字（描述有点不太清楚，提示用编辑距离，最后我说自动状态机也可以） 关于实习和去杭州工作的想法 你对他们的问题？（我主要问的是他们是什么方向的） 二面可能对你的知识的全面性以及抽象能力考察比较多 三面 (7/13 50mins) 详细的介绍最熟悉的项目 用两句话总结NDN的优缺点 设计一个可靠的UDP传输协议 说下TCP（三次握手）是如何建立连接的 简单的说下客户端如何根据网络的情况来调整他的发送速度 你关注了GitHub的什么人 说下Python和CPP的不同 从CPP中说下面向对象编程 平常是如何学习的 说下自己的优势 对他们的一个问题 三面更关注抽象能力以及学习能力，剩下的就是聊人生啦。。。。。 四面 (7/17 25mins) 挑了一个他感兴趣的项目进行提问 在爬虫爬到1亿条数据如何进行存储（我提出一个文本方式，提出要使用数据库） 服务器端应该如何反爬虫 说下对大数据的理解 （安排说抽时间看下大数据相关的） 说下对阿里巴巴的理解 提问一个问题 四面是技术终面，最后说HR可能也会是电面。。。。。","tags":"杂项","loc":"www.houcj.net/blog/2015/07/18/ali-interview/","title":"2015阿里内推电话面试经验"},{"text":"","tags":"编程","loc":"www.houcj.net/blog/2015/07/17/build-a-web-server/","title":"Build a web server"},{"text":"解释器是如何工作的 解释器主要分为两部分：解析（parse）和求值（eval）。解析包括词法分析和语法分析，语义分析，生成语法树。 求值包括作用域，类型处理和语法树遍历。 programs (str) ➡ parse ➡ abstract syntax tree (list) ➡ eval ➡ result (object) 解析 词法分析负责把源程序解析成词法单元token，方便以后语义分析中利用这些token生成抽象语法树。Scheme中的tokens 主要是括号，符号和数字。这里使用python内置的str.split()来进行见到的操作。 def tokenize ( s ): \"Convert a string into a list of tokens.\" return s . replace ( '(' , ' ( ' ) . replace ( ')' , ' ) ' ) . split () def read_from_tokens ( tokens ): \"Read an expression from a sequence of tokens.\" if len ( tokens ) == 0 : raise SyntaxError ( 'unexpected EOF while reading' ) token = tokens . pop ( 0 ) # get the token from the front if '(' == token : L = [] while tokens [ 0 ] != ')' : L . append ( read_from_tokens ( tokens )) tokens . pop ( 0 ) # pop off ')' return L elif ')' == token : raise SyntaxError ( 'unexpected )' ) else : return atom ( token ) 环境 eval 函数里有两个参数，表达式x和环境env，环境用来map变量的名字到变量的值中。环境里有两个方法__init__用来根据形参(parameter)和实参 (argument)来为inner 部分构造一个{variable: value}pair，同时也引用到给定的外部环境。find方法用来找到正确的执行环境。 class Env ( dict ): \"An environment: a dict of {'var':val} pairs, with an outer Env.\" def __init__ ( self , parms = (), args = (), outer = None ): self . update ( zip ( parms , args )) self . outer = outer def find ( self , var ): \"Find the innermost Env where var appears.\" return self if ( var in self ) else self . outer . find ( var ) 求值 对于基础操作的求值可根据Scheme里token所代表的意思用python的方式执行即可。 但对于一个过程操作，当我们在一个嵌套的环境中查找一个变量的时候,我们首先在内层环境中查找，如果找不到的话，我们就到它的外层去查找。 每个过程一般都有三个部分组成：参数列表，函数主体，函数内的环境用来确定变量作用的范围。 class Procedure ( object ): \"A user-defined Scheme procedure.\" def __init__ ( self , parms , body , env ): self . parms , self . body , self . env = parms , body , env def __call__ ( self , * args ): return eval ( self . body , Env ( self . parms , args , self . env )) ################ eval def eval ( x , env = global_env ): \"Evaluate an expression in an environment.\" if isinstance ( x , Symbol ): # variable reference return env . find ( x )[ x ] elif not isinstance ( x , List ): # constant literal return x elif x [ 0 ] == 'quote' : # (quote exp) ( _ , exp ) = x return exp elif x [ 0 ] == 'if' : # (if test conseq alt) ( _ , test , conseq , alt ) = x exp = ( conseq if eval ( test , env ) else alt ) return eval ( exp , env ) elif x [ 0 ] == 'define' : # (define var exp) ( _ , var , exp ) = x env [ var ] = eval ( exp , env ) elif x [ 0 ] == 'set!' : # (set! var exp) ( _ , var , exp ) = x env . find ( var )[ var ] = eval ( exp , env ) elif x [ 0 ] == 'lambda' : # (lambda (var...) body) ( _ , parms , body ) = x return Procedure ( parms , body , env ) else : # (proc arg...) proc = eval ( x [ 0 ], env ) args = [ eval ( exp , env ) for exp in x [ 1 :]] return proc ( * args ) 完成代码见 Github","tags":"编程","loc":"www.houcj.net/blog/2015/07/16/lispy/","title":"A Lisp Interpreter in Python"},{"text":"Copy on write 和其他对象共享一份实值，知道我们必须对自己所拥有的那一份实值进行写动作。在操作 系统领域，各进程之间往往允许共享某些内存分页（以及fork命令等），知道他们打算修改 属于自己的那一个page。这项技术被称作copy on write，是lazy evaluation的一个典型 代表。 CPP中不能声明为virtual函数的函数 一、 内联函数 内联函数是在编译期间进行展开，而虚函数的特性是运行时才动态编译的。 二、构造函数 构造函数是用来创建对象成员的准确类型的，虚函数在不同类型的对象之间选择 合适的动作，在确定的对象没有创建出来以前，是不可能支持虚函数的。 三、静态成员函数 静态成员函数对每个类来说都只有一份，所有对象都共享一份代码。没有 动态绑定的必要。 四、普通函数 普通函数只能被重载（overload），不能被重写 五、友元函数 友元函数不属于类的成员，不能被继承。对于没有继承性质的函数就没有虚函数，虚函数就是 用来确定继承类之间的具体动作。 面向对象编程 封装：可以隐藏实现细节，使得代码模块化。 继承：可以扩展已存在的代码模块，实现代码重用 多态：主要是为了实现接口重用，允许将之类类型的指针赋值给父类类型的指针。\"接口是公司最有价值的资源。设计接口比用一堆类来实现这个接口更费时间。而且接口需要耗费更昂贵的人力的时间\" RTTI typeid 在CPP中返回一个const std::type_info 对象的引用。 dynamic_cast 可以实现在类层次之间的向上向下以及交叉转化。dynamic_cast<目标*>(指针)","tags":"编程","loc":"www.houcj.net/blog/2015/07/14/More-efective-cpp/","title":"More efective cpp"},{"text":"多进程 linux下进程间通信的几种主要手段简介： 管道（Pipe）及有名管道（named pipe） 管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外， 它还允许无亲缘关系进程间的通信； from multiprocessing import Process , Queue def f ( q ): q . put ([ 42 , 'hello' , 'world' ]) if __name__ == '__main__' : q = Queue () p = Process ( target = f , args = ( q ,)) p . start () print q . get () # prints \"[42, None, 'hello']\" p . join () 信号（Signal） 信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身； linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制， 又能够统一对外接口，用sigaction函数重新实现了signal函数）； 报文（Message）队列（消息队列）：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。 共享内存： from multiprocessing import Process , Queue def f ( q ): q . put ([ 42 , None , 'hello' ]) if __name__ == '__main__' : q = Queue () p = Process ( target = f , args = ( q ,)) p . start () print q . get () # prints \"[42, None, 'hello']\" p . join () 共享内存 使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。 往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。 from multiprocessing import Process , Value , Array def f ( n , a ): n . value = 3.1415927 for i in range ( len ( a )): a [ i ] = - a [ i ] if __name__ == '__main__' : num = Value ( 'd' , 0.0 ) arr = Array ( 'i' , range ( 10 )) p = Process ( target = f , args = ( num , arr )) p . start () p . join () print num . value print arr [:] Server 进程方式 : from multiprocessing import Process , Manager def f ( d , l ): d [ 1 ] = '1' d [ '2' ] = 2 d [ 0.25 ] = None l . reverse () if __name__ == '__main__' : manager = Manager () d = manager . dict () l = manager . list ( range ( 10 )) p = Process ( target = f , args = ( d , l )) p . start () p . join () print d print l 信号量（semaphore） 主要作为进程间以及同一进程不同线程之间的同步手段。 套接口（Socket） 更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。","tags":"编程","loc":"www.houcj.net/blog/2015/07/12/multiprocessing/","title":"multiprocessing"},{"text":"尽量使用const STL迭代器以指针为根据塑造出来，所以迭代器的作用就像T 指针， 声明迭代器为const就像声明指针为const一样（即声明一个T const指针）。 如果希望迭代器不得指向不同的东西，但它所指的东西不可被改动，即希望STL 模拟一个const T* 指针，就需要使用const_iterator. 作用域 C++变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。 将函数变量尽可能置于最小作用域内，并在变量声明时进行初始化 PS：如果变量是一个对象，每次进入作用域都要调用其构造函数，每次退出作用域 都要调用其析构函数。 类 显式构造函数 对单个参数的构造函数使用C++关键字explicit class MyClass { public : MyClass ( int num ); } MyClass obj = 1 ; //ok,convert int to MyClass // 会被编译器转化为下面的操作 Myclass tmp ( 1 ); Myclass obj = tmp ; 为了避免构造函数被调用造成隐式转换，可以将其声明为explicit。 拷贝赋值构造函数 仅在代码中需要拷贝一个类对象的时候使用拷贝构造函数，大部分情况下都不需要，此时应使用DISALLOW_COPY_AND_ASSIGN 例如 #define DISALLOW_AND_ASSIGN(TypeName)\\ TypeName(const Tyename&);\\ void operator=(const Typename&) class Foo { public : Foo ( int f ); ~ Foo (); private : DISALLOW_COPY_AND_ASSIGN ( Foo ); }; Foo f1 ; // default constructor Foo f2 ( f1 ); // copy constructor Foo f3 = f1 ; // copy constructor not copy assigin constructor 如果一个新对象被定义，一定会有一个构造函数被调用，不可能调用赋值操作。如果新对象没有被定义，出现operator=就是 拷贝赋值操作。 智能指针 shared_ptr 实现了引用计数, 所以最后一个 shared_ptr 对象析构时, 如果检测到引用次数为 0，就会销毁所指向的对象.在一个指针 操作一个资源的时候，为了实现代码的异常安全，应该尽量把这个资源放到智能指针中。 placement new & palcement delete 如果operator new 接受的参数除了一定会有的size_t之外还有其他，这便是所谓的placment new，众多placment new版本中特别有用的 一个是\"接受一个指针指向该对象被构造之处\"，形如： void * opreator new ( std :: size_t , void * pMemory ) throw (); 确定对象被使用前已先被初始化 reference-returning 函数 // Singleton 是一个class，构造函数是私有的 static Singleton & Instance () { static Singleton singleton ; return singleton ; } C++中，函数内的local static对象会在\"该函数被调用期间\"以及\"首次遇上该对象之定义式\"时被初始化， 。这个函数在第一行定义并初始化一个local static 对象，然后返回一个指向static的引用。任何一种 non-const static对象，无论是局部的还是全局的，在多线程情况下都会有一些问题。处理这个问题的一个做法是：在程序的单线程启动 阶段手工调用所有reference-returning函数，这可消除初始化有关的race conditions。 为多态基类声明virtual析构函数 任何class只要有virtual函数都几乎确定应该也有一个virtual析构函数。如果class不含virtual函数，通常表示它并不意图被 用做一个base classes。当class不企图被当作基类，令其析构函数为virtual往往是个坏主意，因为这增加了对象模型的占有空间。 包括vptr指针和vtbl函数表。 virtual 函数系动态绑定而来，意思是调用一个virtual函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型。 编译期多态 & 运行期多态 哪一个重载函数该被调用（发生在编译期）和哪一个virtual函数该被绑定（发生在运行期）。 头文件 include 的尖括号（<>）和双引号(\"\")的区别 用尖括号是在宏展开的时候，系统首先从C语言函数库中找文件 用双引号的则从项目目录中找文件。 define 保护 所有头文件都应该使用#define防止头文件被多重包含， 命名格式当是: H 例如, 项目 foo 中的头文件 foo/src/bar/baz.h 可按如下方式保护: #ifndef FOO_BAR_BAZ_H_ #define FOO_BAR_BAZ_H_ … #endif // FOO_BAR_BAZ_H_ 头文件依赖 能用前置声明的地方尽量不使用 #include， 使用前置声明可以显著减少需要包含的头文件数量。前置声明中使用的类定义在CPP文件而非h文件中。 同时使用前置声明中的类 class Foo时，数据成员类型必须声明为Foo* 或者 Foo&。将函数参数或者返回值 声明为Foo（但不定义实现） #include 的路径及顺序 项目内头文件应按照项目源代码目录树结构排列。 ru, dir/foo.cc的主要作用是测试或实现dir2/foo2.h的功能，foo.cc中包含头文件的次序 1. dir2/foo2.h 2. C系统文件 3. CPP系统文件 4. 其他库的.h文件 5. 本项目内.h文件 copy and swap 为了实现异常安全的代码，在涉及到内存分配和回收的时候，可以使用copy and assign的方法 MyString & MyString :: operator = ( const MyString & str ) { if ( this != str ); ｛ MyString StrTemp ( str ); char * pTemp = strTemp . m_pData ; strTemp . m_pData = m_pData ; m_pData = pTemp ; ｝ return * this ; } alloc & malloc alloc是唯一可以不使用堆的动态分配机制。alloc可以在栈上分配任意的栈内允许的空间，并且 在函数返回的时候自动释放，就像局部变量一样。 char * ptr = ( char * ) malloc ( 10 ); ptr ++ ; free ( ptr ); // 错误，ptr被修改，不是内存分配时的起始地址 CPP 创建对象的两种方式 堆上创建 需要程序员自己去维护内存的分配和释放 BTree * btree = new BTree ; 栈上创建 由操作系统维护，在超过其范围内自动释放 BTree btree ; malloc/free与new/delete的区别 malloc与free是C++/C 语言的标准库函数，new/delete 是C++的运算符。对于非内部数据类的对象而言，maloc/free 无法满足动态对象的要求 。对象在创建的同时要自动执行构造函数， 对象消亡之前要自动执行析构函数。 由于malloc/free 是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加malloc/free。 指针和引用 指针和引用在语法上最大的区别就是指针可以为NULL，并可以通过delete运算符删除 指针所指的实例，而引用不可以。声明一个引用并没有为引用分配内存。而仅仅 是为该变量赋予一个别名。而声明一个指针则分配了内存。当你知道你需要指向某个东西，而且绝不会改变指向其他东西，或是 当你实现一个操作符而其语法需求无法由pointers打成，你就应该使用reference，任何其他时候使用指针。 虚函数表vtable的存储位置 为了防止vtable被修改，通常vtable被放在只读内存中，在GCC中它被放在ELF中的 .rodata的section中。一个基类的虚函数表总是会继承给它的派生类。在linux下可以通过以下命令查找到 objdump -s -x -d objfilename | c++filt | grep \"vtable\" Traits class 建立一组重载函数或函数模版，彼此间的差异只在于各自的traits参数。令每个函数实现码与其接受之traits信息相应和。 建立一个控制函数或函数模版，它调用上述那些重载函数并传递traits class所提供的信息。 iostream & stdio iostream在编译期间就决定其操作数的类型，而且operator<<是类型安全和可扩充的 stido函数则是在运行时期才解析其格式字符串（formating string） 类成员初始化 编程时尽量将成员的初始化放到初始化列表中，而不是构造函数中，一方面，一些const只能被初始化不能被赋值， 另一方面，在初始化列表中初始化成员在构造函数中通过赋值初始化效率要高。因为对象的初始化首先进行的数据成员 的初始化，然后才会执行构造函数体内的动作。 初始化顺序必须和他们的声明顺序保持一致 ，否则将会产生一些致命的错误。对于一个对象 的所有成员来说，他们在析构函数被调用的顺序总是和在构造函数里被创建的顺序相反。 避免exceptions传出destructors之外 它可以避免terminate函数在exceptions传播过程的栈展开机制被调用 它可以协助确保destructors完成其应该完成的所有事情。 如何不使用virtual函数来实现多态 Base * obj = new Derived ; Derived * d = static_cast < Derived *> ( obj ); d -> doSomething (); 当然也可以使用函数指针，但是比较别扭，上面应该是最优雅的解决方案。 CPP正负下标 数组的第一个元素是元素 0。 C++ 数组的范围是从 array[0] 到 array[size – 1]。 但是，C++ 支持正负下标。 负下标必须在数组边界内；否则结果不可预知。 #include <iostream> using namespace std ; int main () { int intArray [ 1024 ]; for ( int i = 0 , j = 0 ; i < 1024 ; i ++ ) { intArray [ i ] = j ++ ; } cout << intArray [ 512 ] << endl ; // 512 int * midArray = & intArray [ 512 ]; // pointer to the middle of the array cout << midArray [ - 256 ] << endl ; // 256 cout << intArray [ - 256 ] << endl ; // unpredictable } vector简单优化 ### vector < int > vec ; for ( size_t i = 0 ; i < 130 ; i ++ ) { vec . push_back ( i ); } vec刚开始时的容量为0。随着push_back()，每次分配2倍的内存。 1，2，4，8。vector是先创建2倍原来的内存，然后把原来内存中的数据拷贝到 新的内存中，最后在释放原来的内存。为了提高效率可以使用reserve提前为vector分配一大块内存。 而且一旦分配了内存，vec的占有内存的大小就不在改变。需要使用 vector < int > ( v ). swap ( v ); 即原来的内存和0空间内存进行交换。 PS 对与单纯变量，最好以const对象或enums替换#define 对于形式函数的宏，最后改用inline函数替换#define 将某些东西声明为const 可帮助编译器侦测出错误用法。const可被施加于任何作用域内的对象、函数参数、函数返回类型、成员函数本体 编译器强制实施bitwise constness，但你编写程序时应该使用概念上的常量性 当const和non-const成员函数有着实质等价的实现时，令non-const版本调用const版本可避免代码重复 为内置型对象进行手工初始化，因为C++不保证初始化它们 构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。初值列列出的成员变量，其排列次序应该和它们在class中的声明次序相同。 为免除跨编译单元初始化次序，可以用local static对象替换non-local static对象。 Copying函数应该确保复制对象内所有变量及所有base class成分 不要尝试以某个copying（copy or copy assign）函数实现另一个copying函数。应该将共同机制放进第三个函数中，并由连个copying函数共同调用 编译器可以暗自为class创建default构造函数、copy构造函数、copy assign操作符，以及析构函数 为了驳回编译器自动提供的机能，可将相应的成员函数声明为private并且不予实现。 polymorphic base classes应该声明一个virtual 析构函数。如果class带有任何virtual 函数，它就拥有一个virtual析构函数 classes的设计目的如果不是作为base classes使用，或不是为了具备多态性，就不该声明virtual析构函数 析构函数绝对不要throw异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕获任何异常，然后不传播或结束程序 如果客户需要对某个操作函数 运行期间抛出的异常做出反应，那么class应该提供一个普通函数执行该操作。 在构造和析构期间不要调用virutal函数，因为这类调用从不下降至derived class。 赋值操作符返回一个 reference to *this 确保当对象自我赋值时operator=有良好行为。其中技术包括比较来源对象和目标对象的地址、语句的顺序、以及copy-and-swap 确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，其行为仍然正确。 copying函数应该确保复制对象内的所有成员变量及所有base class成分 不要尝试以某个copying函数实现另一个copying函数。应该将共同技能放进第三个函数中，并由两个copying函数共同调用 为防止资源泄露，请使用RAII（Resource Acquisition is Initialization）对象，它们在构造函数中获得资源并在析构函数中释放资源 两个常被使用的RAII classes分别为shared_ptr和auto_ptr。前者通常是最佳选择，因为其copy行为比较直观。若选择auto_ptr，复制动作会使它指向NULL。 httpd源码学习 Makefile文件里的：gcc -W -Wall -lsocket -lpthread -o httpd httpd.c ，修改为： gcc -W -Wall -o httpd httpd.c -lpthread 481行的 int client_name_len 改为 socklen_t client_name_len 436行 改动与上面相似，改为socklen_t类型即可。 34行改为void accept_request(void ); 所以下面的实现也要修改下： void * accept_request ( void * client1 ) { int client = ( intptr_t ) client1 ; // 省略 //同时注意此函数77 和129行改为return NULL; //497行改为if (pthread_create(&newthread , NULL, accept_request, (void*)(intptr_t)client_sock) != 0) //之后再make，程序就OK了。","tags":"编程","loc":"www.houcj.net/blog/2015/06/30/Effecitve-cpp/","title":"Effecitve CPP"},{"text":"Singleton 单利模式是使用最广泛的设计模式，其意图是保证一个类只有一个实例，并提供一个访问它的 全局访问点。 可以定义一个单例类，使用类的私有静态指针变量指向类的唯一实例，并用一个公有的静态方法获取该实例 #实现__new__方法 #并在将一个类的实例绑定到类变量_instance上, #如果cls._instance为None说明该类还没有实例化过,实例化该类,如果cls._instance不为None,直接返回cls._instance class Singleton ( object ): def __new__ ( cls , * args , ** kw ): if not hasattr ( cls , '_instance' ): orig = super ( Singleton , cls ) cls . _instance = orig . __new__ ( cls , * args , ** kw ) return cls . _instance if __name__ == '__main__' : s1 = Singleton () s2 = Singleton () if ( id ( s1 ) == id ( s2 )): print \"Same\" else : print \"Different\" 下面是CPP版本 class Singleton { public : static Singleton & Instance () { static Singleton theSingleton ; return theSingleton ; } /* more (non-static) functions here */ private : Singleton (){}; // ctor hidden Singleton ( Singleton const & ){}; // copy ctor hidden Singleton & operator = ( Singleton const & );{} // assign op. hidden ~ Singleton () {}; // dtor hidden }; int main () { Singleton & p = Singleton :: Instance () ; Singleton & q = Singleton :: Instance (); printf ( \"%p \\n \" , & p ); printf ( \"%p \\n \" , & q ); cin . get (); return 0 ; } 一个线程安全的版本 volatile Singleton * pInst = 0 ; static Singleton & GetInstance () { if ( pInst == NULL ) { lock (); if ( pInst == NULL ) pInst = new Singelton (); unlock (); } return * pInst ; } C++里的new包含了两个步骤： 1. 内存分配 2. 调用构造函数 同时C++标准中规定，如果内存分配失败，或者构造函数没有成功执行， new运算符所返回的将是空。","tags":"编程","loc":"www.houcj.net/blog/2015/06/28/design-pattern/","title":"Design Pattern"},{"text":"在一般的递归调用中，典型的模型是首先执行递归操作，然后记录递归的返回值并计算结果。这种方式下，知道最后的递归我们才能 得到这个返回值来进行最终的计算。 def recsum ( x ): if x == 1 : return x else : return x + recsum ( x - 1 ) rescsum（5）调用时的结果 recsum(5) 5 + recsum(4) 5 + (4 + recsum(3)) 5 + (4 + (3 + recsum(2))) 5 + (4 + (3 + (2 + recsum(1)))) 5 + (4 + (3 + (2 + 1))) 15 在尾递归调用时，我们可以给递归传递一个参数，这个参数记录从当前递归到下个递归时的结果。这样可以让当前递归的返回值和下个递归的返回值相同。 def tailrecsum ( x , running_total = 0 ): if x == 0 : return running_total else : return tailrecsum ( x - 1 , running_total + x ) tailrescsum（5）调用时的结果 tailrecsum(5, 0) tailrecsum(4, 5) tailrecsum(3, 9) tailrecsum(2, 12) tailrecsum(1, 14) tailrecsum(0, 15) 15","tags":"编程","loc":"www.houcj.net/blog/2015/06/27/tail-ecursive/","title":"尾递归优化"},{"text":"Objects are data with methods attached, closures are functions with data attached. 闭包就是一个函数可以引用限定范围内的另一个函数中的变量。在函数式语言领域对于数学闭包常用的表述是\"如果一个运算的结果仍然能被此运算作用， 则这个运算是封闭的\"，如果我们将这个运算的所有结果看做一个集合，那么就可以等价表述说这个运算在这个集合上是封闭的。 def make_counter ( x ): constant = x def counter ( y ): # counter() is a closure return y + constant return counter # 返回一个闭包函数名 c1 = make_counter ( 12 ) c2 = make_counter ( 4 ) print ( c1 ( 3 ), c1 ( 4 ), c2 ( 3 ), c2 ( 4 )) Python 闭包最重要的限制是你无法对outer-scoper赋值，就是说闭包是只读的 def outer ( x ): def inner_reads (): # Will return outer's 'x'. return x def inner_writes ( y ): # Will assign to a local 'x', not the outer 'x' x = y def inner_error ( y ): # Will produce an error: 'x' is local because of the assignment, # but we use it before it is assigned to. tmp = x x = y return tmp return inner_reads , inner_writes , inner_error 如果想这段代码正常运行，需要使用一个可变的容器类型 def outer ( x ): x = [ x ] def inner_reads (): # Will return outer's x's first (and only) element. return x [ 0 ] def inner_writes ( y ): # Will look up outer's x, then mutate it. x [ 0 ] = y def inner_error ( y ): # Will now work, because 'x' is not assigned to, just referenced. tmp = x [ 0 ] x [ 0 ] = y return tmp return inner_reads , inner_writes , inner_error","tags":"编程","loc":"www.houcj.net/blog/2015/06/22/python-closure/","title":"Python 闭包"},{"text":"C++中强制类型转化函数（） dynamic_cast static_cast 关于对象 C++在布局以及存取时间上主要的额外复旦是由virtual引起的，包括： virtual function 机制 用以支持一个有效率的执行器绑定（runtime binding） virtual base 机制 用以实现多次出现在继承体系中的base class，有一个单一而被 共享的实例 此外还有多种继承下的额外负担，发生在一个继承类和其第二或后继的base class的转换。 C++对象模型 在此模型中， Nonstatic data members被配置在每一个class object之内， static data members则被放在class object之外。Static和nonstatic function members 也被放在class object之外。Virutual functions则以下面两个步骤支持。 1. 每个class产生出一堆指向irtual functions的指针，放在表格之中。这个表格被称为virtual table（ vtbl ） 2. 每个class object被安插一个指针，指向相关的virtual table。这个指针被称为 vptr 。vptr的 设定和重置都由每个class的constructor、deconstructor和copy assignment运算符自动完成。每个 class所关联的type_info object（用以支持runtime type identification）也经由virtual table 被指出 放在表格中的第一个slot 在虚拟继承的情况下，base class 不管在继承串链中被派生多少次，永远都只会存在一个实例。一个derived class 如何在本质上模塑base class 的实例呢？ base table模型 。base class table 被产生出来的时候，表格中每个slot内含一个相关的base class地址。每个class object内含一个 bptr，它会被初始化，指向器base class table。这种策略的主要缺点是由于间接性而导致的 空间和存取世间上额外的复旦，优点则是在每个class object中对于继承都有一致的表现方式。第二个 优点是，无须改变class objects本身，就可以放大缩小或更改base class table。 对象的差异 C++程序设计模型直接支持三种programming paradigms。 1. 过程模型（procedural model） 。C语言的程序模型 2. 抽象数据类型模型（abstract data type model）。此模型的抽象是和一组表达式（public接口）一起提供的 3. 面向对象模型（object oriented model）。此模型有一些彼此相关的类型，通过一个抽象的 base class（用以提供共同的接口）被封装起来 在OO paradigm之中，程序员需要处理一个未知的实例，它的类型虽然有所界定，却是无穷可能。 原则上被指定的object的真实类型在每个特定执行点之前，是无法解析的。在C++中，只有通过 pointers和references的操作才能完成。相反地，在ADT paradigm中，程序员处理的是一个拥有固定 而单一类型的实例，它在编译时期已经完全定义好了。 加上多态 C++以下列方法支持多态： 1. 经由一组隐式的转化操作。 2. 经由virtual function机制 3. 经由dynamic_cast和typeid运算符 需要多少内存才能表现一个class object？ 其nonstatic data members的总和大小 加上任何由于对齐（aligment）的需求而填补（padding）上的空间 加上为了支持virtual而由内部产生的任何额外负担。 一个pointer或一个reference之所以支持多态，是因为它们并不引发内存中任何 \"与类型有关的内存委托操作（type-dependent commitment）\";会受到改变的 只有它们所指向的内存的\"大小和内容解释方式\"而已。 构造函数语义学 Default constructor 的构造操作 在C++各个不同的编译模块中，编译器如何避免合成出多个default constructor？ 解决方法是把合成的默认构造函数、拷贝构造函数、析构函数、赋值拷贝函数都以 inline 方式 完成。一个inline函数有静态连接，不会被文件以外看到。如果函数太复杂，不适合 做成inline 函数（内联函数可能导致代码的膨胀），就会合成一个explicit non-inline static 实例。 如果有多个class member都要求constructor初始化操作，将如何？ C++语言要求以成员对象在class中的声明顺序来调用各个constructors。这一点由编译器完成 ，它为每个constructor安排程序代码，以成员声明顺序来调用每一个成员所关联的默认构造函数。 这些代码将被安插在explict user code之前。 如果一个class没有任何constructor，但它内含一个member object，而后者有default constructor。 如果一个没有任何constructors的class派生自一个\"带有default constructor\"的base class class声明或者继承一个virtual function class派生子一个继承串链，其中有一个或更多的virtual base class 只有上面这四种情况，才会造成编译器必须为未声明constructor的class合成一个default constructor 。在合成的default constructor中，只有base class subobjects和成员类对象会被初始化。所有 其他的非静态的数据成员都不会被初始化。 Copy Constructor 的构造操作 对一个object做显示的初始化操作 当object被当做参数交给某个函数时 当函数返回一个class object时 上面这三种情况会以一个object的内容作为另一个 class object 的初值。这时候如果class没有提供一个显式的copy Constructor，其内部是以 default memberwise initialization 完成,也就是把每一个内建的 或派生的data member的值，从一个object拷贝一份到另一个object上。它病死 拷贝其中的member class object，而是以递归的方式施行memberwise initialization。 Named Returned Value优化 X bar () { X xx ; return xx ; } 可能被编译器优化为以下的代码 void bar ( X & __result ) { __result . X :: X (); return ; } 总结 Copy Constructor的应用，迫使编译器多多少少对你的程序代码做部分转化，尤其是当一个 函数以传值（by value）的方式传回一个class object，而该class有一个copy constructor （无论是显式定义出来的或是合成的）时。这将导致深奥的程序转化-不论在函数的定义上还是在使用上。 此外，编译器也将copy constructor的调用操作优化，以一个额外的第一参数（数值直接存放于其中）取代NRV。 成员初始化列表 构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。 class foo { public : foo ( string s , int i ) : name ( s ), id ( i ){} private : string name ; int id ; }; 为了使编译通过，下面四种情况必须使用成员初始化列表。 当初始化一个reference member时 当初始化一个const member时 当调用一个base class 的 constructor，而它拥有一组参数时 当调用一个member class 的constructor，而它拥有一组参数时 列表中的项目顺序是由class中的members声明顺序决定的，不是由初始化列表中的 排列顺序决定的。 Data 语义学 数据成员的绑定 \"member scope resolution rules\"，其效果是，如果一个inline函数在class声明之后立刻被定义的话，那么就对其 进行求值。 数据成员的布局 非静态数据成员在class objects中的排列顺序和被器声明的顺序一样，任何中间介入的static data member都不会 被放进对象布局之中。目前的编译器都是把一个以上测access sections连锁在一起，依照声明的顺序，成为一个连续区块。 Access sections的多少并不是带来额外负担。例如在一个section中声明8个members，或是在8个sections中总共声明 8个members，得到object的大小是一致的。 数据成的存取 每一个静态成员只有一个实例，存放在程序的data segment中，每次程序调用静态成员时， 就会被转化为对该唯一extern实例的直接引用操作。 若取一个静态数据的地址，会得到一个指其数据类型的指针，而不是一个指向其class member的指针， 因为静态成员并不内含在一个class object之中。取一个非静态数据成员的地址，将会得到它在class中的offset， 取一个绑定于真正class object身上的data member的地址将会得到该member在内存中的真正地址。 多重继承 虚拟继承 class 如果内含一个或多个 virtual base class subobject，将被分割为两部分：一个不变区域和一个共享区域。 不变区域中的数据，不管后继如何衍化，总拥有固定的offset（从object算起），所以这一部分数据可以被直接存取。 至于共享区域，其位置会因为每次的派生操作而有变化，所以它们只能被间接存取。 函数语义学 非静态成员函数 C++设计准则之一就是:非静态成员函数至少和一般的非成员函数有相同的效率。这是因为编译器内部将成员函数转换为对等的 非成员函数。下面是转化步骤 1. 改写函数原型，以安插一个额外的参数到成员函数中，用以提供一个存取管道，使类对象得以将此函数调用。此额外参数就是this指针。 2. 将每一个对非静态数据成员的存取操作改为经由this指针来存取。 3. 将成员函数重新写成一个外部函数，将函数名经过 name mangling （一般而言，成员名称之前 会被加上class名称和它们的参数链表，以及参数类型）处理，使它在程序中成为独一无二的语汇。 指向类成员函数的指针 指向类成员函数的指针与普通函数指针的区别在于，前者不仅要匹配函数的参数类型和个数以及返回值类型，还要匹配该函数指针所属的类类型。总结一下，比较以下几点： a）参数类型和个数 b）返回值类型 c）所属的类类型（特别之处） 究其原因，是因为非静态的成员函数必须被绑定到一个类的对象或者指针上，才能得到被调用对象的this指针，然后才能调用指针所指的成员函数 Point3d obj ; Point3d * ptr = & obj ; obj . normalize (); ptr -> normalize (); Point3d Point3d :: normalize () const { register float mag = magnitude (); Point3d normal ; normal . _x = _x / mag ; normal . _y = _y / mag ; normal . _z = _z / mag ; return normal ; } float Point3d :: magnitude () const { return sqrt ( _x * _x + _y * _y + _z * _z ); // _x,_y,_z是Point3d的数据成员 } 在编译器内部可能会被转化为： normal_7Point3dFv ( & obj ); normal_7Point3dFv ( ptr ); void normal_7Point3dFv ( register const Point3d * const this , Point3d & __result ) { register float mag = this -> magnitude (); __result . Point3d :: Point3d ( this -> x / mag , this -> y / mag , this -> z / mag ); return ; } 如果normalize（），是虚成员函数，那么以下的调用： ptr -> normalize (); // 内部转化为 ( * ptr -> vptr [ 1 ])( ptr ); //如何magnitude（）是虚函数， register float mag = magnitude (); // 调用转化为 register float mag = ( * this -> vptr [ 2 ])( this ); 其中vptr表示编译器产生的指针，指向virtual table。1是virtual table slot的索引值，关联到normalize（）函数。第二个ptr表示 this指针。 静态成员函数 如果Point3d::normalize（）是一个静态成员函数， obj . normaobj . normalize (); ptr -> normalize (); // 都会被转化为 normalize_7Point3dSFv (); 静态成员函数的主要特性就是它没有this指针，所以其地址的类型并不是一个指向类成员函数的指针，而是一个非成员函数指针。 1. 它不能直接存取其class中的非静态成员 2. 它不能被声明为const、volatile或virtual 3. 它不需经由class object才能调用，虽然大部分时候它是这样被调用的。 虚成员函数 为了支持虚函数机制，必须首先能够对于多态对象有某种形式的执行期类型判断法。在C++中，多态表示以一个public base class的指针 或引用，寻址出一个继承类对象的意思。 Point * ptr ; ptr = new Point2d ; ptr = new Point3d ; ptr的多态机能主要扮演一个输送机制的角色，经由它，我们可以在程序的任何地方采用一组public derived类型。这种多态类型是 消极的，可以在编译时期完成（virtual base class 情况除外）。当对象别指出的对象真正被使用时，多态也就变成积极的了。 //积极多态一种情况 ptr -> z (); //积极多态另一种情况 if ( Point3d * p3d = dynamic_cast < Point3d *> ( ptr )) return p3d -> _z ; 为了在执行期间获得z()的正确的实例，我们可以可以在每一个多态的类对象身上增加两个members： 1. 一个字符串或数字，表示class类型 2. 一个指针，指向某表格，表格中持有程序的虚函数的执行期地址 在C++中，虚函数可以在编译时期获知，在程序的执行期间，表格的大小和内容不会发生改变。 一个class只会有一个virtual table。 每一个table内含其对应之class object中所有active virtual function函数实例的地址。包括： 这一class所定义的函数实例。它会改写一个可能存在的base class virtual 函数实例 继承自base class 的函数实例。这是在derived class 决定不会改写virtual function时才会出现的情况。 一个pure_virtual_called（）函数实例，它既可以扮演pure virtual function 的空间保卫者角色，也可以当作执行期异常处理函数。 指向成员函数的指针 所有的非静态成员函数都需要对象的地址（this指针指出）。指向成员函数指针的声明语法， 以及指向成员选择运算符的指针，其作用是作为this指针的空间保留者，然而面对一个虚函数，其地址在编译时期是未知的， 所能知道的仅是虚函数在其相关的virtual table中的索引值。即，对一个虚成员函数取地址，所能得到 的只是一个索引值。 一个指向成员函数的指针，是一个结构，内含三个字段：index、faddr和delta。index若不是内含一个相关的virtual table索引值 就是以-1表示函数是nonvirtual。faddr持有nonvirtual 成员函数的地址。delta持有一个可能的this指针调整值。 内联函数 一般而言，处理一个inline函数有两个阶段： 1. 分析函数定义，以决定函数的 \"intrinsic inline ability\"。如果函数因其复杂度，或构建问题别判断不能 称为内联的，它会被转为一个静态函数，并在被编译模块内产生对应的函数定义。 2. 真正的内联函数扩展操作是在调用的那一点上，这会带来参数的求值操作以及临时性对象管理。 在内联函数的扩展期间，如果实际参数是常量表达式，我们可以在替换之前先完成其求值操作，如果是带有副作用的常量表达式（++、--）通常 需要引入临时性变量。否则就直接代换。inline函数对于封装提供了一种必要的支持，可以有效存取封装于class中的非public数据。燃火 一个inline函数如果被调用多次的话，会产生大量的扩展码，使程序暴涨。 构造析构拷贝语意学 A Plain Old Data Structure in C++ is an aggregate class that contains only PODS as members, has no user-defined destructor, no user-defined copy assignment operator, and no nonstatic members of pointer-to-member type. 对象构造 C++并不支持\"临时性的定义\"，这时因为class构造行为的隐式应用之故。global在C++中被视为完全定义的，C++ 的所有全局对象都被以初始化过的数据来对待。 void mumble () { Point local1 = { 1.0 , 1.0 , 1.0 }; Point local2 ; local2 . _x = 1.0 ; local2 . _y = 1.0 ; local2 . _z = 1.0 ; } loacal1的初始化操作会比local2更有效率些。这时因为当函数的active record被放进 程序堆栈时，上述initialization list中的常量就可以被放进local1内存中了。但是explict initialization list带来三项缺点：1. 只有当类成员都是public时才可以。2. 只能指定常量，因为它们在编译时期就可以被evaluated。 3. 由于编译器并没有自动施行之，所以初始化行为的失败可能性会高一些。 Constructors可能内含大量的隐藏码，因为编译器会扩充每一个constructor。在一个class中，经由 构造中的对象来调用一个virtual function，其函数实例应该是在此class中有作用的那个。Constructors 的调用顺序是：由根源而末端（bottom-up），由内而外（inside-out）。 vptr初始化操作在base class Constructors调用操作之后，但是在程序员供应的代码或者成员 初始化列表中所列的成员初始化操作之前。 Constructors的执行算法通常如下： 1. 在继承类构造器中，所有虚基类以及上一层基类的构造器会被调用 2. 上述完成之后，对象的vptr初始化指向相关的virtual tables 3. 如果有成员初始化列表的话，将在构造器内扩展开来。这必须在vptr被设定之后才做，以免有一个虚函数被调用 4. 最后，执行程序员所提供的代码。 对象拷贝 copy assignment operator有一个非正交性的情况，就是它缺乏一个member assignment list。如果没有它，编译器 就没办法压抑上一层base class 的copy operators调用。 // class Vertex: virtual public Point inline Vertex & Vertex :: operator = ( const Vertex & v ) { this -> Point :: operator = ( v ); // Vertex::operator=（const Vertex &v）: Point(v),_next(v._next)是不支持的 _next = v . _next ; return * this ; } 对象析构 就像constructor一样，目前对于destructor的一种最佳实现策略就是维护两份destructor实例： 1. 一个complete object实例，总是设定好vptr（s），并调用virtual base class destructors。 2. 一个base class subobject实例：除非在destructor函数中调用一个virtual function，否则 它绝不会调用virtual base class destructors 并设定vptr。 执行期间语义学 对象的构造和析构 一般而言我们会把object尽可能放置在使用它的那个程序区段附近，这么做可以节省非必要的 对象产生操作和摧毁操作。 C++程序中所有的global objects都被放置在程序的data segment中。class object在编译时期 可以被防止与data segment中并且内容是0，但constructor要等到程序启动才会实施，必须对放置于 program data segment中的object的初始化表达式evaluate，这是一个object需要静态初始化的原因。 const Matrix & identity () { static Matrix mat_identity ; return mat_identity ; } 局部静态变量的constructor必须只能执行一次，虽然可能被调用多次；同时它的destructor必须也只能施行一次， 虽然它也可能被调用多次。 对象数组 Point knots [ 10 ]; //编译器可能的操作 vec_new ( & knots , sizeof ( Point ), 10 & Point :: Point , 0 ); // 使用vec_new 来构造数组对象 void * vec_new ( void * array , size_t elem_size , int elem_count , void ( * constructor )( void * ), void ( * destructor )( void * , char ) ) //使用vec_delete来析构数组对象 void * vec_delete ( void * array , size_t elem_size , int elem_count , void ( * destructor )( void * , char ) ) new 和 delete new运算符总是以标准的C malloc（）完成，delete运算符总是以标准的C free（）完成。 // new 不考虑exception handling extern void * operator new ( size_t size ) { if ( size == 0 ) size = 1 ; void * last_alloc ; while ( ! ( last = malloc ( size ))) { if ( _new_handler ) ( * _new_handler )(); else return 0 ; } return last_alloc ; } // delete extern void operatro delete ( void * ptr ) { if ( ptr ) free (( char * ) ptr ); } 只有在中括号出现时，编译器才寻找数组的纬度，否则它便假设只有单独一个objects要被删除 delete [] p_array ; // 整个数组被删除 delete p_array ; // 只有第一个数组元素被删除 临时对象 临时对象被摧毁，应该是对完整表达式求值过程中的最后一个步骤，该完整表达式造成临时对象的产生。凡持有 表达式执行结果的临时性对象，应该存留到object的初始化操作完成为止。同时，如果一个临时性对象被绑定于 一个reference，对象将残留，直到被初始化它的reference的生命结束，或知道临时对象的生命范畴结束，视哪种 情况先到达而定。 站在对象模型的顶端 三个著名的C++语言扩充性质，分别为template、exception handling和runtime tyep identification。 Template 这里把实例化表示进程将真正类型和表达式绑定到template相关形式参数上头的操作。 Template之中，对于一个非成员name的解析结果，是根据这个name的使用是否与用以实例化该template的参数类型 有关而决定的。如果其使用互不相关，那么就以scope of the template来决定name。如果其使用互有关联，那么就以 scope of the template instantiation来决定name。此外，函数的决议结果只和函数的原型有关，和函数的返回值没有关系。 以手动方式先在个别的object module中完成预先实例化操作，是唯一可以提高编译效率的方法。 异常处理 欲支持exception handling，编译器的主要工作就是找出catch字句，以处理被抛出来的exception。同时编译器必须提供 某种查询exception objects的方法，以知道其实际类型（直接导致了某种形式的执行期间类型识别，即RTTI）最后还需要某种机制 用以管理被抛出的object，包括它的产生、存储、可能的析构、清理以及一般存取。 当一个exception发生时，编译系统必须完成以下事情： 1. 检查发生throw操作的函数 2. 决定throw操作是否发生在try区段中。 3. 若是，编译系统必须把exception type拿来和每一个catch子句进行比较。 4. 如果比较后吻合，流程控制应该交到catch子句手中。 5. 如果throw的发生并不在try区段中，或没有一个catch子句吻合，那么系统必须（a）摧毁 所有active local objects（b）从堆栈中将目前的函数unwind掉（c）进行到程序堆栈下一个函数中去。然后 重复上述步骤2-5 RTTI 一个type-safe downcast必须在执行期对指针有所查询，看看它是否指向它所展现object的真正类型。因此欲支持type-safe downcast，在object空间和执行时间上都需要一些额外负担： - 需要额外的空间以存储类型信息，通常是一个指针，指向某个类型信息节点 - 需要额外的时间以决定执行期的类型。 dynamic_cast 运算符可以在执行期决定真正的类型。如果downcast是安全的，这个运算符会被回传式导弹转换过的指针。 否则的话，回传0.当dynamic_cast运算符作用一个reference时，如果reference并不是真正的一种derived class，那么，由于 不能够回传0，因此抛出一个bad_cast exception. 使用typeid运算符，就有可能以一个reference达到相同的执行期替代路线。 typeid运算符传回一个const reference，类型为type_info。 simplify_conv_op ( const type & rt ) { if ( typeid ( rt ) == typeid ( fct )) { fct & rf = static_cast < fct & > ( rt ); } } PS： 虚函数和纯虚函数 定义一个函数为虚函数，不代表函数为不被实现的函数。 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。 定义一个函数为纯虚函数，才代表函数没有被实现。 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。 虚函数只能借助于指针实现 C++纯虚函数 一、定义 纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加\"=0\" virtual void funtion1()=0 二、引入原因 1、为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。 2、在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：virtual ReturnType Function()= 0;），则编译器要求在派生类中必须予以重写以实现多态性。同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。 纯虚函数最显著的特征是：它们必须在继承类中重新声明函数（不要后面的＝0，否则该派生类也不能实例化），而且它们在抽象类中往往没有定义。 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。 纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。所以类纯虚函数的声明就是在告诉子类的设计者，\"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它\"。 C++位拷贝和值拷贝 位拷贝拷贝的是地址（也叫浅拷贝），而值拷贝则拷贝的是内容（深拷贝）。深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。 位拷贝，及\"bitwise assignment\"是指将一个对象的内存映像按位原封不动的复制给另一个对象，所谓值拷贝就是指，将原对象的值复制一份给新对象。 在用\"bitwise assignment\"时会直接将对象的内存映像复制给另一个对象，这样两个对象会指向同一个内存区域，当一个对象被释放后，另一个对象的指针会成为空指针。这时，就应该编写operator=和copy constructor来实现值拷贝 。 默认的拷贝构造函数\"和\"缺省的赋值函数\"均采用\"位拷贝\"而非\"值拷贝\"的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。 c++模板之声明定义分离编译模型 当我们声明和定义一个模板的时候，必须要让声明和定义放在一个文件里。否则编译器会报错。 在分离式编译的环境下，编译器编译某一个.cpp文件时并不知道另一个.cpp文件的存在，也不会去查找（当遇到未决符号时它会寄希望于连接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就傻眼了，因为模板仅在需要的时候才会实例化出来，所以，当编译器只看到模板的声明时，它不能实例化该模板，只能创建一个具有外部连接的符号并期待连接器能够将符号的地址决议出来。然而当实现该模板的.cpp文件中没有用到模板的实例时，编译器懒得去实例化，所以，整个工程的.obj中就找不到一行模板实例的二进制代码，于是连接器也黔驴技穷了。 这不禁让人疑惑，既然能自动生成函数，为什么还要程序员编写？ 原因如下： （1）如果使用\"缺省的无参数构造函数\"和\"缺省的析构函数\"，等于放弃了自主\"初始化\"和\"清除\"的机会，C++发明人Stroustrup的好心好意白费了。 （2）\"缺省的拷贝构造函数\"和\"缺省的赋值函数\"均采用\"位拷贝\"而非\"值拷贝\"的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。 C++继承和组合 1.什么是继承 A继承B，说明A是B的一种，并且B的所有行为对A都有意义 eg:A=WOMAN B=HUMAN A=鸵鸟 B=鸟 （不行），因为鸟会飞，但是鸵鸟不会。 2.什么是组合 若在逻辑上A是B的\"一部分\"(a part of)，则不允许B从A派生，而是要用A和其它东西组合出B。 例如眼(Eye)、鼻(Nose)、口(Mouth)、耳(Ear)是头(Head)的一部分，所以类Head应该由类Eye、Nose、Mouth、Ear组合而成，不是派生而成 3.继承的优点和缺点 优点： 容易进行新的实现，因为其大多数可继承而来。 易于修改或扩展那些被复用的实现。 缺点： 破坏了封装性，因为这会将父类的实现细节暴露给子类。 \"白盒\"复用，因为父类的内部细节对于子类而言通常是可见的。 当父类的实现更改时，子类也不得不会随之更改。 从父类继承来的实现将不能在运行期间进行改变。 4.组合的优点和缺点 优点： 容器类仅能通过被包含对象的接口来对其进行访问。 \"黑盒\"复用，因为被包含对象的内部细节对外是不可见。 封装性好。 实现上的相互依赖性比较小。（被包含对象与容器对象之间的依赖关系比较少） 每一个类只专注于一项任务。 通过获取指向其它的具有相同类型的对象引用，可以在运行期间动态地定义（对象的）组合。 缺点： 导致系统中的对象过多。 为了能将多个不同的对象作为组合块（composition block）来使用，必须仔细地对接口进行定义。 5.两者的选择 is-a关系用继承表达，has-a关系用组合表达 继承体现的是一种专门化的概念而组合则是一种组装的概念 另外确定是组合还是继承，最清楚的方法之一就是询问是否需要新类向上映射，也就是说当我们想重用原类型作为新类型的内部实现的话，我们最好自己组合，如果我们不仅想重用内部实现而且还想重用接口的话，那就用继承。 6.法则：优先使用（对象）组合，而非（类）继承","tags":"编程","loc":"www.houcj.net/blog/2015/06/19/inside-cpp/","title":"Inside the CPP Object Model"},{"text":"构造过程抽象 在程序设计中，需要处理两类要素：数据和过程。数据是一种我们希望去操作的东西， 过程就是有关操作这些数据的规则的描述。 复合过程 数和算术运算是基本的数据和过程 组合式的嵌套提供了一种组织起多个操作的方法 定义是一种受限的抽象手段，它为名字关联相应的值。 用高阶函数做抽象 一般而言程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有 最少限制的元素被称为第一级的状态。第一级元素的权利包括： - 可以用变量命名 - 可以提供给过程参数 - 可以由过程作为结果返回 - 可以包含在数据结构中 Lisp把过程作为第一级状态，带来强大的表达功能。可以使用过程构造参数， 用lambda构造过程，同时过程也可以作为一般性的方法或者返回值。 构造数据抽象 定义过程的能力使我们有可能在更高的概念层次上处理计算机工作一样，能够构造 符合数据的能力，也将使我们得以在比语言提供的基本数据对象更高的概念 层次上，处理与数据有关的各种问题。 将程序中处理数据对象的表示部分，与处理对象的使用的部分相互隔离的技术形成了 一种称为数据抽象的强有力的设计方法学. 在处理符合数据中的一个关键性思想是闭包的概念---也就是说，用于组合 数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象。 另一关键思想是，复合数据对象能够称为以混合与匹配的方式组合程序模块的方便界面。 数据抽象的基本思想，就是设法构造出一些使用符合数据对象的程序，使它们就像在抽象数据 上操作一样。 map是一种很重要的结构，不仅因为它代表了一种公共模式，而且因为它建立起了 一种处理表的高层抽象。通过map强调的是从元 素表到另一个结果表的缩放变换。从作用上看，map 帮我们建立起了一层抽象屏障，将实现表变换的过程实现与如何提取表中元素以及 组合结果的细节隔离开。 模块化、对象和状态 对于系统结构的两种非常不同的世界观。第一种策略将注意力集中在对象上，将一个大型系统看成一批对象， 它们的行为可能随着时间的进展而不断变化。另一种组织策略将注意力集中在流过系统的 信息流上。 只要我们不使用赋值，以同样的参数对同一过程的两次求值一定产生同样的结果，因此就可以认为 过程是在计算数学函数。不用任何赋值的程序设计称为函数式程序设计。 一个环境就是框架的一个序列，每个框架里包含着一些约束的表格，这些约束将一些变量名字 关联于对应的值。每个框架还包含着一个指针，指向这一框架的外围环境。如果由于当前讨论的目的， 将相应的框架看作是全局的，那么它将没有外围环境。一个变量相对于某个特定环境的值，也就是在 这一环境中，包含着该变量的第一个框架里这个变量的约束值。如果在序列中并不存在 这一变量的约束，那么我们就说这个变量在该特定环境中是无约束的。 过程应用的环境模型 - 将一个过程对象应用于实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的 的实际参数，而后在构造起的这一新环境的上下文中求值过程体。这个新框架的外围环境 就是作为被应用的那个过程对象的一部分的环境 - 相对于一个给定环境求值一个lambda表达式，将创建起一个过程对象，这个过程对象是一个 序对，由该lambda表达式的正文和一个指向环境的指针组成。这一指针指向的就是创建这个过程对象 时的环境。 以局部过程定义作为程序模块化的有用技术中的两个关键性质： - 局部过程的名字不会与包含它们的过程之外的名字互相干扰，这是因为这些局部过程名都是 在该过程运行时创建的框架里面的约束的，而不是在全局环境里约束的。 - 局部过程只需要将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数。这时 是因为对于局部过程体的求值所在的环境是外围过程求值所在环境的下属。 我们可以将世界模拟为一个相互分离的、受时间约束的，具有状态的相互交流的对象，或者 可以将它模拟为单一的、无时间也无状态的统一体。 附录： Scheme Scheme语法极其简洁，支持S（symbol）表达式，可以减少词法解析的时间。Scheme程序中充满了 一对对嵌套的小括号，这些嵌套的符号体现了最基本的数学思想----递归。下面的表格是Scheme语法的基本 结构. Procedures Data Primitive elements +,-,*,/,<,=,> 数字，字符，字符串，布尔值，列表，函数 Means of combination ()composition,COND,IF Means of abstraction Define List 命令 操作 car 取表的第一个元素 cdr 表在取car后的其余部分，对于正常表，其结果是一个表，对非正常表，结果可能是一个元素 cons 构造表，如果第二个参数是表，则将第一个参数作为整体放在第二个参数的表中 List 构造表，将各个参数做为整体放在一个表中 ( define ( appnd list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( appnd ( cdr list1 ) list2 )))) ( define one-two ( list 1 2 3 4 )) ( define odds ( list 1 3 5 7 )) ( appnd odds one-two ) ;return (1 3 5 7 1 2 3 4) 表达式 Scheme C (+ 2 3 4) (2 + 3 + 4) (< low x high) ((low < x) && (x < high)) (f x y) f(x, y) (define (sq x) (* x x)) int sq(int) #t true #\\c 'c' \"abc\" \"abc\" 语法糖 语法糖形式 解释器中形式 (define (sq x) (* x x)) (define sq (lambda (x) (* x x))) '(+ 2 3) (quote (+ 2 3)) if 表达式 cond 表达式 let 表达式和赋值 语法：(let ((var1 val1)...) exp1 exp2...) 说明：let表达式的赋值只在表达式内部有效 ( let (( f + )) ( f 2 3 )) ; return 5 ( let (( f + ) ( x 2 )) ( f x 3 )) ; return 5 ( let (( f + ) ( x 2 ) ( y 3 )) ( f x y )) ; return 5 用define 和 set! 赋值 语法：(define var exp), (set! var exp) 说明：define和 set! 表达式的赋值在全局有效。define 和 set! 的区别是define既能赋值又能定义变量，而set!只能对已经定义的变量赋值 ( define a 1 ) a ; return 1 ( set! a 2 ) a ; return 2 ( let (( a 3 )) a ) ; return 3 a ; return 2 ( let (( a 3 )) ( set! a 4 ) a ) ; return 4 a ; return 2 ( let (( a 3 )) ( define a 5 ) a ) ; return 5 a ; return 2 ( set! b 1 ) ; 错误，b尚未定义 lambda 语法：(lambda (var ...) exp1 exp2 ...) 说明：lambda 表达式用于定义函数。var ... 是参数，exp1 exp2 ...是函数的执行 部分。通常需要结合局部定义 let 或者全局定义表达式 define，再进行函数调用。 (( lambda ( x ) ( + x x )) ( * 3 4 )) ; return 24 if 表达式 语法：(if test consequent alternative) 说明：如果test表达式为真，返回 consequent，否则返回 alternative。 ( define ( abs n ) ( if ( < n 0 ) ( - 0 n ) n )) cond 表达式 语法：(cond (test exp) ... (else exp)) 说明：多路分支判断表达式，类似于C语言的 \"if ... else if ... else\"。 ( define abs ( lambda ( n ) ( cond (( = n 0 ) 0 ) (( < n 0 ) ( - 0 n )) ( else n )))) map 表达式 语法：(map procedure list1 list2 ...) 说明：列表 list1 list2 ... 必须具有同样的长度；过程 procedure 接受的参数个数同列表的个数，各个列表中对应的变量分别作为过程 procedure 的参数被执行， 将每次的运算结果以列表形式返回。 ( map ( lambda ( x y ) ( + x ( * 2 y ))) ( list 1 2 3 ) ( list 4 5 6 ) ) ; return (9 12 15) PS: 过程和定义 () 在Scheme中表示一个过程 ( define A ( * 2 3 )) ( define ( D ) ( * 2 4 )) 粗浅理解，带括号的表示一个过程，相当于C语言中的函数， 不带参数是一个符号表示， 相当于C语言中的宏。 注释 使用分号进行注释 ;(list 1 2 3)","tags":"计算机科学","loc":"www.houcj.net/blog/2015/06/19/sicp/","title":"SICP and Scheme"},{"text":"进程、线程、协程 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。基本上相当与用户空间下进行线程调度。协程不存在 子程序之间的线程切换，而是程序自身控制，因此没有线程切换的开销，协程只有一个线程，因此不需要多线程的锁机制。 静态内存、栈内存、堆内存 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动 创建和销毁。对于栈对象仅在其定义的程序块运行时才存在，static对象在使用之前分配，在程序 结束时销毁。 程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制。 Const 顶层const表示指针本身是个常量 底层const表示指针所指的对象是个常量 尽量使用常量引用 ，使用引用可以避免拷贝，使用const则避免修改实参的值。 string::size_type & size_t size_t size_t是sizeof操作符的结果返回类型，它在头文件中的typedef为 unsigned int 类型。该类型保证实现所建立的最大对象的字节大小。 string::size_type string::size_type是一个无符号类型的值，而且能够存放下任何string对象的大小。所有 用于存放string类的size函数返回值的变量，都应该是string::size_type 类型的。 命名的强制类型转换 一个命名的强制类型转换具有如下形式： cast-name (expression); 其中，type是转换的目标类型，而expression是要转换的值。如果type是引用类型，则结果是左值。 cast-name 是static_cast、dynamic_cast、const_cast和reinterpret_cast的一种。其语法为 const char * pc ; char * p = const_cast < char *> ( pc ); //正确但是通过p写值是未定义的行为 const_cast通常被用来将对象的常量性去除。（cast away the constness） dynamic_cast主要用来执行安全向下转型（safe downcasting），也就是用来决定某对象是否归属继承体系中的某个类型，从基类到派生类 reinterpret_cast执行低级转型，实际结果取决于编译器,例如，从int* 到 int static_cast用来强迫隐式转换（implicit conversions），例如将non-const对象转化为const对象，或将int转化为double。 实参入栈顺序 int b = 0 ; cout << b << b ++ << endl ; // 输出10，b++先使用b然后再加加 cout << ++ b << b ++<<++ b << endl ; // 输出5351 在处理printf或者cout时，压栈顺序为从右向左，对于a++的结果，是有ebp寻址函数栈 空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于 ++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。 尾置迭代器 迭代器的end成员负责返回指向容器尾元素的下一位置的迭代器，该迭代器表示容器的不存在的尾后 元素，作为处理完容器所有元素的标记。 int arr [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int * e = & arr [ 10 ]; // 指向arr尾元素的下一个位置的指针，相当于哨兵的作用。 使用尾置返回类型 任何函数的定义都可以使用尾置（trailing return type）返回，尾置返回类型跟在 形参列表后面并以一个->符号开头，同时为了表示函数真正的返回类型跟在形参列表之后， 可以在返回类型出现的地方放置一个auto： auto func ( int i ) -> int ( * )[ 10 ]; func返回一个函数指针，该指针指向一个含有10个整数的数组。 std :: string :: size_type pos ; // why string::size_type The std::string type defines size_type to be the name of the appropriate type for holding the number of characters in a string. Whenever we need a local variable to contain the size of a string, we should use std::string::size_type as the type of that variable. The reason that we have given cols a type of std::string::size_type is to ensure that cols is capable of containing the number of characters in greeting, no matter how large that number might be. We could simply have said that cols has type int, and indeed, doing so would probably work. However, the value of cols depends on the size of the input to our program, and we have no control over how long that input might be. It is conceivable that someone might give our program a string so long that an int is insufficient to contain its length. 列表初始化 下面四条语句都可以： int i = 0 ; int i = { 0 }; int i ( 0 ); int i { 0 }; void * 是一种特殊的指针类型，可以用于存放任意对象的地址。 const 和 constexpr 如果想在多个文件之间共享const对象，必须在变量的定义之前加extern关键字 常量表达式是指值不会在改变并且在编译过程就能得到计算结果的表达式。 const int max_files = 20 ; //是常量表达式 const int sz = get_size (); //不是常量表达式，具体值在运行时才能得到 C++11 规定允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量 表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 const int * p = nullptr ; // p是一个指向整型常量的指针 constexpr int * q = nullptr ; // q是一个指向整数的常量指针。 类型别名 两种实现方式 typedef using using SI = Sales_item ; // SI是Sales_item的别名 C++11引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型 C++11引入decltype类型说明符，它的作用是选择并返回操作数的数据类型。 字面值类型： 常量表达式的值需要在编译使就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般都比较 简单，值也容易得到。就把它们称为\"字面值类型(literal type)\" 一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 类模版 编译器根据模版创建类或函数的过程称为实例化，当使用模版时，需要指出编译器应把类或函数实例化成何种 类型。 内联函数和constexpr函数 将函数指定为内联函数，通常就是将它在每个调用节点上内联地展开。 constexpr函数是指用于常量表达式的函数，同时要求函数的返回类型及所有形参的类型 都是字面值类型，而且函数体中必须有且只有一条return语句。 constexpr int new_sz () { return 42 ;} constexpr int foo = new_sz (); // foo是一个常量表达式 对于某个给定的内联或者constexpr函数来说，它的多个定义必须完全一致，因此内联函数和 constexpr函数通常定义在头文件中。 class 和struct关键字 使用class和struct定义类唯一的区别就是默认的访问权限。使用struct关键字，定义在第一个访问说明 符之前的成员是public的，如果我们使用class关键字，则这些成员是private的。 函数指针 函数指针指向的是函数而非对象，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 const 在成员函数后面加const表示，这个函数是只读函数，不会改变类的数据成员。 class Point { int xVal , yVal ; public : int GetY () const ; }; //关键字const必须用同样的方式重复出现在函数实现里，否则编译会把它们看成不同的函数 int Point :: GetY () const { return yVal ; } 如果把const放在函数声明前就意味着函数的返回值是常量。同时在const成员函数中，用mutable修饰 成员变量名后，就可以修改类的成员变量。 在C中const是外部链接，它总是占用内存，而且它的名字是全局符， C编译器不能把const看成一个编译器期间的常量，而在C++默认const是内部连接的，它 在编译期间就会确定值。 类 类是C++语言中最基本的特性，它允许我们为自己的应用定义新类型，从而使得程序更加简洁。类有 两项基本功能：一是数据抽象，即定义数据成员和函数成员的能力。二是封装，即保护类的成员不被随意 访问的能力。 构造函数 构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 构造函数不能被声明成const的，当我们创建类的const对象时，直到构造函数完成初始化过程，对象才能 真正取得其常量属性，因此，构造函数在const对象的构造过程中可以向其写值。需要注意的是初始化const 对象或者引用类型的对象时后，必须在执行构造函数体之前完成初始化工作，所以可以使用初始化列表进行初始化工作。 因为初始化表的执行先于函数体。 默认构造函数 如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数， 默认构造函数无需任何实参。 如果类包含有内置类型或者复合类型的成员，则只有当这些成员都被赋予了类内的初始值时， 这个类才适合于使用合成的构造函数 类类型 struct First { int memi ; int geMem (); }; struct Second { int memi ; int getMem (); }; First obj ; Second obj2 = obj1 ; //错误，obj1和obj2类型不同 即使两个类的成员列表完全一致，它们也是不同的类型，对于一个类来说，它的成员 和其他任何类的成员都不是一回事。 友元 友元关系不存在传递性，每个类独立的负责自己的友元类或者友元函数。当第一个名字第一次 出现在一个友元声明中，我们隐式地假定该名字当前作用域是可见的，即使我们仅仅是用友元的类 的成员调用友元函数，它也必须是被显式的声明过。 成员初始化顺序 class test { public : test ( int val ) : j ( val ), i ( j ){} // i先初始化 private : int i ; int j ; }; 构造函数的初始化值的顺序和成员声明的顺序保持一致，同时尽量避免使用某些成员初始化其他成员。 静态成员 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键字则只 出现在类内部的声明语句中。 静态数据成员可以是不完全类型，非静态数据成员必须是完全类型才能使用。静态数据成员的类型可以是 它所属的类类型，而非静态数据成员则只能声明成它所属类的指针。 谓词 谓词是一个可调用的表达式，其返回结果是一个能用做条件的值。标准库使用两种谓词：一元 谓词（只接受单一参数）和二元谓词（它们有两个参数）。（相当于if中的条件表达式） 使用emplace操作 当调用push或insert成员函数时，我们将元素类型的对象传递给它们， 这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数 传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接 构造元素。 适配器（adaptor） 容器、迭代器、和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为 看起来想另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其看起来像一种 不同的类型。 动态内存 程序使用动态内存出于以下三种原因： 1. 程序不知道自己需要使用多少对象 2. 程序不知道所需对象的准确类型 3. 程序需要多个对象间共享数据。 new & delete 在自由空间分配的内存是无名的，因此 new 无法为其分配的对象命名，而是返回一个指向该对象 的指针： int * pi = new int （ 1024 ） ; //pi 指向的对象的值为1024 vector * pv = new vector < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } // 列表初始化 我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者 将相同的指针值释放多次，其行为都是未定义的。 const int * pci = new const int ( 1024 ); delete pci ; 当我们delete一个指针后，指针值就变为无效了，但在很多机器上指针仍保存着已经释放的动态内存的地址，这时候 指针就会变成悬空指针，即，指向一块曾经保存数据对象但现在已经无效（delete）的的内存的指针。解放方法是：在指针 即将离开其作用域之前释放掉它所 关联 的内存。如果需要保存指针可以在delete之后将nullptr赋予指针。 shared_ptr 智能指针也是模块，我们创建一个智能指针时，必须提供指针可以指向的类型。 shared_ptr < Foo > factory ( T arg ) { // shared_ptr 负责释放内存 return make_shared < Foo > ( arg ); } void use_factory ( T arg ) { shared_ptr < Foo > p = factory ( arg ); // 使用p，p离开作用域，它指向的内存会被自动释放掉 } 智能指针与动态数组 // 为了使用shared_ptr必须提供一个删除器 shared_ptr < int > sp ( new int [ 10 ],[]( int * p ) { delete [] p ;}); // shared_ptr未定义下标运算符，并且不支持指针的算术运算 for ( size_t i = 0 ; i != 10 ; ++ i ) { * ( sp . get () + i ) = i ; // 使用get获取一个内置指针 } sp . reset () //使用lambda释放数组，它使用delete[] unique_ptr & weak_ptr unique_ptr拥有它所指指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向 一个给定的对象。当unique_ptr对象被销毁时，它所指向的对象也被销毁。 weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。 通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时的开销。通过 在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。 释放动态数组 typedef int arrT [ 42 ]; // arrT 是一个42个int的数组的类型别名 int * p = new arrT ; // 分配一个42个int的数组，p指向第一个元素 delete [] p ; // 方括号是必须的，因为被分配的是一个数组 析构函数 在一个析构函数中，首先执行函数体（析构函数体被不直接销毁成员），然后销毁成员，成员按初始化顺序的逆序销毁。通常析构函数释放 对象在生存期分配的所有资源。隐式销毁一个内置指针类型的成员不会delete它所指向的对象。与普通指针不同 ，智能指针是类类型，所以有析构函数，智能指针成员在析构阶段会被自动销毁。 自动调用析构函数的情况 - 变量在离开其作用域时被销毁 - 当一个对象被销毁时，其成员被销毁 - 容器被销毁时，其元素被销毁 - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁 - 对于临时对象，当创建它的完整表达式结束时被销毁 删除的函数 我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。 struct NoCopy { NoCopy () = default ; // 使用合成的默认构造函数 NoCopy ( const NoCopy & ) = delete ; // 阻止拷贝 NoCopy & operator = ( const NoCopy & ) = delete ; // 阻止拷贝 ~ NoCopy () = default ; //使用合成析构函数 ｝ 如果有一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应 的成员函数将被定义为删除的。 引用计数 引用计数的工作方式如下： - 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少 对象与正在创建的对象共享状态。当创建一个对象时，计数器初始化为1 - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享 的计数器，指出给定对象的状态又被一个新用户所共享。 - 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构 函数释放状态。 - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器 变为0，拷贝赋值运算符就必须销毁状态。 拷贝和交换 ### HasPtr & HasPtr :: operator = ( HasPtr rhs ) { // rhs 是按值传递的， // 交换左侧运算对象和局部变量rhs的内容 swap ( * this , rhs ); // rhs指向本对象曾经使用的内存 return * this ; // rhs被销毁，从而delete了rhs中的指针 } 右值引用 右值引用就是必须绑定到右值的引用，右值引用有一个重要的性质--只能 绑定到一个将要销毁的对象。 一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是 对象的值。 int i = 42 ; int && rr = i ; // 错误：不能将一个右值引用绑定到一个左值上 int & r2 = i * 42 ; // 错误：i*42是个右值 int && rr2 = i * 42 ; // 正确：将rr2绑定到结果上 移动&拷贝 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过 拷贝构造函数来移动的，拷贝赋值运算符和移动赋值运算符的情况类似。 三/五原则 三个基本的控制类的拷贝操作：拷贝构造函数，拷贝赋值函数，析构函数； 还有两个不新标准下的：移动构造函数，移动赋值函数。这所有五个拷贝控制成员应该看作一个整体； 一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。 引用限定符 引用限定符可以是&或&&，分别指出this可以指一个左值或者右值。类似const限定符，引用限定符 只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。 面向对象程序设计 面向对象程序设计 的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的 接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定 程度上忽略相似类型的区别，而以同意的方式使用它们的对象。 防止继承的发生 如果一个类不想被其他类继承，或者不想考虑它是否适合作为一个基类，C++11新标准提供了一种 防止继承发生的方法，即在类名后跟一个关键字final： class NoDerived final {}; // NoDerived 不能作为基类被继承 纯虚函数 一个纯虚函数无需定义，我们通过在函数体的位置书写=0就可以将一个虚函数 说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处： class base : { public : double f ( int ) const = 0 ; //纯虚函数 }; 尾置返回类型与类型转换 template < typename It > auto fcn ( It beg , It end ) -> decltype ( * beg ) { return * beg ; } 转发 模版转发 template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( std :: forward < T2 > ( t2 ), std :: forward < T1 > ( t1 )); } 可变参数模版转发 template < typename ... Args > void fun ( Args && .. args ) { work ( std :: forward < Args > ( args )...); } 命名空间 命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现 文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义 类及函数的方式： 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象， 则这写成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。 命名空间的成员的定义部分则置于另外的源文件中。 虚继承 虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的 基类子对象称为虚基类（virtual base class）。在这种机制下，不论虚基类 在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类 子对象。 运行时类型识别 运行时类型识别（run-time type identification）的功能由两个运算符实现： - typeid运算符，用于返回表达式的类型 - dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用 在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。","tags":"编程","loc":"www.houcj.net/blog/2015/06/13/cpp/","title":"CPP Primer"},{"text":"有序字典 Contains Duplicate III Given an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k. 分析 使用大小为k的有序字典，这里使用有序字典是为了防止改变元素的相对次序，这样每次搜索的 时候只需要在这个字典里查找即可，而字典的查找是可以在常数时间内完成的。因此时间复杂度为 O（n）。这里有个trick就是设置key = val/t, 这样可以保证每次搜索只需查找 key附近的值是否符合条件即可。 Python Code class Solution : # @param {integer[]} nums # @param {integer} k # @param {integer} t # @return {boolean} def containsNearbyAlmostDuplicate ( self , nums , k , t ): if k < 1 or t < 0 : return False dic = collections . OrderedDict () for val in nums : key = val / t if t else val if dic . get ( key ) or ( dic . get ( key - 1 ) is not None and ( abs ( dic . get ( key - 1 ) - val ) <= t )) or ( dic . get ( key + 1 ) and ( abs ( dic . get ( key + 1 ) - val ) <= t )): return True if len ( dic ) == k : dic . popitem ( False ) dic [ key ] = val return False","tags":"计算机科学","loc":"www.houcj.net/blog/2015/06/01/orderedDict/","title":"Python有序字典"},{"text":"MRO mro() Stands for Method Resolution Order. It returns a list of types the class is derived from, in the order they are searched for methods. 在Python2.3中，MRO算法的基本思想是根据每个祖先类的继承结构，编译出一张列表，包括搜索到的类，按策略删除重复的。但是，在维护单调性方面失败过（顺序保存），所以从Python2.3之后采用了新的C3算法。 C3算法 C3算法最早被提出是用于Lisp的，应用在Python中是为了解决原来基于深度优先搜索算法不满足本地优先级，和单调性的问题。 本地优先级：指声明时父类的顺序，比如C(A,B)，如果访问C类对象属性时，应该根据声明顺序，优先查找A类，然后再查找B类。 单调性：如果在C的解析顺序中，A排在B的前面，那么在C的所有子类里，也必须满足这个顺序。 LEGB 在其他语言中如 C 中，变量名是内存地址的别名，而在 Python 中，名字是一个字符串对象，它与他指向的对象构成一个{name:object}关联。而 LEGB 则是名字空间的一种查找规则。 LEGB 代表名字查找顺序: locals -> enclosing function -> globals -> builtins locals 是函数内的名字空间，包括局部变量和形参 enclosing 外部嵌套函数的名字空间（闭包中常见） globals 全局变量，函数定义所在模块的名字空间 builtins 内置模块的名字空间，轻易不要修改 builtins >>> b Traceback ( most recent call last ): File \"<pyshell#0>\" , line 1 , in < module > b NameError : name 'b' is not defined >>> __builtins__ . b = \"built\" >>> b 'built' 用下标item来获取序列的元素 >>> import operator >>> operator . itemgetter ( 1 , 3 , 5 )( 'ABCDEFG' ) ( 'B' , 'D' , 'F' ) 静态方法、类方法、抽象方法 静态方法 是一类特殊的方法，有时你可能需要写一个属于这个类的方法，但是这些代码完全不会使用到实例对象本身。 类方法 不是绑定到对象上，而是绑定在类上的方法 一个具体的列子：调用静态类 如果你把一个静态方法拆分成多个静态方法，除非你使用类方法， 否则你还是得硬编码类名。使用这种方式声明方法，Pizza类名明永远都不会在被直接引用， 继承和方法覆盖都可以完美的工作。 class Pizza ( object ): def __init__ ( self , radius , height ): self . radius = radius self . height = height @staticmethod # 静态方法，参数没有self def compute_area ( radius ): return math . pi * ( radius ** 2 ) @classmethod # 类方法，可以绑定类的方法 def compute_volume ( cls , height , radius ): return height * cls . compute_area ( radius ) def get_volume ( self ): return self . compute_volume ( self . height , self . radius ) 抽象方法 是定义在基类中的一种方法，它没有提供任何实现，类似于java中接口中的方法。 import abc class BasePizza ( object ): __metaclass__ = abc . ABCMeta @abc.abstractmethod def get_radius ( self ): \"\"\"Method that should do something.\"\"\" >>> BasePizza() Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: Can't instantiate abstract class BasePizza with abstract methods get_radius 上下文管理器 class Closer : '''一个上下文管理器，可以在with语句中 使用close()自动关闭对象''' def __init__ ( self , obj ): self . obj = obj def __enter__ ( self , obj ): return self . obj # 绑定到目标 def __exit__ ( self , exception_type , exception_value , traceback ): try : self . obj . close () except AttributeError : # obj不是可关闭的 print 'Not closable.' return True # 成功地处理了异常 >>> with Closer(int(2)) as i: ... i += 1 >>> i 3 拷贝 copy (self) 定义对类的实例使用 copy.copy() 时的行为。 copy.copy() 返回一个对象的浅拷贝，这意味着拷贝出的实例是全新的，然而里面的数据全都是引用的。 也就是说，对象本身是拷贝的，但是它的数据还是引用的（所以浅拷贝中的数据更改会影响原对象）。 deepcopy (self, memodict=) 定义对类的实例使用 copy.deepcopy() 时的行为。 copy.deepcopy() 返回一个对象的深拷贝， 这个对象和它的数据全都被拷贝了一份。 memodict 是一个先前拷贝对象的缓存，它优化了拷贝过程， 而且可以防止拷贝递归数据结构时产生无限递归。当你想深拷贝一个单独的属性时，在那个属性上调用 copy.deepcopy() ， 使用 memodict 作为第一个参数。 Pickling Pickling是Python数据结构的序列化过程。 下面的例子是 Slate ，它会记住它的值曾经是什么，以及那些值是什么时候赋给它的。 然而 每次被pickle时它都会变成空白，因为当前的值不会被存储: import time class Slate : '''存储一个字符串和一个变更日志的类 每次被pickle都会忘记它当前的值''' def __init__ ( self , value ): self . value = value self . last_change = time . asctime () self . history = {} def change ( self , new_value ): # 改变当前值，将上一个值记录到历史 self . history [ self . last_change ] = self . value self . value = new_value ) self . last_change = time . asctime () def print_change ( self ): print 'Changelog for Slate object:' for k , v in self . history . items (): print ' %s \\t %s ' % ( k , v ) def __getstate__ ( self ): # 故意不返回self.value或self.last_change # 我们想在反pickle时得到一个空白的slate return self . history def __setstate__ ( self ): # 使self.history = slate，last_change # 和value为未定义 self . history = state self . value , self . last_change = None , None function、bound method、unbound method 一个函数(function)是由 def 语句或者 lambda 创建的。 当一个函数(function)定义在了class语句的块中（或者由 type 来创建的), 它会转成一个 unbound method , 当我们通过一个类的实例来 访问这个函数的时候，它就转成了 bound method , bound method 会自动把这个实例作为函数的地一个参数。 所以， bound method 就是绑定了一个实例的方法， 否则叫做 unbound method .它们都是方法(method), 是出现在 class 中的函数。 new & init的区别 当我们需要控制对象的创建操作时，我们需要重写__new__方法，当我们需要控制对象的初始化操作时，我们需要重写__init__ 方法。在创建一个对象的时候，__new__方法被最先调用，然后返回一个对象的实例，然后 __init__方法才被调用，它不返回任何信息，只是初始化对象，给对象的属性赋值。 元类 python中的一切都是对象，它们要么是类的实例，要么是元类的实例，除了type。type实际上是它自己的元类，在纯Python环境中这可不是你能够做到的，这是通过在实现层面耍一些小手段做到的。 GIL 全局解释器锁是一种用来同步线程执行的机制，保证在一个时刻只有一个线程 执行。Python里的全局解释锁必要性的原因主要是由Python的内存管理非线程安全 决定的。 使用GIL还是有一些好处的，主要包括提高单线程程序执行的速度，很容易继承C函数库里那些线程不安全的函数。 附录：Python魔法方法 魔法方法 什么时候被调用 解释 new (cls [,...]) instance = MyClass(arg1, arg2) __new__在实例创建时调用 init (self [,...]) instance = MyClass(arg1,arg2) __init__在实例创建时调用 cmp (self) self == other, self > other 等 进行比较时调用 pos (self) +self 一元加法符号 neg (self) -self 一元减法符号 invert (self) ~self 按位取反 index (self) x[self] 当对象用于索引时 nonzero (self) bool(self) 对象的布尔值 getattr (self, name) self.name #name不存在 访问不存在的属性 setattr (self, name) self.name = val 给属性赋值 __delattr_(self, name) del self.name 删除属性 getattribute (self,name) self.name 访问任意属性 getitem (self, key) self[key] 使用索引访问某个元素 setitem (self, key) self[key] = val 使用索引给某个元素赋值 delitem (self, key) del self[key] 使用索引删除某个对象 iter (self) for x in self 迭代 contains (self, value) value in self, value not in self 使用in进行成员测试 call (self [,...]) self(args) \"调用\"一个实例 enter (self) with self as x: with声明的上下文管理器 exit (self, exc, val, trace) with self as x: with声明的上下文管理器 getstate (self) pickle.dump(pkl_file, self) Pickling setstate (self) data = pickle.load(pkl_file) Pickling","tags":"编程","loc":"www.houcj.net/blog/2015/06/01/improved-python/","title":"Improved Python"},{"text":"排序算法 归并排序 归并排序是分治模式的典型代表. 所谓的分治模式就是将原问题分解为几个 规模较小但类似于原问题的子问题, 递归地求解这些子问题,然后再合并这些子问题的 解来建立原问题的解. Sort List Sort a linked list in O(n log n) time using constant space complexity. 分析 链表的查找需要遍历整个链表,因为应该使用尽可能少的查找操作.这里使用归并排序的算法. 首先找到链表的中点,把链表递归的分成左右两部分,然后对左右两部分进行归并操作. Python Code class Solution : # @param head, a ListNode # @return a ListNode def sortList ( self , head ): if not head or not head . next : return head slow = head fast = head while fast . next and fast . next . next : slow = slow . next fast = fast . next . next head1 = head head2 = slow . next slow . next = None return self . merge ( self . sortList ( head1 ), self . sortList ( head2 )) def merge ( self , head1 , head2 ): if head1 is None : return head2 if head2 is None : return head2 dummy = ListNode ( - 1 ) pre = dummy while head1 and head2 : if head1 . val < head2 . val : pre . next = head1 head1 = head1 . next else : pre . next = head2 head2 = head2 . next pre = pre . next if head1 is None : pre . next = head2 if head2 is None : pre . next = head1 return dummy . next 同时归并排序有很好的并行性 def mergesort '(A, lo, hi): if lo + 1 < hi : # two or more elements mid = ( lo + hi ) / 2 fork mergesort '(A, lo, mid) mergesort '(A, mid, hi) join merge ( A , lo , mid , hi ) 快速排序 快速排序也是使用了分治的思想. 下面是对一个典型的子数组A[lo..hi]的三步分治过程: 分解: 数组A[lo..hi]被划分为左右两个子数组A[lo..q-1], A[q+1..hi],使得左边数组的每个 元素都小于等于A[q],而右边数组的每个元素都大于等于A[q].其中,计算下标q也是划分过程的一部分. 解决: 通过递归调用快速排序,对左右两个子数组进行排序 合并 因为子数组都是原地排序的,所以不需要合并操作:数组A[lo..hi]已经有序. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 分析 将这两个数字，作为一个整体，进行比较。然后一次排序, 就可以得到结果.这里使用快速排序. 给定例子：3,30,34 比较3和30，实际上就是比较330和303哪个大 比较3和34，实际上就是比较334和343哪个大 比较30和34，实际上就是比较3034和3430哪个大 那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。 Python Code class Solution : # @param num, a list of integers # @return a string def largestNumber ( self , num ): def quickSort ( num , low , high ): def partition ( num , low , high ): x = num [ high ] i = low - 1 for j in range ( low , high ): if str ( num [ j ]) + str ( x ) > str ( x ) + str ( num [ j ]): i += 1 num [ i ], num [ j ] = num [ j ], num [ i ] num [ i + 1 ], num [ high ] = num [ high ], num [ i + 1 ] return i + 1 if low < high : q = partition ( num , low , high ) quickSort ( num , low , q - 1 ) quickSort ( num , q + 1 , high ) quickSort ( num , 0 , len ( num ) - 1 ) st = '' . join ( str ( element ) for element in num ) if st [ 0 ] == '0' : return '0' return st 堆排序 Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 分析 可以使用大小为k的小顶堆,小顶堆初始化为各个链表中的首元素(最小值).当从小顶堆 中取出一个元素的时候,就把这个元素所在链表对应的下一个元素加入到 小顶堆中,知道堆为空. Python Code heap = [] dummy = ListNode ( - 1 ) for node in lists : if node : heap . append (( node . val , node )) heapq . heapify ( heap ) head = dummy while heap : tmp = heapq . heappop ( heap ) head . next = ListNode ( tmp [ 0 ]) head = head . next if tmp [ 1 ] . next : heapq . heappush ( heap ,( tmp [ 1 ] . next . val , tmp [ 1 ] . next )) return dummy . next 上面介绍的是基于比较的排序算法。 可以证明基于比较排序算法的下限为O(NlogN)的。 简单证明如下： N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。 下面介绍的非基于比较的线性排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。 但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内) 基数排序 基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 实现方法： 将所有待比较数值（正整数）统一为同样的数位长度， 数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 Maximum Gap 分析 使用基数排序，由于是整数因此以2为底的基数排序即可。每次提取整数的第i位放到0 后者1的桶中。 Python Code class Solution : # @param num, a list of integer # @return an integer def maximumGap ( self , num ): length = len ( num ) if length < 2 : return 0 num = self . radixSort1 ( num ) res = 0 for i in range ( 1 , length ): if res < num [ i ] - num [ i - 1 ]: res = num [ i ] - num [ i - 1 ] return res def radixSort1 ( self , num ): for i in range ( 31 ): bucket = [[] for j in range ( 2 )] for val in num : if ( val >> i ) & 1 : bucket [ 1 ] . append ( val ) else : bucket [ 0 ] . append ( val ) num = [ val for lst in bucket for val in lst ] return num 桶排序 桶排序假设输入数据服从均匀分布，平均时间复杂度为O（n）。桶排序将区间划分为n个大小的子区间， 称为桶。然后先讲桶中的数进行排序，然后遍历每个桶，按照次序依次把各个桶中的元素列出来即可。 def BUCKET_SORT ( A ): n = len ( A ) B = [[ - 1 ] for i in range ( n )] for i in range ( n ): B [ A [ i ] / 10 ] . append ( A [ i ]) for i in range ( n ): B [ i ] . sort () res = [] for i in range ( n ): if len ( B [ i ]) != 1 : for val in B [ i ]: if val != - 1 : res . append ( val ) return res 计数排序 计数排序假设n个输入元素中的每一个都是o到k区间的一个整数,其中k为某个整数.当k=O(n)时 运行时间为O(n). 计数排序的基本思想是:对每一个输入元素x,确定小于x的元素的个数.利用这一信息,就可以直接把x 放到它在输出数组中的位置上了. 计数排序是稳定的 def counting_sort ( A , k ): B , C = [ 0 ] * len ( A ), [ 0 ] * ( k + 1 ) # 包括0和k，长度k+1 for a in A : C [ a ] += 1 for i in range ( 1 , k + 1 ): # 1 to k C [ i ] += C [ i - 1 ] for j in reversed ( range ( len ( A ) - 1 )): # 这里要注意索引从0开始的，所以要-1 B [ C [ A [ j ]] - 1 ] = A [ j ] C [ A [ j ]] -= 1 return B","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/31/sort1/","title":"排序算法"},{"text":"Straight-forward problems that don't require any special technique (e.g. simulation, searching, sorting etc.) In most cases, these problems will ask you to perform some step by step, straight-forward tasks. Their constraints are not high, and not too low. In most cases the first problems (the easiest ones) in topcoder Single Rounds Matches are of this kind. They test mostly how fast and properly you code, and not necessarily your algorithmic skills. Breadth First Search (BFS) Problems that use BFS usually ask to find the fewest number of steps (or the shortest path) needed to reach a certain end point (state) from the starting one. Besides this, certain ways of passing from one point to another are offered, all of them having the same cost of 1 (sometimes it may be equal to another number). Often there is given a N x M table (formed of N lines and M columns) where certain cells are passable and others are impassable, and the target of the problem is to find the shortest time/path needed to reach the end point from the start one. Such tables may represent mazes, maps, cities, and other similar things. These may be considered as classical BFS problems. Because BFS complexity is in most cases linear (sometimes quadratic, or N logN), constraints of N (or M) could be high – even up to 1 million. Flood Fill Sometimes you may encounter problems that are solved by the help of Flood Fill, a technique that uses BFS to find all reachable points. The thing that makes them different from BFS problems described above is that a minimum path/cost is not needed. For example, imagine a maze where 1 represents impassable cells and 0 passable cells. You need to find all cells that are reachable from the upper-left corner. The solution is very simple – take one-by-one a visited vertex, add its unvisited neighbors to the queue of visited vertices and proceed with the next one while the queue is still populated. Note that in most cases a DFS (Depth First Search) will not work for such problems due to stack overflows. Better use a BFS. For inexperienced users it may seem harder to implement, but after a little training it becomes a \"piece of cake\". Brute Force and Backtracking I have placed these 2 techniques in the same category because they are very similar. Both do the same thing – try all possible cases (situations) and choose the best one, or count only those that are needed (depending on the problem). Practically, Backtracking is just more advanced and optimized than Brute Force. It usually uses recursion and is applied to problems having low constraints (for example N<=20). Brute Force There are many problems that can be solved by the help of a simple brute force. Note that the limits must not be high. How does a brute force algorithm work? Actually, it tries all possible situations and selects the best one. It's simple to construct and usually simple to implement. If there is a problem that asks to enumerate or find all possible ways (situations) of doing a certain thing, and that doesn't have high limits – then it's most probably a brute force problem. Backtracking This technique may be used in many types of problems. Just take a look at the limits (N, M and other main parameters). They serve as the main hint of a backtrack problem. If these are very small and you haven't found a solution that's easier to implement – then just don't waste your time on searching it and implement a straight-forward backtracking solution. Dynamic Programming Quite a few problems are solved with the help of this technique. Knowing how to detect this type of problem can be very valuable. However in order to do so, one has to have some experience in dynamic programming. Usually a DP problem has some main integer variables (e.g. N) which are neither too small, nor too big – so that a usual DP complexity of N&#94;2, N&#94;3 etc. fits in time. Note that in the event that N is very small (for TC problems usually less than 30) – then it is likely the problem is not a DP one. Besides that there should exist states and one or more ways (rules) to reach one greater state from another lower one. In addition, greater states should depend only upon lower states. What is a so-called state? It's just a certain configuration or situation. PS:有超链接符号的都是已经写过的文章，xmind导出到pdf会丢失超链接信息","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/28/find-a-solution/","title":"How to find a solution"},{"text":"查找算法 顺序查找 条件： 无序或有序数组 原理： 按顺比较每个元素，直到知道关键字为止。 时间复杂度： O(n) Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 分析 intervals中的值已经排序,因此如果没有 可以直接append到result中.首先根据newInterval.start的值, 确定其在Intervals中的位置,然后再根据newInterval的start和end值进行 merge,如果最后的元素还有剩余就全部append到result中. Python Code class Solution : # @param {Interval[]} intervals # @param {Interval} newInterval # @return {Interval[]} def insert ( self , intervals , newInterval ): n = len ( intervals ) if n == 0 : return [ newInterval ] res = [] i = 0 while i < n and intervals [ i ] . end < newInterval . start : res . append ( intervals [ i ]) i += 1 start = newInterval . start end = newInterval . end while i < n and intervals [ i ] . start <= newInterval . end : start = min ( start , intervals [ i ] . start ) end = max ( end , intervals [ i ] . end ) i += 1 res . append ( Interval ( start , end )) while i < n : res . append ( intervals [ i ]) i += 1 return res First Missing Positive Given an unsorted integer array, find the first missing positive integer. For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 分析 这里只需要把正确的位置放上正确的元素即可。如把4放在A[3]的位置 Python Code class Solution : # @param A, a list of integers # @return an integer def firstMissingPositive ( self , A ): n = len ( A ) for i in range ( n ): while A [ i ] > 0 and A [ i ] <= n and A [ i ] != A [ A [ i ] - 1 ] : A [ A [ i ] - 1 ], A [ i ] = A [ i ], A [ A [ i ] - 1 ] for x in range ( n ): if A [ x ] != x + 1 : return x + 1 return n + 1 二分查找 条件： 有序数组 原理： 查找过程从数组的中间元素开始， 如果中间元素正好是要查找的元素，则搜素过程结束； 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。 如果在某一步骤数组为空，则代表找不到。 每一次比较都使搜索范围缩小一半。 时间复杂度： O(lgn) Search in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 分析 虽然这个数组不是完全有序的，但是每次的左半部分或者右半部分都是 有序的，这样我们使用二分查找，每次都可以去掉一半的不符合条件的值。 同时注意边界条件。 Python Code class Solution : # @param A, a list of integers # @param target, an integer to be searched # @return an integer def search ( self , A , target ): if not A : return - 1 length = len ( A ) l = 0 r = length - 1 while l <= r : mid = ( l + r ) / 2 if A [ mid ] == target : return mid if A [ mid ] < A [ r ]: if A [ mid ] < target <= A [ r ]: l = mid + 1 else : r = mid - 1 else : if A [ l ] <= target < A [ mid ]: r = mid - 1 else : l = mid + 1 return - 1 下面是常见的二分查找的Algorithm puzzle exapmles： Given A a sorted array find out how many times does x occur in A. Given a real number x, find out its cubic root. Given A a sorted array with distinct numbers, find out an i such that A[i] == i. Given the +,-,*,/,sqrt operations and a real number x find an algorithm to get log_2_x. Given an array of distinct numbers A such that A[0] > A[1] and A[n-1] > A[n-2] find out a local minimum (find out an i such that A[i-1] > A[i] < A[i + 1]). Let A be a sorted array with distinct elements. A is rotated k positions to the right (k is unknown). Find out k. Let A be a sorted array with distinct elements. A is rotated k positions to the right (k is unknown). Find out if A contains a number x. Given two sorted arrays of length n and m, find out the kth element of their sorted union. Given A, an array comprised of an increasing sequence of numbers followed immediately by a decreasing one. Determine if a given number x is in the array. Given an array of N distinct int values in ascending order, determine whether a given integer is in the array. You may use only additions and subtractions and a constant amount of extra memory. Player A chooses a secret number n. Player B can guess a number x and A replies how does x compare to n (equal, larger, smaller). What's an efficient strategy for B to guess n. Hash表查找 条件： 先创建哈希表 原理： 根据key value进行查找，通过hash函数定位数据元素。 时间复杂度： 平均复杂度为O（1），取决于冲突的大小。 Two Sum Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 分析 可以使用字典存储该元素以及它所对应的下标，那么如果两个元素的和满足target。 就可以直接根据他们的值线性时间取出他们的下标，时间复杂度为 O(n)。 可能需要遍历表中的所有元素。 Python Code class Solution : # @return a tuple, (index1, index2) def twoSum ( self , num , target ): dic = {} length = len ( num ) for index in range ( length ): dic [ num [ index ]] = index + 1 for i in range ( length ): if dic . get ( target - num [ i ]): if i + 1 != dic [ target - num [ i ]]: return i + 1 , dic [ target - num [ i ]]","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/28/search/","title":"查找算法"},{"text":"动态规划本质是一种递推，使用空间存储中间的状态，动态规划的关键是 找到状态转移方程。复杂度是状态总数*某状态下的最大转移数。动态规划可以 自底向上或者自顶向下 Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1...n? For example, Given n = 3, there are a total of 5 unique BST's. 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 分析 定义状态: F[n]表示二叉树中有n个节点时unique BST的数目。 那么假设根节点为k时，这时unique BST的数目为以k为根节点的左子树数目*以k为节点的右子树数目。 那么F[n]的值就等于从1到n依次为根节点时的unique BST的数目之和。 \\begin{equation*} F[n]=\\sum_{i=1}&#94;{n}F[i]*F[n-i-1] \\end{equation*} 因此是个一维的动态规划。 Python Code class Solution : # @return an integer def numTrees ( self , n ): cunt = [ 0 for i in range ( n + 1 )] cunt [ 0 ] = 1 cunt [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( 0 , i ): cunt [ i ] += cunt [ j ] * cunt [ i - 1 - j ] return cunt [ n ] House Robber II Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 分析 首先先处理线性的情况。 由于只有相邻的house才会产生影响，与邻居的邻居是无关的。 dp[n]表示到第n个house是的最大收益。那么可以得到相应的 状态转移方程为： \\begin{equation*} dp[n] = max(dp[n-2]+num[n], dp[n-1]) \\end{equation*} 对于圆形的情况，当取第一个元素的时候，就不能取第n个元素。如果不取 第一个元素，剩下的元素就可以转化为线性的问题。比较这两种情况的最大值即可。 Python Code class Solution : # @param {integer[]} nums # @return {integer} def rob ( self , nums ): if len ( nums ) < 2 : return nums [ 0 ] if nums else 0 return max ( self . robber ( nums [: - 1 ]), self . robber ( nums [ 1 :])) def robber ( self , nums ): length = len ( nums ) if length < 2 : return nums [ 0 ] if nums else 0 dp = [ 0 for x in range ( length )] dp [ 0 ] = nums [ 0 ] dp [ 1 ] = max ( nums [ 0 ], nums [ 1 ]) for i in range ( 2 , length ): dp [ i ] = max ( dp [ i - 2 ] + nums [ i ], dp [ i - 1 ]) return dp [ length - 1 ] Edit Distance Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a character b) Delete a character c) Replace a character 分析 我们采用自底向上的动态规划的解法，那么当前的状态可以由它的上一步的状态决定。 由于两个字符串，因此需要两维的数组来存储这些状态。 dp[i][j]表示word1的从最后一个字符到第i单词与word2从最后一个字符到第j个字符所需要的 最少的编辑距离。 \\begin{equation*} dp[i][j] = min(dp[i+1][j]+1, dp[i][j+1]+1, dp[i+1][j+1]+t[i][j]) \\end{equation*} \\begin{equation*} t[i][j] = \\begin{cases} 1, & \\mbox{word1}[i] == \\mbox{word2}[j] \\\\ 0, & \\mbox{word1}[i] != \\mbox{word2}[j] \\end{cases} \\end{equation*} Python Code class Solution : # @return an integer def minDistance ( self , word1 , word2 ): n = len ( word1 ) m = len ( word2 ) dp = [[ 0 for x in range ( m + 1 )] for y in range ( n + 1 )] for j in range ( m + 1 ): dp [ 0 ][ j ] = j for i in range ( n + 1 ): dp [ i ][ 0 ] = i for i in range ( n ): for j in range ( m ): tmp = 0 if word1 [ i ] == word2 [ j ] else 1 dp [ i + 1 ][ j + 1 ] = min ( dp [ i ][ j + 1 ] + 1 , dp [ i + 1 ][ j ] + 1 , dp [ i ][ j ] + tmp ) return dp [ n ][ m ] Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area. For example, given the following matrix: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Return 4. 分析 定义状态：dp[i][j]表示在第i行第j列时，最大的square size，我们知道 一个正方形的size，就可以很容易求它的面积。这里采用自定向下的动态规划。 当matrix里的元素为0时，dp[i][j]为0，因为这时候不能形成一个全为1的正方形。 当matrix里的元素为1时，很容易得到下面的递推方程。 \\begin{equation*} dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 \\end{equation*} dp[i][j]在第一行，以及第一列时与matrix中的元素保持一致。 Python Code class Solution : # @param {character[][]} matrix # @return {integer} def maximalSquare ( self , matrix ): m = len ( matrix ) if not m : return 0 n = len ( matrix [ 0 ]) maxSize = 0 for j in range ( n ): if matrix [ 0 ][ j ] == '1' : maxSize = 1 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == '1' : matrix [ i ][ j ] = int ( min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ])) + 1 if matrix [ i ][ j ] > maxSize : maxSize = matrix [ i ][ j ] return maxSize * maxSize if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2015/05/27/dong-tai-gui-hua/","title":"动态规划"},{"text":"选择问题 输入： 一个包含n个元素的集合A和一个整数i， 1 ≤ i ≤ n 输出： 元素x属于A，且A中恰好有i-1个元素小于（大于）它。 Find Minimum in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 分析 我们知道，旋转后的左右部分都是有序的，若中间元素小于右边的元素，则最小值一定在 左边的集中，否则就在右边的集合中。 Python Code 递归版本 class Solution : # @param num, a list of integer # @return an integer def findMin ( self , num ): n = len ( num ) left , right = 0 , n - 1 while left < right and num [ left ] > num [ right ] : mid = left + ( right - left ) / 2 if num [ mid ] <= num [ right ]: right = mid else : left = mid + 1 return num [ left ] 迭代版本 class Solution : # @param num, a list of integer # @return an integer def findMin ( self , num ): length = len ( num ) if length < 4 : return min ( num ) left , right = 0 , length - 1 while left < right and num [ left ] > num [ right ]: mid = ( right - left ) / 2 + left if num [ mid ] > num [ right ]: left = mid + 1 else : right = mid return num [ left ] 第k大元素 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array's length. 分析 这里使用一个期望为O（n）的算法， 空间复杂度为O(lgn)的算法。 随机从集合中选出一个元素，使用和快排类似的partion算法，找到这个元素在集合中的新位置index 由于是第k大，因此比较 n-index-1 与 k 的大小。如果相等则即为找到的元素 如果n-index-1 < n-k，递归处理左半部分,其中k = k - (n-index-1) 否则递归处理右半部分。 Python Code import random class Solution : def findKthLargest ( self , nums , k ): n = len ( nums ) if n == 1 : return nums [ 0 ] q = random . randint ( 0 , n - 1 ) nums [ - 1 ], nums [ q ] = nums [ q ], nums [ - 1 ] pivort = nums [ - 1 ] i = - 1 for j in range ( n - 1 ): if nums [ j ] <= pivort : i += 1 nums [ i ], nums [ j ] = nums [ j ], nums [ i ] nums [ i + 1 ], nums [ - 1 ] = nums [ - 1 ], nums [ i + 1 ] cnt = n - i - 1 if cnt == k : return pivort if cnt > k : return self . findKthLargest ( nums [ n - cnt + 1 :], k ) elif cnt < k : return self . findKthLargest ( nums [: n - cnt ], k - cnt ) 下面的例子是findK应用的推广 两个排序数组的中的中位数 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 分析 由于数组已经是排序的，因此使用上面的findK算法，每次都可以确定的缩小一半的查找范围。同时，如果两个数组长度 之和为偶数，中位数为连个中间数的平均数，如果为奇数，则中位数即为中间数。 Python Code class Solution : # @return a float def findMedianSortedArrays ( self , A , B ): lenA = len ( A ) lenB = len ( B ) length = lenA + lenB if length % 2 == 1 : return self . findKth ( A , B , length / 2 + 1 ) else : return ( self . findKth ( A , B , length / 2 ) + self . findKth ( A , B , length / 2 + 1 )) / 2.0 def findKth ( self , A , B , k ): if len ( A ) > len ( B ): return self . findKth ( B , A , k ) if len ( A ) == 0 : return B [ k - 1 ] if k == 1 : return min ( A [ 0 ], B [ 0 ]) pa = min ( k / 2 , len ( A )) pb = k - pa if A [ pa - 1 ] < B [ pb - 1 ]: return self . findKth ( A [ pa :], B , k - pa ) // select from the remainder A and B elif A [ pa - 1 ] > B [ pb - 1 ]: return self . findKth ( A , B [ pb :], k - pb ) else : return A [ pa - 1 ]","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/24/select/","title":"选择算法"},{"text":"把二叉查找树保存到文件中 Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. You must be able to restore to the exact original BST using the saved format. 由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历 或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过 中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来 构造一棵二叉树。 构造二叉树的代码如下： void readBSTHelper ( int min , int max , int & insertVal , BinaryTree *& p , ifstream & fin ) { if ( insertVal > min && insertVal < max ) { int val = insertVal ; p = new BinaryTree ( val ); if ( fin >> insertVal ) { readBSTHelper ( min , val , insertVal , p -> left , fin ); readBSTHelper ( val , max , insertVal , p -> right , fin ); } } } void readBST ( BinaryTree *& root , ifstream & fin ) { int val ; fin >> val ; readBSTHelper ( INT_MIN , INT_MAX , val , root , fin ); } Serialization|Deserialization of a Binary Tree Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called ‘serialization' and reading back from the file to reconstruct the exact same binary tree is ‘deserialization'. 在二叉排序树中，中序遍历是有序的，而普通的二叉树就没有这样的性质。因此需要使用哨兵来输出那些空的节点，来最终确定每个 节点的位置。这里使用前序遍历。 Cpp Code void writeBinaryTree ( BinaryTree * p , ostream & out ) { if ( ! p ) { out << \"# \" ; } else { out << p -> data << \" \" ; writeBinaryTree ( p -> left , out ); writeBinaryTree ( p -> right , out ); } } 从文件中读取这个二叉树的操作也是类似的。我们同样使用先序遍历，如果遍历到的节点是一个哨兵，说明是 空节点，我们忽视这个节点就好。如果是一个具体的数值，我们就把它插入到当前的节点，然后遍历它的左孩子， 然后遍历它的右孩子。 Cpp Code void readBinaryTree ( BinaryTree *& p , ifstream & fin ) { int token ; bool isNumber ; if ( ! readNextToken ( token , fin , isNumber )) return ; if ( isNumber ) { p = new BinaryTree ( token ); readBinaryTree ( p -> left , fin ); readBinaryTree ( p -> right , fin ); } } 当然我们也可以使用层次遍历。 Printing a Binary Tree in Level Order Given a binary tree, print out the tree in level order (ie, from left to right, level by level). Output a newline after the end of each level. 3 / \\ 9 20 / \\ 15 7 For example, the level order output of the tree above is: 3 9 20 15 7 可以使用BFS或者DFS BFS 使用BFS时，需要记录一层的节点数目，以及下层的节点数目。当这层的 节点数目为0的时候，说明这层的节点已经完全被输出。然后接着输出下一层。 void printLevelOrder ( BinaryTree * root ) { if ( ! root ) return ; queue < BinaryTree *> nodesQueue ; int nodesInCurrentLevel = 1 ; int nodesInNextLevel = 0 ; nodesQueue . push ( root ); while ( ! nodesQueue . empty ()) { BinaryTree * currNode = nodesQueue . front (); nodesQueue . pop (); nodesInCurrentLevel -- ; if ( currNode ) { cout << currNode -> data << \" \" ; nodesQueue . push ( currNode -> left ); nodesQueue . push ( currNode -> right ); nodesInNextLevel += 2 ; } if ( nodesInCurrentLevel == 0 ) { cout << endl ; nodesInCurrentLevel = nodesInNextLevel ; nodesInNextLevel = 0 ; } } } DFS 使用DFS时需要记录递归的深度，根据递归的深度来确定层数 class Solution : # @param root, a tree node # @return a list of lists of integers def levelOrder ( self , root ): res = [] def dfs ( root , depth ): if root : if self . cur == depth : res . append ([ root . val ]) self . cur += 1 else : res [ depth ] . append ( root . val ) dfs ( root . left , depth + 1 ) dfs ( root . right , depth + 1 ) if root : self . cur = 0 dfs ( root , 0 ) return res Morris二叉树遍历算法 对于二叉树的遍历，可以使用递归或者堆栈，但morris遍历，使用 无堆栈，O（1）空间进行二叉树遍历。 原理 利用所有叶子节点的右指针，指向其后继节点，形成一个环，在第二次遍历到这个节点时， 由于左子树已经遍历完了，则访问该节点。 中序遍历 算法伪码： 1. Initialize current as root 2. While current is not NULL If current does not have left child a) Print current's data b) Go to the right, i.e., current = current->right Else a) Make current as right child of the rightmost node in current's left subtree b) Go to this left child, i.e., current = current->left Python Code def morris_inorder ( self , root ): res = [] p = root while p : if p . left is None : res . append ( p . val ) p = p . right else : tmp = p . left while tmp . right and tmp . right != p : tmp = tmp . right if tmp . right is None : tmp . right = p p = p . left else : res . append ( p . val ) tmp . right = None p = p . right return res Morris的前序遍历和中序遍历比较类似，只不过在前驱节点为空的时候，直接输出当前的节点 后序遍历 后序遍历比较复杂，需要建立一个临时节点dump，令其左孩子为root，并且需要一个倒序输出某两个节点 之间路径的各个节点的自过程。 具体实现和测试代码见 Github Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 分析 根据左右子树的高度判断下次从左子树还是右子树进行查找，类似二分查找，时间复杂度为O（lgn）*O(lgn)树高 因此总的时间复杂度为O（lgn&#94;2），具体实现有很多方式，需要注意的是，当判断这棵树为完全树的时候 应该马上返回它的节点数目，以此加快递归的返回速度。 CPP Code class Solution { public : int countNodes ( TreeNode * root ) { if ( root == NULL ) return 0 ; TreeNode * L = root ; TreeNode * R = root ; int height = 0 ; while ( R ) { height += 1 ; L = L -> left ; R = R -> right ; } if ( L == NULL ) { return ( 1 << height ) - 1 ; } return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Convert Sorted List to Balanced Binary Search Tree (BST) Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 由于链表只能顺序遍历，因此最优的解法应该是在遍历链表的同时，构造这个二叉查找树。 因此我们采取bottom-up(而非通常的top-down)的方法，从底到上创建二叉查找树节点，然后把他们分配到它们的父亲节点中 这样就可以一边遍历，一遍构造二叉查找树。 BinaryTree * sortedListToBST ( ListNode *& list , int start , int end ) { if ( start > end ) return NULL ; // same as (start+end)/2, avoids overflow int mid = start + ( end - start ) / 2 ; BinaryTree * leftChild = sortedListToBST ( list , start , mid - 1 ); BinaryTree * parent = new BinaryTree ( list -> data ); parent -> left = leftChild ; list = list -> next ; parent -> right = sortedListToBST ( list , mid + 1 , end ); return parent ; } BinaryTree * sortedListToBST ( ListNode * head , int n ) { return sortedListToBST ( head , 0 , n - 1 ); } Convert Binary Search Tree (BST) to Sorted Doubly-Linked List 同上面的方法类似，我们可以采用中序遍历的方法，把每个遍历到的节点依次插入到 双向链表中，同时保持双向链表的有序性 void treeToDoublyList ( Node * p , Node *& prev , Node *& head ) { if ( ! p ) return ; treeToDoublyList ( p -> left , prev , head ); // current node's left points to previous node p -> previous = prev ; if ( prev ) prev -> next = p ; // previous node's right points to current node else head = p ; // current node (smallest element) is head of // the list if previous node is not available // as soon as the recursion ends, the head's left pointer // points to the last node, and the last node's right pointer // points to the head pointer. Node * right = p -> right ; head -> previous = p ; p -> next = head ; // updates previous node prev = p ; treeToDoublyList ( right , prev , head ); } // Given an ordered binary tree, returns a sorted circular // doubly-linked list. The conversion is done in-place. Node * treeToDoublyList ( Node * root ) { Node * prev = NULL ; Node * head = NULL ; treeToDoublyList ( root , prev , head ); return head ; }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/18/binary-tree/","title":"二叉树"},{"text":"和树的遍历类似，关于的图的遍历一般也有两种，深度优先和宽度优先。 课程安排 I&II There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 分析 核心是遍历图，确定图中节点的数目，以及图中是否有环。其中课程安排II的核心是根据拓扑排序后的节点约束的如果小于课程数目，则剩下的按正常排序即可（节点之间没有前后的约束关系），这里可以使用 Topological sorting 具体深度优先的算法如下 L = Empty list that will contain the sorted nodes while there are unmarked nodes do select an unmarked node n visit ( n ) function visit ( node n ) if n has a temporary mark then stop ( not a DAG ) if n is not marked ( i . e . has not been visited yet ) then mark n temporarily for each node m with an edge from n to m do visit ( m ) mark n permanently unmark n temporarily add n to head of L 具体实现 def findOrder ( self , numCourses , prerequisites ): self . lst = [] self . visited = [ - 1 ] * numCourses self . hascyle = False for edge in prerequisites : if self . visited [ edge [ 0 ]] == - 1 : self . visit ( edge [ 0 ], prerequisites ) if self . hascyle : return [] for i in range ( numCourses ): if i not in self . lst : self . lst . append ( i ) return self . lst def visit ( self , node , prerequisites ): if self . visited [ node ] == 0 : self . hascyle = True return if self . visited [ node ] == - 1 : self . visited [ node ] = 0 for edge in prerequisites : if edge [ 0 ] == node : self . visit ( edge [ 1 ], prerequisites ) #self.visited[node] =-1 self . visited [ node ] = 1 self . lst . append ( node ) 发现岛的数目 Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110 11010 11000 00000 Answer: 1 Example 2: 11000 11000 00100 00011 Answer: 3 分析 这道题其实是求连通分支的个数。可以采取DFS, 或者BFS。下面采用的是DFS，在每次的 DFS调用中，就会找到一个连通分支，直到遍历图中的所有节点找到所有的连通分支。 def numIslands ( self , grid ): m = len ( grid ) if m < 1 : return 0 n = len ( grid [ 0 ]) visited = [[ 0 for i in range ( n )] for j in range ( m )] def dfs ( row , col ): visited [ row ][ col ] = 1 if row > 0 and grid [ row - 1 ][ col ] == '1' and not visited [ row - 1 ][ col ]: dfs ( row - 1 , col ) if row < m - 1 and grid [ row + 1 ][ col ] == '1' and not visited [ row + 1 ][ col ]: dfs ( row + 1 , col ) if col > 0 and grid [ row ][ col - 1 ] == '1' and not visited [ row ][ col - 1 ]: dfs ( row , col - 1 ) if col < n - 1 and grid [ row ][ col + 1 ] == '1' and not visited [ row ][ col + 1 ]: dfs ( row , col + 1 ) count = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == '1' and not visited [ i ][ j ]: dfs ( i , j ) count += 1 return count","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/13/graph/","title":"图论"},{"text":"内存管理 ，对于Python这样的动态语言是必不可少的。通常的内存管理包括操作系统提供的虚拟内存，以及 垃圾回收机制。本文着重于Python中的垃圾回收机制。 首先我们介绍一下的垃圾回收中通用的基本概念 垃圾回收 如果一个程序可能直接或间接地引用一个对象，那么这个对象就是\"存活的\"，已经引用不到的对象就是\"死亡\" 的。垃圾回收就是要自动的收集并释放这些死亡的对象。 垃圾回收中常见的算法 1. 标记清除(Mark and Sweep) 原理 首先从根开始将可能引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。 根 所谓根就是判断对象是否可被引用的起始点。虽然不同的语言编译器对根的规定不同，但基本上是讲变量和运行栈 作为根。 标记清除算法的时间是和存活对象数与对象总数的综合相关的。 还有一种变形 缺点 在分配了大量的对象，并且其中只有一部分存活的情况下，所消耗的时间会大大超过必要的值，这时因为 在清除阶段还需要对大量死亡对象进行扫描。 标记压缩(Mark and Compact) 它不是将标记的对象清除，而是在清理无用对象完成后让所有存活的对象都向一端移动， 并更新引用其对象的指针，节约了内存空间 缺点 压缩过程较慢，效率较低。 复制收集(Copy and Collection) 将从根节点开始被引用的对象复制到另外的空间中，然后将复制的对象能够引用的对象用递归的方式不断复制 下去。 优点 有很好的局部性。在复制过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的 内存空间中的可能性会提高。 缺点 内存减少一半，可用空间减少 2. 引用计数 原理 在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。 引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束等时间点。当一个对象的引用计数变为0时， 则说明它将来不会被引用，因此可以释放相应的内存空间。 缺点 无法回收循环引用 维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 3. 分代回收 由于GC和程序处理的本质是无关的，因此它消耗的时间越短越好。分代回收的目的就是为了在程序运行期间，将GC所 消耗的时间尽量缩短，是一种空间换时间的策略。 思路 利用一般性程序所具备的性质，即大部分对象在短时间内都会成为垃圾，而经过一定时间依然存活的对象往往 拥有较长的寿命。 增量回收 不等GC全部完成，而是将GC操作细分成多个部分逐一执行。这种方式被成为增量回收。 GC大一统理论 像标记清除和复制收集这样，从根开始进行扫描以判断对象生死的算法，被称为追踪回收（Tracing）。引用 计数算法则是当对象之间的引用关系发生变化时，通过对引用技术进行更新来判断对象生死的。 任何一种GC算法，都是追踪回收和引用计数回收两种思路的组合。 下面就结合Python源码具体说下Python中垃圾回收的实现，更多源码见 Python 源码剖析 Python垃圾回收中的引用计数 每个Python对象都有一个Pyobject_HEAD // object.h struct _object { Py_ssize_t ob_refcnt ; // 应用计数值 struct PyTypeObject * ob_type ; } PyObject ; 其中 ob_refcnt就是利用引用技术来进行垃圾回收的数据结构。 在容器中有循环引用出现的情况下，Python就辅助使用标记清除和分代回收来解决这样的问题。 Python垃圾回收中的标记清除 Python中的垃圾回收机制完全是为了处理循环引用而设计的。 所有容器对象在PyObject_HEAD之前加入PyGC_HEAD来实现标记清除机制。 // objimpl.h typedef union _gc_head { struct { union _gc_head * gc_next ; union _gc_head * gc_prev ; Py_ssize_t gc_refs ; } gc ; long double dummy ; /* force worst-case alignment */ } PyGC_Head ; 垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)： // gcmodule.c static void update_refs ( PyGC_Head * containers ) { PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { assert ( gc -> gc . gc_refs == GC_REACHABLE ); gc -> gc . gc_refs = FROM_GC ( gc ) -> ob_refcnt ; assert ( gc -> gc . gc_refs != 0 ); } } 然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1： // gcmodule.c static void subtract_refs ( PyGC_Head * containers ) { traverseproc traverse ; PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { traverse = FROM_GC ( gc ) -> ob_type -> tp_traverse ; ( void ) traverse ( FROM_GC ( gc ), ( visitproc ) visit_decref , NULL ); } } 然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象。 // gcmodule.c static void move_unreachable ( PyGC_Head * young , PyGC_Head * unreachable ) { PyGC_Head * gc = young -> gc . gc_next ; while ( gc != young ) { PyGC_Head * next ; // 对于root object，把gc_refs设置为GC_REACHABLE if ( gc -> gc . gc_refs ) { PyObject * op = FROM_GC ( gc ); traverseproc traverse = op -> ob_type -> tp_traverse ; assert ( gc -> gc . gc_refs > 0 ); gc -> gc . gc_refs = GC_REACHABLE ; ( void ) traverse ( op , ( visitproc ) visit_reachable , ( void * ) young ); next = gc -> gc . gc_next ; } // 对于非root对象移到unreachable链表中，并标记为 // GC_TENTATIVELY_UNREACHABLE else { next = gc -> gc . gc_next ; gc_list_move ( gc , unreachable ); gc -> gc . gc_refs = GC_TENTATIVELY_UNREACHABLE ; } gc = next ; } } 在处理完finalizer等细节之后，就可以对unreasonable链表中的节点进行回收 Python垃圾回收中的分代回收 用来表示\"代\"的结构体是gc_generation， 包括了当前代链表表头、对象数量上限、当前对象数量： // gcmodule.c struct gc_generation { PyGC_Head head ; int threshold ; /* collection threshold */ int count ; /* count of allocations or collections of younger generations */ }; Python默认定义了三代对象集合，代数越大，对象存活时间越长。 #define NUM_GENERATIONS 3 #define GEN_HEAD(n) (&generations[n].head) /* linked lists of container objects */ static struct gc_generation generations [ NUM_GENERATIONS ] = { /* PyGC_Head, threshold, count */ {{{ GEN_HEAD ( 0 ), GEN_HEAD ( 0 ), 0 }}, 700 , 0 }, {{{ GEN_HEAD ( 1 ), GEN_HEAD ( 1 ), 0 }}, 10 , 0 }, {{{ GEN_HEAD ( 2 ), GEN_HEAD ( 2 ), 0 }}, 10 , 0 }, }; 最后在进行垃圾回收的时候，Python从最老的一代（第二代）开始，然后回收这个代 和比它年轻的代。 //gcmodule.c //NUM_GENERATIONS = 3 static Py_ssize_t collect_generations ( void ) { int i ; py_ssize_t n = 0 ; for ( i = NUM_GENERATIONS ; i >= 0 ; i -- ){ if ( generations [ i ]. count > generations [ i ]. threshold ){ n = collect ( i ); break ; } } return n ; } 总结： Python采用了最常用的引用计数来跟踪和回收垃圾。在引用计数的基础上， 通过\"标记-清除\"解决容器对象可能产生的循环引用问题， 通过\"分代回收\"以空间换时间的方法提高垃圾回收效率。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/10/garbage-collection-in-python/","title":"Python中的垃圾回收机制"},{"text":"无论使用什么编程语言，生产一条基本语句所需要的工数几乎是一定的。 —弗雷德里克·布鲁克斯 特定领域语言(Domain Specific Language) 指利用为特定领域所专门设计的词汇和语法，简化程序设计过程，提高 生产效率的技术。 优点 可以直接使用其对象领域中的概念，集中描述\"what\"部分，而不必对\"how\" 进行描述。 外部DSL 像这些迷你语言为代表的，由专用的语言引擎来实现的DSL，称为外部DSL。 XML、SQL、正则表达式就是典型的外部DSL 内部DSL 内部DSL是在现在语言中实现DSL，而作为DSL基础的这种现有语言，称为数组语言。 外部DSL是从UNIX脱胎发展而来的，而内部DSL则是发源于Lisp和Smalltalk Programming is a process of designing DSL for your own application —— 大卫·托马斯 DSL设计的构成要素 上下文（Context） 语句 （Sentence） 单位 （Unit） 词汇 （Vocabulary） 层次结构 （Hierarchy） 元编程 所谓元编程就是用程序来编写程序。在Ruby和Python这样的语言中，由于程序本身的信息是可以被访问的， 因此在程序运行中也可以对程序本身进行操作，这就是元编程。 反射 在C++中，一个对象是知道自己的数据类型的， 通过这个信息，可以在调用虚拟成员函数时，选择与自己的类型相匹配的函数。 像这样获取和变更程序本身信息的功能，被称为反射（Reflection）。 闭包 在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。 对象：在数据中以方法的形式包含了过程 闭包：在过程中以环境的形式包含了数据 动态运行 就是在运行后总的程序能够识别自身，并对自身进行操作。而程序对自身操作的编程也被称为元编程。 鸭子类型(Duck Typing) 不考虑某个对象到底是哪个类的实例，而只关心它拥有哪些方法，这就是鸭子类型。 结构子类型(Structuaral Subtyping) 以类型的结构来确定可代换性的类型关系，被称为结构子类型。 名义子类型 (Nominal Subtyping) 像Java这样根据声明拥有继承关系的类型具有可代换性的类型关系，被称为名义子类型。 非强制静态类型 在Dart中，没有指定类型的变量和表达式会被当做Dynamic型，其类型检查在运行时完成。 提高动态语言速度的三种技术 JIT(Just In Time Compiler)，指的是在程序运行时将其编译为机器语言的技术。由于编译为机器语言的程序可以以CPU原本的 速度来运行，因此能够克服解释器所带来的劣势。 特殊化，指的是一种在将函数转换为内部表达时所需用的技术。通常假定参数为特殊类型， 事先准备一个特殊化的高速版本，在函数调用的开头先执行类型检查，当前提条件成立时直接运行 高速版本，从而避免了在运行时伴随的大量的类型检查。 分代回收，见 垃圾回收 。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/09/programming-language/","title":"编程语言中的基本概念"},{"text":"编程&技术 1. 系统架构&设计模式 大型网站技术架构 [Done] 设计模式可重用面向对象软件的基础 [10%] 简约之美：软件设计之道 [0%] 重构:改善既有代码的设计 [50%] 关于系统架构和设计模式的东西了解的不多，至少一些基本原理和方法还是需要懂的 2. 计算机科学 网络 TCP/IP详解卷1 [Done] TCP/IP详解卷2 [30%] Unix网络编程 [10%] 数据结构与算法 算法导论 [Done] 算法概论 [Done] 编程珠玑 [Done] 编程之美 [Done] 剑指offer [Done] Cracking the Coding Interview [60%] 具体数学 [10%] 算法竞赛入门经典训练指南 [10%] 操作系统 深入理解计算机系统 [Done] 鸟哥的Linux私房菜 [Done] Unix 环境高级编程 [20%] 编程语言&程序设计 C C专家编程 [Done] C陷阱和缺陷 [Done] C和指针 [10%] K&R [10%] C++ C++ primer [Done] Effective C++ [10%] More Effective C++ [20%] Inside CPP [Done] Python Python基础教程 [Done] Python核心编程 [Done] Django Web开发指南 [Done] 改善Python代码的91个意见[Done] Python高级编程 [40%] Python 源码剖析 [20%] 机器学习 数学之美 [Done] 集体智慧编程 [Done] 统计学习方法 [Done] 机器学习实战 [10%] 程序设计 计算机程序的构造与解释 [70%] 编程实践 代码的未来 [Done] 可读代码的艺术 [10%] 7周7语言 [10%] The Progmatic Programmer [Done] 程序员的自我修养-链接装载与库 [30%] 其它 Shell Mysql 正则表达 3.软件开发 UNIX编程艺术 [30%] 人件 [10%] 人月神话 [30%] 高效能程序员的45个习惯：敏捷开发之道 [10%] 程序员的思维修炼: 开发认知潜能的九堂课 [25%] 4. 科技人文 浪潮之巅 [Done] 淘宝技术这十年 [Done] 乔布斯转 [Done] 悟空转 [Done] 黄金时代 [Done] 三体1 [Done] 三体2 [40%] 三体3 [23%] 白银时代 [30%] 世界是平的 [Done] 淘宝技术这十年 [Done] mactalk 人生元编程 [Done] 菊与刀 [Done] 5.思维 禅与摩托车维修艺术 [Done] 自控力 [Done] 天才在左，疯子在右 [Done] 黑客与画家 [Done] 失控 [30%] 禅者的初心 [50%] 影响力 [Done] 思维的乐趣[Done] 暗时间 [Done] 思考的快与慢 [50%] 学习之道 [15%] 要读书单 自私的基因 [0%] 乌合之众 [0%] 批判性思维：带你走出思维的误区 [0%] 黑天鹅：如何应对不可预知的未来 [0%] 从0到1开启商业与未来的秘密 [0%]","tags":"编程","loc":"www.houcj.net/blog/2015/05/08/my-booklist/","title":"我的书单"},{"text":"解压缩文件： $ cd /path/to/works $ tar cvzf game.tar.gz works // 压缩 $ tar zxvf game.tar.gz // 解压缩 SCP命令 scp hostfilename remotename@remoteIP:/path/to/remote $ scp ./works.zip root@192.168.56.101:/home/game 修改可执行权限 chmod +x //or chmod 755 Linux下TCP Socket编程 客户端编程工作 创建 socket 连接到远程服务器 发送数据 接收数据 关闭 socket 服务器编程工作 打开 socket 绑定到特定的地址以及端口上 监听连接 建立连接 接收/发送数据 Socket端口重用: setsockopt()改善程序的健壮性 如果在已经处于 ESTABLISHED状态下的socket调用close socket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket,可以使用 SO_REUSEADDR 套接字选项，这个选项通知内核，如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口。如果端口忙，而TCP状态位于 其他状态，重用端口时依旧得到一个错误信息，指明\"地址已经使用中\"。 ： int opt = 1 ; setsockopt ( listenfd , SOL_SOCKET , SO_REUSEADDR , & opt , sizeof ( opt )); 如果要已经处于连接状态的soket在调用close socket后强制关闭，不经历 TIME_WAIT 的过程： bool bDontLinger = FALSE ; setsockopt ( s , SOL_SOCKET , SO_DONTLINGER , ( const char * ) & amp ; bDontLinger , sizeof ( bool )); 在send()，recv()过程中有时由于网络状况等原因，发收不能预期进行，而设置收发时限： int nNetTimeout = 1000 ; //1秒 //发送时限 setsockopt ( socket , SOL_S0CKET , SO_SNDTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); //接收时限 setsockopt ( socket , SOL_S0CKET , SO_RCVTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节 (异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据 和接收数据量比较大，可以设置socket缓冲区，而避免了send()，recv()不断的循环收发： // 接收缓冲区 int nRecvBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_RCVBUF , ( const char * ) & amp ; nRecvBuf , sizeof ( int )); //发送缓冲区 int nSendBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_SNDBUF , ( const char * ) & amp ; nSendBuf , sizeof ( int )); 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响 程序的性能： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_SNDBUF , ( char * ) & amp ; nZero , sizeof ( nZero )); 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_RCVBUF , ( char * ) & amp ; nZero , sizeof ( int )); 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性： BOOL bBroadcast = TRUE ; setsockopt ( s , SOL_SOCKET , SO_BROADCAST , ( const char * ) & amp ; bBroadcast , sizeof ( bool )); 在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可 以设置connect()延时，直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的 作用，在阻塞的函数调用中作用不大) bool bConditionalAccept = TRUE ; setsockopt ( s , SOL_SOCKET , SO_CONDITIONAL_ACCEPT , ( const char * ) & amp ; bConditionalAccept , sizeof ( bool )); 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket()，以前我们 一般采取的措施是\"从容关闭\"shutdown(s，SD_BOTH)，但是数据是肯定丢失了，如何设置让程序满足具体 应用的要求(即让没发完的数据发送出去后在关闭socket)？ struct linger { u_short l_onoff ; u_short l_linger ; }; linger m_sLinger ; m_sLinger . l_onoff = 1 ; //(在closesocket()调用，但是还有数据没发送完毕的时候容许逗留) // 如果m_sLinger.l_onoff=0;则功能和2.)作用相同; m_sLinger . l_linger = 5 ; //(容许逗留的时间为5秒) setsockopt ( s , SOL_SOCKET , SO_LINGER , ( const char * ) & amp ; m_sLinger , sizeof ( linger )); PS: 1. 在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用 2. 如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0； 还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息： (前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数，采用的 具体协议，以及出错的代码都可以记录下来） bool bDebug = TRUE ; setsockopt ( s , SOL_SOCKET , SO_DEBUG , ( const char * ) & amp ; bDebug , sizeof ( bool )); 粘包 指TCP协议中，发送方发送的若干包数据到接收时粘成以包，从接收缓存看，后一数据的 头紧接着前以包数据的尾。 粘包出现的原因 发送端需要等缓冲区满才发送出去，造成粘包 接收方不及时接受缓冲区的包，造成多个包接收 粘包解决方法 使用TCP中的强制数据立即传送操作指令PUSH 接收方提高接收进程的优先级，或者将一个包中的数据按结构字段，人为控制接受方式。","tags":"编程","loc":"www.houcj.net/blog/2015/05/07/huawei-related/","title":"TCP Socket"},{"text":"首先介绍最简单的反转链表 题目描述: Reverse a singly linked list. 分析： 题目比较简单，可以使用迭代或者递归分别实现。 迭代实现 原链表中的元素依次插入到新的链表中，作为新链表的第一个元素，这里需要注意的是，防止断链。 def reverseList ( self , head ): dummy = ListNode ( - 1 ) cur = None dummy . next = cur while head : q = head . next # 防止断链 dummy . next = head head . next = cur cur = head head = q return dummy . next 或者 原地迭代，每次都把当前的节点链接到到前一个节点。 def reverseList2 ( self , head ): pre = None cur = head while cur : p = cur . next # 保存下一个元素 cur . next = pre # 把当前的指针链接到前一个元素 pre = cur cur = p return pre 递归实现 每次都把下一个节点链接到当前节点。 def reverseList1 ( self , head ): if ( not head ) or ( not head . next ): return head q = self . reverseList1 ( head . next ) head . next . next = head head . next = None return q 进阶1 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL 分析 关键是找到反转位置的节点， def reverseBetween ( self , head , m , n ): pre = dummy = ListNode ( - 1 ) dummy . next = head count = 1 while count < m : pre = pre . next # 找到反转节点的前一个节点 head = head . next #当前的反转节点 count += 1 while count < n : p = head . next # 把当前反转节点的下一个节点依次插入到链表中 head . next = p . next # 保证head节点指向n以后的节点 p . next = pre . next pre . next = p count += 1 return dummy . next 进阶2 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 return 1->4->3->2->5->NULL 分析 找到反转字符串的起点和终点，然后再把它们连接起来。只需要扫描一遍链表即可，时间复杂度O(N)。 def reverseKGroup ( self , head , k ): pre = tail = dummy = ListNode ( - 1 ) dummy . next = head while 1 : count = k while tail and count : count -= 1 tail = tail . next if not tail : break head = pre . next # for the next cycle while pre . next != tail : p = pre . next # assign pre . next = p . next # delete p . next = tail . next #tail the beging of the reverse list tail . next = p # insert tail = head pre = head return dummy . next 完整代码见 Github","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/reverse-linked-list/","title":"反转链表"},{"text":"题目描述 : Count the number of prime numbers less than a non-negative number, n 分析 ： 这里需要注意的是n是很大的整数，因此不能在循环内使用函数的调用来判断一个数是否为素数，否则会超时。可以使用bool数组来确定这个数是否为素数。下面介绍一种素数筛选法来解决这个问题。 素数筛选法就是的理论基础就是每个合数都是可以分解为两个或者多个素数相乘的形式。首先除2以外的偶数都不是素数，另外，对于素数3，它的倍数3*5，3*7，...，3*n，都不是素数。 剩下都是素数。 具体见下面的代码。 class Solution { public : int countPrimes ( int n ) { if ( 2 >= n ) return 0 ; bool * a = new bool [ n ]; for ( int i = 0 ; i < n ; i ++ ){ if ( i % 2 == 0 ) { a [ i ] = false ; } // 除2以外的偶数都不是素数 else { a [ i ] = true ; } } a [ 1 ] = false ; // 1 不是素数 a [ 2 ] = true ; // 2 是素数 int sn = int ( sqrt ( n )); for ( int i = 3 ; i < sn + 1 ; i += 2 ){ if ( a [ i ]) { for ( int j = i * i ; j < n ; j += i << 1 ) // i的奇数倍都不是素数 { a [ j ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ]) { sum += 1 ; } } delete [] a ; return sum ; } }; Python代码实现见 Github ，需要注意的是Python中的bool数组必须声明为[True]*n.","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/sifting-prime/","title":"素数筛选法"},{"text":"间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 读未初始化的存储器 虽然bss存储器位置总是被加载器初始化为零，但对于堆存储器不是这样的。在堆中初始化的元素的值是不确定的 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 引用指针而不是它所指向的对象 int * binheapDelete ( int ** binheap , int * szie ) { int * packet = binheap [ 0 ]; binheap [ 0 ] = binheap [ * szie - 1 ]; * size -- ; //should be (*size)-- heapify ( binheap , * size , 0 ); return ( packet ); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } /*C程序中常见的与存储器有关的错误 */ 间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 引用指针而不是它所指向的对象 int *binheapDelete(int **binheap, int *szie) { int *packet = binheap[0]; binheap[0] = binheap[*szie -1]; *size--;//should be (*size)-- heapify(binheap, *size, 0); return(packet); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } strcpy（）函数 #include<stdio.h> int main ( int argc , char * argv []) { int flag = 0 ; char passwd [ 10 ]; memset ( passwd , 0 , sizeof ( passwd )); strcpy ( passwd , argv [ 1 ]); /*argv[1] = \"aaaaaaaaaaaaa\"是，下面的flag也为1*/ if ( 0 == strcmp ( \"LinuxGeek\" , passwd )) { flag = 1 ; } if ( flag ) { printf ( \" \\n Password cracked \\n \" ); } else { printf ( \" \\n Incorrect passwd \\n \" ); } return 0 ; } 破解上述加密的关键在于利用攻破strcpy()函数的漏洞。 所以用户在向\"passwd\"缓存输入随机密码的时候并没有提前检查\"passwd\"的容量是否足够。 所以，如果用户输入一个足够造成缓存溢出并且重写\"flag\"变量默认值所存在位置的内存的长\"密码\"， 即使这个密码无法通过验证，flag验证位也变成了非零，也就可以获得被保护的数据了。 要避免这样的问题， 建议使用 strncpy()函数 。 - 修改代码片段（只读代码） #include<stdio.h> int main ( void ) { char * ptr = \"China\" ; * ptr = 'A' ; printf ( \" \\n [%s] \\n \" , ptr ); return 0 ; } 通过*ptr = ‘T'，会改变内存中代码段（只读代码）\"China\"的第一个字母。 这个操作是无效的，因此会造成seg-fault或者崩溃。","tags":"编程","loc":"www.houcj.net/blog/2015/05/04/usual-error-in-c/","title":"C程序中常见的与存储器有关的错误"},{"text":"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. ~Donald Knuth 程序员必须再实现和维护程序的简单性与它的运行速度之间做出权衡。 优化编译器的能力和局限性 编译器必须很小心地对程序只使用安全的优化。程序中有两个妨碍优化的因素。 - 存储器别名使用 void add1 ( int * xp , int * yp ) { * xp += * yp ; * xp += * yp ; } void add2 ( int * xp , int * yp ) { * xp += 2 * * yp ; } 编译器并不会把第一个函数优化成第二个函数，因为如果考虑到 xp 等于 yp 的情况。twiddle1 中的 xp 会增加 4 倍，而 twiddle2 中的 xp 仅会增加 2 倍。 函数调用 作为一个示例，考虑下面这两个过程： int f (); int func1 () { return f () + f () + f () + f (); } int func2 () { return 4 * f (); } 编译器也不会吧第一个函数优化为第二个，考虑下面 f 的代码： int counter = 0 ; int f () { return counter ++ ; } 这个函数有个副作用：它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。 考虑下面所示的简单向量数据结构： typedef int data_t ; typedef struct { long int len ; data_t * data ; } vec_rec , * vec_ptr ; 一段合并运算的代码： void combine1 ( vec_ptr v , data_t * dest ) { long int i ; * dest = IDENT ; for ( i = 0 ; i < vec_length ( v ); i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 其中 vec_length 获取 v 的长度，get_vec_elemnet 获取内容。 特别的，使用声明： #define IDENT 0 #define OP + 它对向量的元素求和。 #define IDENT 1 #define OP * 它计算的是向量元素的乘积。 - 消除循环的低效率 void combine2 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 这种优化我们称之为代码移动。 减少过程调用 在 combine2 中，每次循环都要调用 get_vec_element ，为了减少过程调用，代码如下: data_t * get_vec_start ( vec_ptr v ) { return v -> data ; } void combine3 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { * dest = * dest OP data [ i ]; } } 但是这段代码得到的性能提高出乎意料的普通，只提高了整数求和的性能。 - 消除不必要的存储器引用 在我们将 combine3 生成汇编代码后，可以看出，在每次迭代中，程序都要读取出指针 dest 处的值，乘以 data[i]，再将结果存回到 dest。这样的读写显得很是浪费。 考虑如下代码： void combine4 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 我们引入一个临时变量 acc， 它在循环中用来累计计算来的值。只有再循环完成之后结果才存放到 dest 中。在汇编代码中可以看到，编译器会使用一个寄存器来保存累积值。与 combine3 中的循环相比，我们将每次迭代的存储器操作从两次读和一次写减少到只需要一次读。 循环展开 循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。（如果展开后不能很好的提高程序的并行性还是不要展开） void combine5 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_lenght ( v ); long int limit = length - 1 ; data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < limit ; i += 2 ) { acc = ( acc OP data [ i ]) OP data [ i + 1 ]; } for (; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 提高性能的技术 高级设计: 为遇到的问题选择适当的算法和数据结构。 基本编码原则: 消除连续的函数调用 消除不必要的存储器引用：引入临时变量来保持中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。 低级优化 展开循环，降低开销，并且使得进一步优化成为可能。 通过使用例如多个累积变量和重新结合技术，找到方法提高指令级并行。 用功能得风格重写条件操作，使得编译采用条件数据传送。 关于程序的优化，最常见的是优化是选择合适的算法和数据结构，这个是起决定性作用的，基本编码原则还是要遵守的，至于低级优化还要考虑程序的局部性等问题。Amdahl定律为我们描述了一个改进任何过程的通用原则，当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。 $$\\frac{1}{(1-\\alpha)+\\alpha/k}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/01/optimizing-program-performance/","title":"程序性能优化"},{"text":"24点游戏 是一种使用扑克牌来进行的益智类游戏，游戏内容是：从一副扑克牌中抽去大小王剩下52张，任意抽取4张牌，把牌面上的数（A代表1）运用加、减、乘、除和括号进行运算得出24。每张牌都必须使用一次，但不能重复使用。在不同版本中，对J、Q、和K的处理有些差异。一个常见的版本是把J、Q、和K去除，或当成10；还有一个版本是把J表示11，Q表示12，K代表13。 虽然大多数24点存在很多解法，有相当一部分数字组合只存在唯一的解法。这种组合往往较有难度，也较为有趣。这里总结一些常见的组合。 分数运算 虽然给出4个数字都是整数，中间步骤中有时会出现分数。这种4个数字的组合往往较有难度。一个经典的例子是1，5，5，5，其解答为5 × (5 − 1 ÷ 5) = 24；另外 一个例子是3，3，8，8，其解答为8 ÷ (3 - 8 ÷ 3) = 24。 大数／奇数运算 有些组合中会涉及到一些较大数字，这些组合通常较有难度。比如4、4、10、10的解法为(10 × 10 − 4) ÷ 4 = 24，5、6、6、9的解法为6 × 9 − 5 × 6 = 24。 下面的代码可以解决上面出现的情况。 Show the code def PointGame ( n ): i = 0 if ( n == 1 ): if matrix [ 0 ][ 0 ] == matrix [ 0 ][ 1 ] * 24 : return True else : return False for i in range ( 0 , n ): for j in range ( i + 1 , n ): # use two dimention array a = matrix [ i ][ 0 ] b = matrix [ i ][ 1 ] c = matrix [ j ][ 0 ] d = matrix [ j ][ 1 ] # python needs the deepcopy to copy the value to the destination matrix [ j ] = copy . deepcopy ( matrix [ n - 1 ]) expa = result [ i ] expb = result [ j ] result [ j ] = result [ n - 1 ] result [ i ] = '(' + expa + '+' + expb + ')' matrix [ i ][ 0 ] = a * d + b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '-' + expb + ')' matrix [ i ][ 0 ] = a * d - b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expb + '-' + expa + ')' matrix [ i ][ 0 ] = b * c - a * d matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '*' + expb + ')' matrix [ i ][ 0 ] = a * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True if c != 0 : result [ i ] = '(' + expa + '/' + expb + ')' matrix [ i ][ 0 ] = a * d matrix [ i ][ 1 ] = b * c if ( PointGame ( n - 1 )): return True if a != 0 : result [ i ] = '(' + expb + '/' + expa + ')' matrix [ i ][ 0 ] = b * c matrix [ i ][ 1 ] = a * d if ( PointGame ( n - 1 )): return True # restore the value matrix [ i ][ 0 ] = a matrix [ i ][ 1 ] = b matrix [ j ][ 0 ] = c matrix [ j ][ 1 ] = d result [ i ] = expa result [ j ] = expb i += 1 return False 完整的代码见 Github 代码持续更新，该算法的核心就是穷举每种出现的可能，为了更好的实现，上面的代码对数字出现的顺序有一定的要求。不同的顺序得到的结果可能不一样。","tags":"编程","loc":"www.houcj.net/blog/2015/04/25/cal24/","title":"24点游戏编程"},{"text":"操作系统内核是应用程序和硬件之间的媒介。它提供三个基本抽象： 文件是对I/O设备的抽象 虚拟存储器是对主存和磁盘的抽象 进程是对处理器、主存和I/O设备的抽象 系统中所有的信息，都是一串位表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文。 预处理->编译->汇编->链接 程序的机器级表达 数据传递、局部变量的分配和释放通过操作程序栈来实现。机器用栈来传递过程参数、存储返回信息、保存寄存器用于恢复，以及本地存储。为单个过程分配的那部分栈称为栈桢。最顶端的栈桢以两个指针界定，寄存器%ebp为帧指针，寄存器%esp为栈指针。 存储器层级结构 计算机系统中的一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。这个思想围绕着计算机程序的一个成为局部性（locality）的基本属性。 局部性通常有两种形式：时间局部性（temporal locality）和空间局部性（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 理解存储器层次结构的本质的程序员能够利用这些知识，编写出更有效的程序，无论具体的存储系统结构是怎样的，应使用以下技术： 将你的注意力一种在内部循环上，大部分计算机和存储器访问都发生在这里 通过按照数据对象存储在存储器中的顺序、以步长为1来读数据，从而使得你程序中的空间局部性最大 一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得你程序中的时间局部性最大 高速缓存行、组和块的区别： 块是一个固定大小的信息包，是高速缓存和主存来回传送信息的基本单位 行是高速缓存中存储块以及其他信息（有效位和标记位）的容器 组是一个或多个行的集合 直接映射高速缓存中，组和行是等价的。因为一行总是存储一个块，所以行和块通常可以互换使用。 cache friendly code 最常见的情况运行得最快 每个缓存内部缓存不明中数量最小。 对局部变量的反复引用是好的，因为编辑器能够将它们缓存在寄存器文件中（时间局部性） 步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储在连续的块。（空间局部性） 异常控制流 进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程。 从主程序返回 调用exit函数。 父进程通过fork函数创建一个新的运行子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括text，data，bss，heap以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。 父进程与新创建的子进程之间最大的区别在与它们有不同的PID。 fork函数调用一次却会返回两次，一次在是在调用父进程中，一次在新创建的子进程中。 父进程中，fork返回子进程的PID 子进程中，fork返回0。 父进程和子进程是并发运行的独立进程。 当fork在新进程中返回时，新进程现在的寻你存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中任一个后来进行写操作时，写时拷贝机制就会创建新页面。 回收子进程 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，相反，进程被保持在一种已终止的状态中，知道被它的父进程回收。当父进程回收已终止的子进程时，内核讲子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个被终止了但是还未回收的进程称为僵尸进程。 发送信号 Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。 每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。默认地，一个子进程和它的父进程同属于一个进程组。 unix> /bin/kill -9 -12345 一个负的PID会导致信号被发送到进程组PID中的每个进程。 因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和住函数并发低运行 非本地跳转 在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分治到另一个函数。 setjmp 函数在env缓冲区中保存当前调用环境，以供后面longjmp使用，并返回0.调用环境包括PC，stack pointer 和通用目的寄存器。 longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。 setjmp函数只被调用一次，但返回多次：一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时；一次是为每个相应的longjmp调用。另一方面longjmp调用一次，但从不返回。 可以把try语句中的catch自居看作类似与setjmp函数。throw语句类似与longjmp函数。 虚拟存储器 虚拟存储是对主存的一个抽象。支持虚拟存储器的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。 现代系统通过将虚拟存储器骗和磁盘上的文件片关联起来，以初始化虚拟存储器骗，这个过程叫做存储器映射。 SRAM缓存表示位于CPU和主存之间的L1、L2、L3高速缓存，DRAM缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。 由于大的不命中处罚，DRAM缓存是全相连的。因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。 按需也买年调度和独立的虚拟地址空间的结合，简化了连接和加载、代码和数据共享，以及应用程序的存储器分配。 一个给定的linux系统上每个进程都使用类似的存储器格式。文本节总是从虚拟地址0x08048000处开始（对于32位地址空间），或者从0x400000处开始（64位地址空间）。数据和bss节紧跟在text segement后面。栈占据进程地址空间最高的部分，并向下生长。 结合告诉缓存和虚拟存储器的主要思路是地址翻译发生在高速缓存查找之前。 在MMU中包含了一个关于PTE（page table entry）的小缓存，称为TLB。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。 用来压缩页表的常用方法是使用层级结构的页表 匿名文件 匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理存储器中找到一个合适的牺牲页面，如果页面被修改过就将这个页面换出，用二进制0覆盖牺牲页面并更新页表。 动态分配器 动态分配器维护着一个进程的虚拟存储器区域，称为堆。堆是一个请求二进制零的区域，它紧接在未初始化的bss区域后开始，并向上生长。 对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 动态分配器有两种基本风格。 显式分配器，要求应用显示地释放任何已经分配的块（block） 隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，就释放这个快，也叫垃圾收集器。 calloc是一个基于malloc的wrapper函数，它将分配的存储器初始化为零。想要改变一个以前已分配块的大小，可以使用realloc函数。 程序使用动态分配器分配的最重要原因是 经常知道程序实际运行时，它们才知道某些数据结构的大小 分配器的要求和目标 显示分配器必须在以下严格的约束条件下工作： 处理任意请求序列，即不可以假设分配和释放请求的顺序 立即响应请求，不允许分配器为了提供高性能重新排列或者缓冲请求 只使用堆，任何非标量数据结构都必须保存在堆里。 对齐块，分配器必须对齐块，使得它们可以保存任何类型的数据对象。 不修改已分配的快，压缩已分配的块这样的技术是不允许的。 碎片 内部碎片，是在一个已分配块比有效载荷大时发生的。 外部碎片，是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。 分配器长采用启发式策略来师徒维持少量的大空闲块，而不是维持大量的小空闲块。 如果分配器不能为请求块找到合适的空闲块，那么分配器就会通过调用sbrk函数，向内核申请额外的堆存储器。分配器讲额外的存储器转化为一个大的空闲块，将这个块插入到空闲链表中， 然后将被请求的块放置在这个新的空闲块中。 分离存储 就是维护多个空闲链表，其中每个链表中的块的大小大致相等。 简单分离存储，使用简单分离存储，每个大小类（size class）的空闲链表包含大小相等的块，每个块的大小就是这个大小类中的最大元素的大小。要释放一个块，分配器只要简单的讲这个块插入到相应的空闲链表的前部。 优点，分配和释放都是很快的常数时间 缺点，简单分离存储很容易造成内部和外部碎片 分离适配，使用分离适配，分配器维护着一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。 优点，对分离空闲链表的简单的首次适配搜索，其存储器利用率接近于对整个堆的最佳适配搜索的存储器利用率。 伙伴系统 伙伴系统是分离适配的特例，其中每个大小类都是2的幂。为了分配一个大小为2&#94;k的块，我们找到第一个可用的大小为2&#94;j的块，其中 k<=j<=m(堆的大小为2&#94;m)。如果j = k,搜索完成，否则递归二分割这个块，直到j = k。当我们进行这样的分割时，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。要释放一个大小为2&#94;k的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，就停止合并。 垃圾收集 在一个支持垃圾收集的系统中，应用显示分配堆块，但是从不显式释放它们。垃圾收集器定期识别垃圾块，并相应地调用free，将这些块放回到空闲链表中。 C程序中的 Marki&Sweep收集器必须是保守的，因为C语言不会用类型信息来标记存储器位置。想int或者float这样的标量可以伪装成指针。 并发编程 I/O多路服用技术 优点 它比基于进程的程序设计给了程序员更多的对程序行为的控制。 一个基于I/O多路服用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。 缺点 编码复杂 不能充分利用多核处理器 线程 运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文，包裹一个唯一的整数线程ID、栈，栈指针，程序计数器、通用目的寄存器和条件吗。 和一个线程相关的线程组成一个线程池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程第一个运行的线程。线程池主要的影响是，一个线程可以杀死它的任何对等线程，或者等待它的任何对等线程终止。 在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached）。 - 可结合的，一个可结合的线程能够被其他线程回收其至于那和杀死。在回收之前，它的存储器资源是没有释放的 - 可分离的，一个可分离的线程是不能别其他线程回收或杀死的。它的存储器资源在它终止时由系统自动释放。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/04/15/csapp/","title":"深入理解计算机系统"},{"text":"Programs must be written for people to read, and only incidentally for machines to execute. — Abelson & Sussman, Structure and Interpretation of Computer Programs 1. 交换变量 一般交换变量有以下三种方法： 最常用的，就是设置一个临时变量 temp = x ; x = y ; y = x ; 这种方法在python中可以更优雅的表示，而且效率更高。 x , y = y , x 不增加临时变量使用加法 b = a + b a = b - a # a = a + b - a = b 即 a = b b = b - a # b = a + b - b = a 使用位操作 b = a &#94; b a = a &#94; b b = a &#94; b 使用\"+\"和\"-\"的一行操作: a = ( a + b ) - ( b = a ) 2. Python字典中判断键值是否存在 一般情况会是用一个判断语句 dic = { 'key' : 'value' } if 'key' in dic : print dic [ 'key' ] else : print 'not found' 在python中可以内置的get函数即可 print dic . get ( 'key' , 'not found' ) 3. 读取文件 python中有三个方法来处理文件内容的输入： read（） 一次读取全部的文件内容。 f = open ( 'path/to/file.txt' , 'r' ) ff = f . read () f . close () readline() 每次读取文件的一行。 f = open ( 'path/to/file.txt' , 'r' ) line = f . readline () while 1 : if line : print line else : break f . close () readlines() 读取文件的所有行，返回一个字符串列表 f = open ( 'path/to/file.txt' , 'r' ) ff = f . readlines () f . close () 由于文件操作需要注意文件的打开和关闭操作，因此更优雅的做法是 with open ( 'path/to/file.txt' , 'r' ): for line in f : do_somenthing ( line ) 4. while 1 还是 while True？ 在python 2中，由于 True 不是关键字，因此可以对True进行赋值。下面的语句是可以的 True = 'Hello' 因此在无限循环中，我们应该使用while 1，因为while True在每次 while循环时都会有对True的判断操作。 下面使用dis，Disassembler for Python bytecode,即把python代码反汇编为字节码指令， 模块观察生成的字节码。 In [ 10 ]: import dis In [ 11 ]: def while_one (): .... : while 1 : .... : pass .... : In [ 12 ]: def while_true (): .... : while True : .... : pass .... : In [ 13 ]: if __name__ == '__main__' : .... : Print 'while 1' .... : dis . dis ( while_one ) .... : Print 'while True' .... : dis . dis ( while_true ) ##########output while 1 2 0 SETUP_LOOP 3 ( to 6 ) 3 >> 3 JUMP_ABSOLUTE 3 >> 6 LOAD_CONST 0 ( None ) 9 RETURN_VALUE while True 2 0 SETUP_LOOP 10 ( to 13 ) >> 3 LOAD_GLOBAL 0 ( True ) 6 POP_JUMP_IF_FALSE 12 3 9 JUMP_ABSOLUTE 3 >> 12 POP_BLOCK >> 13 LOAD_CONST 0 ( None ) 16 RETURN_VALUE 5. string的连接 对一个可迭代对象，经常需要对其中的字符串元素进行连接操作，这时候一般有下面两种方法 '+' 和 'join' 。 使用'+'进行操作时，每次都需要创建新的对象，然后再对新的对象进行操作。 计数出要join的所有字符串的长度，然后进行一一拷贝，这样只有一次对象生成 #This is good to glue a large number of strings for chunk in input (): my_string . join ( chunk ) 因此处于内存的考虑，应尽量使用join操作。 6. string的反转 string的反转可以使用for循环从右向做输出。代码如下 def reverse_str ( string ): return '' . join ( string [ i ] for i in range ( len ( string ) - 1 , - 1 , - 1 )) 或者使用递归 def reverse_str1 ( string ): if len ( string ) <= 1 : return string return reverse_str ( string [ 1 :]) + string [ 0 ] 当然最简单和效率最高的是使用切片。 def reverse_str1 ( string ): return string [:: - 1 ] 7. 字典中的setdefault函数 我们经常需要使用字典来初始化数据，每个字典的值是一个列表。通常使用以下的方法 dics = {} for ( val , dic ) in data : if val in dics : dics [ val ] . append ( dic ) else : dics [ val ] = [ dic ] 通过setdefault可以优化为 dics = {} for ( val , dic ) in data : dics . setdefault ( val , []) . append ( dic ) 8. 列举 在python中遍历list获得index和item。可以通过下面的代码： index = 0 for item in lst : print index , item index += 1 # or for index in range ( len ( lst )): print index , lst [ index ] 而使用enumerate可以使代码更清晰， 更易读。 for ( index , item ) in lst : print index , item 9. 列表展开（list comprehension） 列表展开比一般的循环操作的效率更高，而且更简单。 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] for i in range ( len ( a )): a [ i ] = i ** 2 // ** 比 pow （）的效率更高，因此它在 python 中是一个运算符 或者更高的实现 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] a = [ val ** 2 for val in a ] # or : a = map ( lambda i : i ** 2 , a ) 10. 很长的序列使用xrange() 相对于 range() 一次性载入整个序列， xrange() 可以帮你省下许多内存，因为它一次只载入一个元素。 11.字典和列表 在Python中，字典是基于hash table实现的。因此查找操作的复杂度是O(1),而list实际是个数组，查找操作的复杂度是O(n)。 def test (): t = time . time () lst = [ 'the' , 'zen' , 'of' , 'python' , 'Beautiful' , 'is' , 'better' , 'than' , 'ugly' ] found = [ 'Explicit' , 'is' , 'better' , 'than' , 'implicit' ] #lst = dict.fromkeys(lst,1) for i in xrange ( 10 ** 7 ): for token in found : if token not in lst : pass print time . time () - t 当直接在list中进行查找时上述代码执行了7.14800000191s，当去掉注释，使用字典使，上述代码执行了2.4960000515s，效率提高了大约1.9倍。因此当需要对数据进行频繁访问和查找的时候，dict比list具有更大的优势。 12. 生成器 要理解生成器，首先需要理解Python迭代的内部机制：Python中的迭代就是对可迭代对象实现了__iter__()方法和迭代器(iterator)实现了__next__()方法的一个操作过程。就是说，可迭代对象的__iter__()方法可以返回迭代器，迭代器通过调用next()方法获取其中的每一个值。 任何你可用 \"for... in...\" 处理的都是可迭代对象：列表，字符串，文件.... 这些迭代对象非常便捷，但是当有大量数据要使用内存的时候，必须要使用生成器了。 生成器是用来生成迭代器的函数，它的返回值是yield而不是return。因为生成器并没有将所有值放入内存中，而是实时地临时的生成这些值。 下面用打印出全排列来说明声明生成器的具体实现 def perm ( self , arr , pos = 0 ): if pos == len ( arr ): yield arr for i in range ( pos , len ( arr )): arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] #swap the elements sequential for x in self . perm ( arr , pos + 1 ): yield x arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] 当生成器要一个数时，生成器会执行，直至出现yield语句，生成器返回yield参数，之后生成器停止继续执行。 当需要下一个数时，生成器从上次的状态开始执行，直至出现yield语句，返回参数，停止。如此反复。 13. Python中有用的数据结构 Counter() Counter 用于统计可hash对象出现的次数。并以降序排序输出。 import collections string = \"the zen of python\" print collections . Counter ( string ) #output Counter ({ ' ' : 3 , 'e' : 2 , 'h' : 2 , ' \\n ' : 2 , 'o' : 2 , 'n' : 2 , 't' : 2 , 'f' : 1 , 'p' : 1 , 'y' : 1 , 'z' : 1 }) Deque Deque支持线程安全，内存优化的append和pop操作，在队列两端的插入和删除操作都近乎O(1)的时间复杂度。而list在处理即改变列表长度又改变元素位置的操作，如insert(0,v),pop(0)的时间复杂度就基本为O(n)。 Heapq heapq使用一个堆实现的优先队列。堆是一个二叉树，它的孩子节点的值都小于或者等于父亲节点（最小堆)。常见的有以下几种操作。 heapq.heappush(heap, item) 把item的值push到heap中，同时保持heap的性质。 heapq.heappop(heap) 弹出堆顶的元素 heapq.heapify(x) 在线性时间内把list x 转化为一个堆。","tags":"编程","loc":"www.houcj.net/blog/2015/04/01/life-is-short-use-python/","title":"人生苦短我用Python"},{"text":"链接 C++中允许重载方法，这些方法在源代码中有相同的名字，却有不同的函数列表。编译器讲每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这个编码过程叫做mangling。 链接器如何解析多重定义的全局符号 函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 Unix链接器使用下面的规则来处理多重定义的符号： 不允许有多个强符号。 如果有一个强符号和一个弱符号，那么选择强符号 如果有多个弱符号，那么从这些弱符号中任意选择一个 在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，连接会失败 加载器（loader）将可执行目标文件的代码和数据从磁盘拷到内存中，然后跳转到程序的第一条指令或入口点来运行程序。这个将程序拷贝到内存并运行的过程叫做加载。 无论我们在存储器中的何处加载一个目标模块，数据段总是分配成紧随代码段后面。因此，代码段中任何指令和数据段中任何一个变量之间的距离都是一个运行时常量，和代码段和数据段的绝对的存储位置无关 链接器的两个主要任务是符号解析和重定位 符号解析 讲姆讲目标文件中的每个全局符号都绑定到一个唯一的定义 重定位 确定每个符号的最终在内存中的位置，并修改对那些目标的引用。 链接器 分别编译：即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候将它们整合到一起。但是，链接器一般是与C编译器分离的。 链接器通常把由编译器或汇编器生成的若干个目标模块整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。 链接器通常把目标模块看成是由一组外部对象组成。每个外部对象代表机器内存中的某个部分，并通过一个外部名称来识别。 exit函数和return函数的主要区别是： exit用于在程序运行的过程中随时结束程序，exit的参数返回给操作系统。exit函数运行时会先执行由atexit（）函数等级的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile（）创建的临时文件。exit是结束一个进程，它将删除进程的内存空间，同时讲错误信息返回给父进程。exit是系统调用级别的，表示整个进程的结束。 return表示终止当前函数的运行，并将操作权返回给调用者。如果在main函数中，表示将操作权返回给操作系统，隐式调用exit。​如果return没有值就返回空，表示中断函数的执行，返回调用函数处。return是语言级别的，它表示了调用堆栈的返回； 理解复杂声明可用的\"右左法则\"：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。 分析下面的例子，答案见最后。 char * const * ( * next )(); char * ( * c [ 10 ]) int ( ** p ); 每个外部对象只在一个地方声明。这个声明的地方一般就在一个头文件中，需要用到该外部对象的所有模块都应该包括在这个头文件。特别注意：定义该外部对应的那个模块也应该包括这个头文件。 编译：生成目标平台的指令 -解释：在运行过程中才生成目标平台的指令。需要虚拟机来将编译后生成的中间代码翻译成目标平台的指令。 Interposition指用户定义的函数取代函数库中声明 完全相同的函数 ，不是重载. void mktemp () {..} void getwd () { mktemp ();} int main () { mktemp (); getwd (); // 即使库函数有 void mktemp(){}，操作系统也会调用用户自己定义的函数 return 0 ; } 链接库的五个特殊秘密 动态链接库的扩展名为 \".so\"，静态的为\".a\" 通过-lthread选项，告诉编译器链接到libthread.so 编译器期望在确定的目录下找到这些库函数 观察头文件，确定所使用的函数库 与提取动态库中的符号相比，静态库中的符号提取的方法限制更严格 动态库的优点： 动态链接可执行文件比功能相同的静态链接可执行文件的体积小。 所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。 关于库函数的使用，最好的用法就是尽量使用系统头文件。 预处理 宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。 宏定义中的空格不能忽视 #define f (x) ((x)-1） 的意思是f代表(x) ((x)-1而不是f(x)代表((x)-1 宏定义中出现的括号的作用是预防引起与优先级有关的问题。例如 #define abs(x) (((x)>=0)?:(x):-(x)) // 正确 #define abs(x) x>0?x:-x // 错误 abs(a-b)在错误的表达式中会展开为 a-b>0?a-b:-a-b 即使是用括号括起来也可能出错。 #define max(a,b) ((a)>(b)?(a):(b)) 在上面的表达式中，如果a大于b，那么a将会被求两次值，此时max(a++,b)就会产生错误的结果。 正确的做法如下： #define max(x, y) ({ typeof ( x ) _max1 = ( x ); typeof ( y ) _max2 = ( y ); ( void ) ( & _max1 == & _max2 ); // 当两个比较两个类型不同的变量的地址时,编译器会给出一个警告.提示我们在进行类型不同的比较. _max1 > _max2 ? _max1 : _max2 ; }) 前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果,编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误。 再看一个经典的例子 #define toupper(c) (( c ) >= 'a' && ( c ) <= 'z' ? ( c ) + ( 'A' - 'a' ) : ( c )) 这样做的原因是因为touppper(函数在调用时造成的系统开销要大大多于函数体内的实际计算操作。 动态语言和静态语言 通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。 动态类型语言：动态类型语言是指在 运行期间 才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言 静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在 编译期间 检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表 一般情况静态类型的语言运行速度要高于动态语言。 强类型定义语言和弱类型定义语言 强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言，可以有效的避免许多错误 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 Python是动态的强类型语言，C是静态的弱类型语言","tags":"编程","loc":"www.houcj.net/blog/2015/03/27/link-and-preprocess/","title":"链接和预编译"},{"text":"宏定义 一般情况下我们这样定义min宏 #define min(x,y) ((x) > (y) ? (y) : (x)) 但是当这样的宏执行： num = min ( a , b ++ ); 当编译时，宏展开后就是下面的代码 num = (( a ) > ( b ++ ) ? ( a ) : ( b ++ )) 这样b就会多加一次，下面是linux内核定义min宏的代码 #define min(x, y) ({ \\ typeof(x) _min1 = (x); \\ typeof(y) _min2 = (y); \\ (void) (&_min1 == &_min2); \\ _min1 < _min2 ? _min1 : _min2; }) (void) (&_min1 == &_min2); 这个语句的后半部分比较了两个变量的地址, 它的作用在于当两个比较两个类型不同的变量的地址时,编译器会给出一个警告. 提示我们在进行类型不同的比较.那么前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果, 编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误. 内存管理 虚拟内存通过 Page 的形式组织。Pages就是操作系统用于内存和磁盘之间移动或者进行保护的单位。Page in，Page out。磁盘上有个特殊的交换区来与内存进行交换。 进程只能操作位于屋里内存中的页面。 i = 0 ; while ( malloc ( 1 << 20 )) ++ i ; // to see the memory available in this process. printf ( \"Allocated %d MB total \\n \" , i ); cache cache 的类型 write-through cache : 每次写入cache时同时写入到内存，保持内存与cache的一致性。 write-back cache ： 当第一次写入时，只写入cache。如果已经写入过的cache行再次需要写入时，此时第一次写入的结果尚未保存，所以要先把它写入到内存中。当内存切换进程时，cache中所有的数据都要先写入到内存中。 line： 内存读取以行（32 bytes）为单位，整行的数据也会被装入到cache中。每行由两部分组成：一个数据部分以及一个标签，用于指定它所代表的地址。 block： 一个行内的数据块被称作块。块保存来回移动于Cache行和内存之间的字节数据。 -堆 堆区域用于动态 用于内存管理的调用是： malloc 和 free ------------从堆中获得内存以及把内存返回给堆 brk 和 sbrk --------------调整数据端的大小至一个绝对值。 堆中经常出现的两类问题： 释放或改写仍在使用的内存；（内存损坏） 未释放不再使用的内存；（内存泄露） 内存泄露的的检测： swap 观察交换区 netstat、vmstat等工具 对齐（alignment）：数据项只能存储在地址是数据项大小整数倍的内存位置上。数据项不能跨越页面或者cache边界 段（segment）错误原因： dereference Null pointer. int * p ; p = NULL ; * p ; 或者解引用一个包含非法值的指针。 p = malloc ( 256 ); p [ - 1 ] = 0 ; p [ 256 ] = 1 ; 在未得到正确的权限时进行访问。 const int i = 0 ; f (){ i = 1 ; // 表达式必须是可以修改的左值。 } 消耗完了堆栈或者堆空间。 C 语言中的运算规则 C语言中每个token应该尽可能多的包含更多的字符。如果编译器的输入流截止到某个字符之前已经被分解成一个个的token，那么从该字符之后应尽可能的组成一个最长的字符串的token。除了字符串与字符串常量，符号的中间不能嵌有空白（空格符、制表符，换行符）。 C语言中符号之间的空白将被忽略，这些符号包括空格符，制表符，换行符号： if ( a > b ) b = a ; if ( a > b ) b = a ; C语言变量的声明包括两部分：类型，以及声明符。 C语言运算符优先级 最高优先级包括：数组下标，函数调用操作符，各结构成员选择操作符。都是自左向右结合。 单目运算符的优先级仅次于最高级的运算符。单目运算符是自右向左结合。 双目运算符中，优先级为: 算术运算符 > 移位运算符 > 关系元算符 >逻辑运算符>赋值运算符>条件元算符 在所有的运算符中， 逗号 运算符的优先级最低。 C语言中，只有四种运算符存在规定的求值顺序（&&、||、?:、,）。运算符&&和||首先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符？：有三个操作数：在a？b:c中，操作数a首先别求值，根据a的值再求b后者c的值。而逗号操作符，首先对左侧操作数求值，然后该值被丢弃，再对右侧操作数求值。 C语言中常见的问题 如果一个整形常量的第一个字符是数字0，那么该常量将被视作八位数。譬如010会被当成十进制中的8。 在C语言中用单引号引起的字符所代表的是该字符ASCII码的整数值。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。 C语言中，每个case只有在遇到break时才会跳出switch语句。否则讲继续。 switch ( exp ) { case one : do something1 ; break ; case two : do something2 ; break ; default : do something3 : break ; } 如果strlen(s)的值是n，那么该字符串实际需要n+1个字符的空间，'\\0'作为结束标志。 char * p , * q ; p = \"xyz\" q = p ; p [ 0 ] = 'X' q [ 1 ] = 'Y' 复制指针并不同时复制指针所指向的数据，而是把指针所指向的地址复制给另一个指针。 int n = 4 ; int buffer [ n ] = { 1 , 2 , 3 , 4 }; int * bufptr = buffer ; int * p = buffer ; while ( n > - 1 ) { if ( bufptr == & buffer [ 4 ]) { printf ( \"Work well ! \\n \" ); break ; } * bufptr ++ = * p ++ ; n -= 1 ; } 所以上面的代码执行后，p，q共同指向字符串\"XYz\" - 当常量被转换为指针使用时，这个指针绝对不能解引用，即不能使用该指针所指向内存中的存储内容。ANSI规定：数组中实际不存在的溢界元素的地址位于数组所占用内存之后，这个地址可以用于进行赋值比较。但是不能引用该地址的元素。 类型提升：在表达式中，每个char类型都被转换为int，float都会转换为double。由于函数参数也是一个表达式，所以当参数传递给函数时也会发生类型转换。 整型提升：char、short int和位段类型（signed，unsigned）以及枚举类型将被提升为int，前提是int类型能够完整地容纳原先的数据，否则讲会被转换为 unsigned int。 X = Y Left Value（左值）: 表示存储结果的地方. X 代表存储的地址。 Right Value（右值）: Y中的内容 数组名是不可修改的左值 ，只有可修改的左值才能被赋值。 a +++++ b ; 由于编译器的中最长匹配的原则，上式会被翻译为 a ++++ + b ; //即 (( a ++ ) ++ ) + b ; 而 a++ 不能作为左值， 因为a++返回的是自身的值副本。因此上面的表达式是错误的。 C语言里函数的参数默认是从右往左处理的，输出时是从左往右。 #include<stdio.h> int main ( void ) { int a = 10 , b = 20 , c = 30 ; printf ( \" \\n %d..%d..%d \\n \" , a + b + c , ( b = b * 2 ), ( c = c * 2 )); return 0 ; } 答：输出结果是： 110..40 . .60 void*和C结构体 设计一个能接受任何类型的参数并返回interger（整数）结果的函数 答：如下： int func ( void * ptr ) 数组和指针 数组名a本身就是指针，在加上取地址符&，就变成了一个双指针，如果a是一维数组对应的 &a就是二维数组，&a+1就是数组整体加一行。 空指针和悬挂指针 当delete一个指针的时候，实际上仅是让编译器释放内存，但指针本身依然存在，这时它就是一个 悬挂指针，可以通过下面的语句使悬挂指针成为空指针。 ptr = 0 ; 如果这个函数的参数超过一个，那么这个函数应该由一个结构体来调用， 这个结构体可以由需要传递参数来填充。 - 大端和小端 （数据在内存中的字节排列顺序） - 大端：最低位置存放高位字节，高位优先。 - 小端：最低位置存放低位字节，地位优先。 'NUL'和'NULL'的区别 一个'L'的'NUL'用于结束一个ASCII字符串。 两个'L'的'NULL'用于表示什么也不指向（空指针） C中的关键字： extern：用于变量，表示在其他地方（文件）定义。用于函数定义，表示全局可见，即可被任意文件内的函数访问。 const：相当于read only static：在函数内部，表示该变量的值在各个调用一直保持持续性。 联合（Union）和结构体（Struct） 一个联合的总的大小等于它的最大字段的大小 如果我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，以减少分配空间的总量。","tags":"编程","loc":"www.houcj.net/blog/2015/03/03/expert-c-programming/","title":"Expert C Programming"},{"text":"线程安全 一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会产生一直产生正确的结果。 四个线程不安全函数类 不保护共享变量的函数 对一个未受保护的全局计数器变量加1. 改进：利用像P和V操作这样的同步操作来保护共享的变量。 优点，在调用程序中不需要做任何修改 缺点，同步操作讲减慢程序的执行时间 保护跨越多个调用的状态的函数 unsigned int next = 1 ; int rand ( void ) { next = next * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } void srand ( unsigned int seed ) { next = seed ; } 改进方法重写，使得它不再使用任何static数据，而是依靠调用者在参数中传递状态信息。 int rand_r ( unsigned int * nextp ) { * nextp = * nextp * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } 缺点，被迫修改调用程序中的代码。 返回指向静态变量的指针的函数。 改进方法，加锁-拷贝（lock-copy）技术。基本思想是将线程不安全函数与互斥锁联系起来。在每一个调用位置，对互斥锁解锁，调用线程不安全函数，讲函数返回的结果拷贝到一个私有的存储器位置，然后对互斥锁解锁。 char * ctime_ts ( const time_t * timep , char * privatep ) { char * sharedp ; P ( & mutext ); sharedp = ctime ( timep ); strcpy ( privatep , sharedp ); V ( & mutex ); return privatep ; } 调用线程不安全函数 改进方法，lock-copy","tags":"编程","loc":"www.houcj.net/blog/2015/02/27/multi-thread/","title":"多线程"},{"text":"一、大型网站构架演化发展历程 应用服务和数据服务分离 使用缓存改善网站性能 使用应用服务器集群改善网站的并发处理能力 数据库读写分离 使用反向代理和CDN加速网站响应 CDN部署在网络提供商的机房，使用户可以从最近的网络提供商机房获取数据 方向代码里部署在网站的中心机房，反向代理服务器中缓存着用户的请求资源。 使用分布式文件系统和分布式数据库系统 使用NoSQL和搜索引擎 业务拆分 分布式服务 网站架构模式 分层 分层就是将系统在横向纬度上切分成几个部分，每个部分负责一部分相对比较单一的 指责，然后通过上层对下层的依赖和调用组成一个完整的系统 层次 内容 应用层 具体业务和视图展示，如网站首页及搜索输入和结果展示 服务层 为应用层提供服务支持，如用户管理服务 数据层 提供数据存储访问服务，如数据库、缓存、文件、搜索引擎 分割 分割就是在纵向方面对软件进行切分，将不同的业务进行分割，包装成高内聚 低耦合的模块单元，有利于软件的开发和维护，同时也提供网站的并发处理能力 和功能扩展能力。 分布式 分布式意味着，可以使用更多的计算机完成同样的功能，将分成和分割的模块独立 部署。 集群 对于用户访问集中的模块，如网站首页，需要将独立部署相同应用 构成一个集群，通过负载均衡设备共同对外提供服务。 缓存 缓存就是将数据存放在距离计算最近的位置以加快处理速度。一般包括 CDN、反向代理、本地缓存、分布式缓存。使用缓存有两个条件，一是数据访问热点不均衡，而是数据在某个时间段内有效，不会 很快过期。 异步 业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个 阶段之间通过共享数据的方式一步执行进行协作。 在单一服务器内部，可通过多线程共享内存队列的方式实现异步，处在业务 操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理。在分布式 系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作 内存队列的分布式部署。 冗余和自动化 数据库从了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对 数据库进行主从分离，实时同步实现热备份。 自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控 和报警，自动化失效转移，恢复，自动化降级，自动话分配资源。 安全 xss攻击，sql注入。 二、软件架构 软件架构就是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的 设计。 一般说来，除了当前的系统功能需求，软件架构还需要关注性能、可用性、伸缩性、 扩展性、安全性这5个架构要素，架构设计过程中需要平衡这5个要素之间的关系以实现需求和架构目标， 也可以通过考察这些架构要素来衡量一个软件架构设计的优劣，判断其是否满足期望。 1、性能 在浏览器端可以，可以通过浏览器缓存、使用页面压缩、合理布局页面、 减少Cookie传输等手段改善性能。 在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在 内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力。 以及使用异步操作和CDN等缓存操作。 在代码层面可以使用多线程、改善内存管理手段优化性能。 在数据库服务器端，索引、缓存、SQL优化，以及使用NoSQL。 衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过这些指标以确定系统设计是否达到目标 可用性 网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多态服务器相互备份， 任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失。 衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种 不可预期的问题时，系统整体是否依然可用 伸缩性 伸缩性就是通过不断向及群众加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的 数据存储需求。 衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器.加入 新的服务器后是否可以提供和原来无差别的服务.集群中容纳的总的服务器数量是否有限. 对于应用服务器集群,通过使用合适的负载均衡设备就可以向及群众不断加入服务器. 对于缓存服务器集群,加入新的服务器可能会导致缓存路由失效,因此需要改进缓存路由算法保证缓存数据的 可访问性. 关系数据库支持数据复制,主从热备等机制,但很难做到大规模的可伸缩性,因此需要通过路由分区等手段将部署 有多个数据库的服务器组成一个集群. 扩展性 衡量网站扩展性好坏主要标准就是在网站增加新的业务产品时，是否可以实现对现有 产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。不同产品 之间是否很少耦合， 一个产品的改动是否有影响，其他产品和功能不需要受牵连 进行改动。 网站可扩展架构的主要手段是事件驱动架构和分布式服务。 事件驱动架构在网站中通常利用消息队列实现，将用户请求和其他业务事件构造成消息发布到消息队列， 消息的处理者作为消费者从消息队列中获取消息进行处理，这样就把消息产生和消息处理分离开来 分布式服务则是将业务和可复用服务分离开来,通过分布式服务框架调用,新增产品可以通过调用可服用的服务 实现自身的业务逻辑,而对现有产品没有任何影响. 安全性 衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段,是否有可靠的应对策略. 三、瞬时相应:网站的高性能架构 网站性能测试 一、性能响应指标 1、相应时间 指应用执行一个操作需要的时间，包括从发出请求开始到收到最后相应数据所需的时间。响应时间是系统最终哟啊的性能指标， 直观反应了系统的快慢。 2、并发数 指系统能够同时处理请求的数目，这个数字反应了系统的负载特性。 3、吞吐量 值单位时间内系统处理的请求数量，体现系统的整体处理能力。 4、性能计数器 它是描述服务器活操作系统性能的一些数据指标，包括system load、对象与线程数、内存使用、CPU使用、磁盘与网络 I/O等指标。 二、性能测试 性能测试是一个总称，具体可细分为性能测试、负载测试、压力测试、稳定性测试。 Web 前端性能优化 一、浏览器访问优化 1、减少http请求 减少http请求的主要手段是合并CSS、合并javascript、合并图片.如果每张图片都有不同的超连接,可通过CSS偏移响应 鼠标点击操作,构造不同的URL。 2、使用浏览器缓存 对于一些静态资源文件，可以通过设置HTTP头中Cache-Control和Expires属性来设定浏览器缓存。当这些静态资源发生 变化时，要通过改变文件名实现，即生成一个新的JS文件并更新HTML文件的引用，同时使用浏览器缓存策略的网站 在更新静态资源时，应采用逐量更新的方法，以免用户浏览器突然大量缓存失效，集中更新缓存，造成服务器 3、启用压缩 在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。文本文件的压缩效率可达80%以上， 因此HTML、CSS、JavaScript文件启用 GZip 压缩可达到较好的效果。 4、CSS放在页面最上面、JavaScript放在页面最下面 浏览器会在下载完全部CSS之后对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。 浏览器在加载JavaScript后立即执行，有可能会阻塞整个页面。 5、减少Cookie传输 Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输，因此应尽量减少Cookie中传输的数据量。另一方面 对于静态资源的访问，可以考虑使用独立域名访问，避免请求静态资源时发送Cookie. 二、CDN加速 CDN的本质是一个缓存，而且将数据缓存在离用户最近的地方，是用户以最快的速度获取数据. 三、反向代理 反向代理位于网站机房一侧，代理网站web服务器接收HTTP请求。反向代理服务器具有保护网站安全的作用，同时代理 服务器也可以通过配置缓存功能加速web请求。方向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以 提高系统总体处理能力，进而改善网站高并发情况下的性能。 应用服务器性能优化 应用服务器就是处理网站业务的服务器，网站的业务代码都在这里。优化的主要手段有分布式缓存、集群、异步。 分布式缓存 网站性能优化第一定律：优先考虑使用缓存优化性能。 1、缓存的基本原理 一方面，缓存中的访问速度一般都很快。另一方面，如果缓存中的数据是经过计算处理得到的，那么被缓存的数据无需要重复 计算即可直接使用，缓存还起到减少计算时间的作用。 缓存的本质是Hash表，数据以Key、Value的形式存储在Hash表中，Hash表数据读写的时间复杂度都是O（1）.缓存能够很高效的 原因就是网站数据访问通常遵循二八定律,因此利用Hash表和内存的告诉访问特性,可以很好的改善系统性能. 2、合理使用缓存 一般数据的读写比例在2:1以上,缓存才有意义. 通过分布式缓存服务器集群,将缓存数据分布到集群多台服务器上可在一定程度 上改善缓存的可用性. 缓存预热 ：缓存中存放的是热点数据，热点数据又是缓存系统利用LRU对不断访问的数据筛选淘汰出来的。新启动的缓存 系统如果没有任何数据，在重建缓存数据的过程中，系统的性能和数据库负载都不太好， 那么最好在 缓存系统启动时就把热点数据加在号，这个缓存预加载手段叫做缓存预热。 3、分布式缓存架构 分布式缓存指缓存部署在多个服务器组成的集群中，以集群方式提供缓存服务，其架构方式有两种， 一种是以JBoss Cache为代表的需要更新同步的分布式缓存，一种是以Memcached为代表的 不互相通信的分布式缓存。 JBoss Cache 的分布式缓存在集群中所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的 时候，会通知集群中其他机器更新缓存数据或清除缓存数据。由于海量数据的缓存的同步代价过大，因此 这种方案多见于企业应用系统中。 Memcached Memcached采用一种集中式的缓存集群管理，缓存与应用分离部署，缓存系统部署在一组专门的服务器上，应用 程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据。 简单的通信协议 ：远程通信需要考虑两方面的问题，一是通信协议，如TCP，另一种是通信 序列化协议，数据传输的两端，必须使用彼此可识别的数据序列化方式才能使通信得以完成，如JSON等 稳步呢序列化协议。Memcached使用TCP协议通信，其序列化是哦i一个命令关键字开头，后面是一组 命令操作数。如读取一个数据的命令协议是get 高性能的网络通信 ，Memcached服务端通信模块基于Libevent。 高效的内存管理 ，内存管理的一个最大问题就是碎片，操作系统在垃圾回收方面做了很多工作：压缩，复制。Memcached使用 固定空间分配。 代码优化 多线程 使用多线程的原因主要有两个：I/O阻塞与多CPU. 一台服务器上启动多少线程合适? 启动线程数 = [任务执行时间/（任务执行时间 - IO等待时间）*CPU内核数] 资源复用 资源复用主要有两种模式：单例和对象池。 目前Web开发主要使用贫血模型，从Service到Dao都是些无状态对象，无需重复创建，因此很自然的使用单例。 对象池模式通过服用对象实例，减少对象创建和资源消耗。常用的连接池、线程池，本质上都是对象，池管理方式也基本相同。 数据结构 目前比较好的字符串Hash散列算法是Time33算法，即对字符串逐字符迭代乘以33，求得Hash值，算法原型为： \\begin{equation*} hash(i) = hash(i-1)*33 + str[i] \\end{equation*} Time33可以很好的解决冲突，但是相似的字符串的HashCode也可能比较相似。如‘AA'的HashCode是2210，字符串‘AB'的HashCode是 2211.一个可行的解决方案是，先用MD5对字符串提取质问，然后再对信息指纹求HashCode。 存储优化 B+树 vs LSM 树 B+树 是一种专门针对磁盘存储而优化的N叉排序树，以额点为单位存储在磁盘中，从根开始超早所需数据所在的节点编号和 磁盘位置，将其加载到内存中然后继续查找，直到找到所需的数据。目前数据库多采用两级索引的B+树，树的层次最多三层。 因此可能需要5次磁盘访问才能更新一次记录（三次磁盘访问获取数据索引及行ID，然后再进行一次数据文件读操作，及 一次数据文件写操作）。 LSM树 可以看作是一个N阶合并树。数据写操作都在内存中进行，并且会创建一个新纪录，这些数据在内存中仍然是一棵排序树， 当数据量超过设定的内存阈值后，会将这棵排序树和磁盘上最新的排序树合并。当这棵排序树的数量也超过阈值后，和磁盘上下一级的 排序树合并。合并过程用最新的数据覆盖旧的数据。在LSM树上进行一次数据更新不需要磁盘访问，在内存中即可完成，因此当数据访问的 写操作大于读操作时，LSM可以加快访问速度。 RAID RAID 0：并发写入N块磁盘 RAID 1：将一份数据同时写入两块磁盘 RAID 10：将数据并发写入N/2块磁盘，另外一块磁盘作为备份 RAID 5：数据并发写入N-1块磁盘，螺旋式写入另外一块磁盘 四、万无一失：网站的高可用（Availiablity）架构 高可用的网站架构 实现高可用架构的主要手段是数据和服务的冗余备份以及失效转移。位于应用层的服务器通常为了应对高并发的访问请求， 会通过负载均衡设备将一组服务器组成一个集群共同对外提供服务，当负载均衡设备通过心跳检测等手段监控到某台应用 服务器不可用时，就将其从集群列表中删除，并将请求分发到集群中其他可用的服务器上，使整个集群保持可用，从而实现应用 高可用。 高可用的应用 应用层主要处理网站应用的业务逻辑，应用的一个显著特点是应用的无状态性，无状态的应用是指应用服务器不保存业务的 上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器， 处理结果都是完全一样的。 应用服务器集群的Session管理 利用独立部署的Session服务器集群统一管理Session，应用服务器每次读写Session时，都访问Session服务器。这种解决 方案事实上是将应用服务器的状态分离，分为无状态的应用服务器和有状态的Session服务器，然后针对这两种服务器的不同 特性分别设计其架构 高可用的数据 CAP原理 CAP原理认为，一个提供数据服务的存储系统无法同时满足数据一致性（Consisitency），数据可用性（Avalibility）， 分区耐受性（Partition Tolerance，系统具有跨网络分区的伸缩性）。在大型网站中，通常选择强化A和p，而在某种程度 上放弃C。 数据备份 数据热备份可分为两种：异步热备方式和同步热备方式。 在异步写入方式下，存储服务器分为主存储服务器（Master）和从存储服务器（Slave），应用程序正常情况下值连接主存储服务器 ，数据写入时，由主存储服务器的写操作代理模块将数据写入本机存储系统后立即返回写操作成功响应，然后通过异步线程将写操作 同步到从存储服务器。实践中，通常使用读写分离的方法， 写操作至访问Master数据库，读操作只访问Slave数据库。 失效转移 系统确认一台服务器是否宕机的手段有两种，心跳检测和应用程序访问失败报告。对于应用程序的访问失败报告，控制中心还需要再发送心跳检测进行确认，以免错误判断 服务器宕机。 代码控制 目前网站应用开发中主要使用的是分支开发，主干发布的方式。即任何修改都不得在主干上直接进行，需要开发一个新功能，或者修复一个bug时，从主干 拉一个分治进行开发，开发完成且测试通过后，合并回主干，然后从主干进行发布，主干上的代码永远是最新发布的版本。 自动化发布 火车发布模型：将每个应用的发布过程看作一次火车旅程，火车定点运行，期间有若干站点，每一站都进行例行检查，不同的项目下车，剩下的项目继续 作者火车旅行，直到火车到达重点。这个火车发布模型是基于规则驱动的流程，所以这个流程可以自动化。目前比较流行的Web自动化测试工具是ThoughtWorks 开发的Selenium。 灰度发布 灰度发布将集群服务器分成若干部分，每天只发布一部分服务器，观察运行稳定没有故障再发布另一部分服务器，期间如果有问题，只需要回滚已发布的一部分 服务器即可。灰度发布也常用于用户测试，别称为AB测试。 网站监控 目前网站使用比较广泛的开源性能监控工具是Ganglia，它支持大规模服务器集群，并支持以图形的方式在浏览器展示实时性能曲线。 五、永无止境：网站的伸缩性架构 负载均衡 HTTP重定向负载均衡 HTTP重定向服务器唯一的功能就是根据用户的HTTP请求计算一台真是的Web服务器地址，，并将该Web服务器地址写入HTTP重定向响应中（响应状态码302）， 返回给用户浏览器。缺点是浏览器需要两次请求才能完成一次访问，性能较差；重定向服务器自身的处理能力有可能称为瓶颈。 DNS域名解析负载均衡 在DNS服务器中配置多个A记录，每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置多个服务器就构成一个集群， 并可以实现负载均衡。目前的DNS是多级解析，每一级DNS都可能缓存A记录，当下线某台服务器，需要较长的更新时间。目前常用的方面是使用DNS作为第一级负载均衡，即将域名解析为提供负载均衡服务的内部服务器。 反向代理负载均衡 反向代理服务器管理一组Web服务器，将请求根据负载均衡算法转发到不同的Web服务器上。Web服务器处理完成的响应也需要通过反向代理代理服务器返回给用户。 因此反向代理服务器需要配置双网卡和内部外部两套IP地址。 由于反向代理服务器转发请求在HTTP协议层面，因此也叫应用层负载均衡。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能成为瓶颈。 IP负载均衡 在网络层通过修改请求目标地址进行负载均衡。 IP负载均衡的关键在与真实物理Web服务器响应数据包如何返回给负载均衡服务器。一种方案是负载均衡服务器在修修改目的同时修改源地址，将数据包源地址设为 自身IP，即源地址转换。另一种方案是将负载均衡服务器同时作为真实物理服务器集群的网关服务器，这样所有响应数据都会到达负载均衡服务器。 数据链路层负载均衡 数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。 这种数据传输的方式又称为三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址。这种负载均衡方式又被称为直接路由方式。使用三角 传输模式的链路层负载均衡是目前大型网站使用最广的一种负载均衡手段。在Linux平台上最好的链路层负载均衡开源产品是LVS(Linux Virtual Server)。 负载均衡算法 负载均衡服务器的实现可以分为两个部分: 1. 将请求数据发送到该地址对应的web服务器上 2. 根据负载均衡算法和Web服务器列表计算得到集群中一台Web服务器的地址。 具体的算法有：轮询（Round Robin），加权轮询（Weighted Round Robin），随机（Random），最少连接（Least Connections），源地址散列 （Source Hashing）：根据请求来源的IP地址进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总在同一个服务器上处理，该请求的上下文信息 可以存储在这台服务器上，在一个会话周期内重复使用，从而实现回话粘滞。 分布式缓存集群的伸缩性设计 分布式缓存集群伸缩性设计的最主要目标就是使新加入缓存 服务器后的整个缓存服务器集群中已经缓存的数据尽可能还被访问到。 一致性Hash算法 一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的Hash映射。 具体算法过程为：先构造一个长度为2&#94;32的整数环（这个环被称做一致性Hash环），根据节点 名称的Hash值将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据 的Key计算得到其Hash值，然后在Hash环上顺时针查找距离这个Key的Hash值最近的缓存服务器节点， 完成Key到服务器的Hash映射查找。具体应用中，这个Hash环通常是使用二叉查找树实现， Hash查找过程实际上是在二叉查找树中查找不小于查找数的最小数值。当然这个二叉树的最右边叶子节点和最左边的叶子节点相连接，构成环。 但是上述算法有个缺点就是可能造成节点负载的不均衡。 计算机的任何问题都可以通过增加一个虚拟层来解决 ，因此解决上述问题的 方法就是使用虚拟层的手段：将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的Hash值放置在Hash环上，Key在环上先找到 虚拟服务器节点，再得到物理服务器的信息。虚拟节点的经验值为150. 数据存储服务器集群中的伸缩性设计 关系数据库集群： Cobar，相当于在应用程序与数据库之间加了一个调度的中间层。Cobar服务器集群的伸缩可用简单的负载均衡即可，MySQL要想保持集群扩容后数据 一致，可使用一致性Hash算法。 NoSQL数据库集群： Apache HBase。 六、随需应变:网站的可扩展架构 扩展性是指在系统影响最小的情况下，系统功能可持续扩展或提升的能力。它是系统架构设计层面的开闭原则，对扩展开放，对修改关闭。 设计网站可扩展架构的核心思想是模块化，并在次基础上，降低模块间的耦合性，提供模块的复用性。 利用分布式消息队列降低系统耦合性 事件驱动架构 事件驱动架构：通过在低耦合的模块之间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作，典型的 EDA架构就是操作系统中常见的生产者消费者模式，在大型网站中，最常用的是分布式消息队列。 分布式消息队列 队列是以中先进先出的数据结构，分布式消息队列可以看作将这种数据结构部署在对立的服务器上，应用程序可以通过远程访问接口使用 分布式消息队列，进行消息存取操作，进而实现分布式的异步调用。 利用分布式服务打造可复用的业务平台 分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一消息，而分布式服务通过借口分解系统耦合性，不同子系统通过相同的接口 描述进行服务调用。 解决方案就是拆分，将模块独立部署，降低系统耦合性。拆分可分为纵向拆分和横向拆分。 纵向拆分：将一个大应用拆分为多个小应用，如果新增业务比较独立，那么就直接将其设计部署为一个独立的Web应用系统。 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务，不许哟啊依赖具体的模块代码，即可 快速搭建一个应用系统，而模块内业务逻辑变化的时候，只要接口保持一致就不会影响业务程序和其他模块。 可扩展的数据结构 传统的关系数据库需要指定表的schema（字段名称，数据类型，并遵循特定的设计方式），这样无法做到很好的扩展性。那么 如何才能无需改变表结构就可以新增字段呢？NoSQL数据库使用的ColumnFamily设计就是一个解决方案，它是一种面向列族的稀疏 矩阵存储格式。创建表的时候，只需要指定ColumnFamily的名字，无需指定字段（Column），可以在数据写入时在指定，这样就可以使得 应用程序的数据结构可以随意扩展。 七、固若金汤：网站的安全架构 网站应用攻击与防御 全球大约70%的Web应用攻击来自XSS攻击和SQL注入攻击。此外还有CSRF、Session劫持等手段。 XSS攻击 XSS（Cross Site Script）即跨站点脚攻击，指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户 浏览器进行恶意操作的一种攻击方式 常见的XSS攻击有两种，反射型：攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的；持久型：黑客提交含有恶意脚本的请求，保存 在被攻击的Web站点的数据库中，用户浏览网页是，恶意脚本被包含在正常页面中，达到攻击的目的。 常见的防御手段有：消毒：对某些html危险字符转义，如\">\"转义为\"&gt\"，\"<\"转义为\"&lt\"；Httponly：浏览器禁止页面JavaScript访问 带有HttpOnly属性的Cookie，防止xss攻击窃取Cookie； 注入攻击 注入攻击主要有两种形式，SQL注入和OS注入攻击。SQL攻击的原理是攻击者在HTTP请求中注入恶意SQL命令（drop table users），服务器 请求参数构造数据库SQL命令时，恶意SQL被一起构造并在数据库中执行。 使用预编译手段，绑定参数是最好的防SQL注入方法，攻击者的恶意SQL会被当作SQL的参数，而不是SQL命令。 CSRF攻击 CSRF（Cross Site Request Forgery）攻击者通过跨站请求，以合法用户的身份进行非法操作，CSRF的主要手法是利用跨站请求，在 用户不知情的情况下，以用户身份伪造请求。核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。 主要的防御手段是：表单Token（在页面表单中增加一个随机数为Token，每次响应页面的Token都不相同，从正常的页面提交的请求包含该Token）， 验证码，Referer check（HTTP请求头的Referer域中记录着请求源，可检查请求来源，验证其是否合法，可以实现图片防盗链） if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2014/12/22/architecture/","title":"大型网站技术架构"},{"text":"GCC 预编译 gcc -E hello.c -o hello.i # 或者 gcc hello.c > hello.i 编译 gcc -S hello.c -o hello.s 汇编 as hello.s -o hello.o # 或者 gcc -c hello.s -o hello.o # 或者 gcc -c hello.c -o hello.o ELF objdump -h hello.o size hello.o objdump -s -d hello.o # code or text section objdump -x -s -d hello.o # data or rodata section and bss section objdump -d hello.o # disassembly 段表 readelf -S hello.o readelf -s hello.o The relocation operation also relies on two extra tables which are namely: .rela.dyn : Relocation for dynamically linked objects (data or procedures), if PLT is not used. .rela.plt : List of elements in the PLT (Procedure Linkage Table), which are liable to the relocation during the dynamic linking (if PLT is used).","tags":"编程","loc":"www.houcj.net/blog/2014/10/05/GCC/","title":"GCC"},{"text":"Bitmap bitmap就是使用一个bit来存储相应的value值，相对于int直接存储可以大大的 节约内存。 一个value在bitmap的处理过程可以看成是一次二维数组的处理过程，首先我们找过这个 value在第几个数组元素中存储，然后我们把 value%sizeof(array) 的值对应的位的值、 设为1，在查找的时候我们只需要找到value对应的数组元素以及这个元素中在 value%sizeof(array) 的值，即可得。 具体实现： class Bitmap ( object ): def __init__ ( self , num ): # init the class self . size = int (( num + 30 ) / 31 ) # floor function self . array = [ 0 for x in range ( self . size )] # the size of the array def set ( self , num ): # init the number to the bit formart byteIndex = num % 31 elemIndex = int ( num / 31 ) self . array [ elemIndex ] |= ( 1 << byteIndex ) print self . array def clr ( self , num ): byteIndex = num % 31 elemIndex = int ( num / 31 ) self . array [ elemIndex ] &= ( ~ ( 1 << byteIndex )) def test ( self , num ): # test the number to see it's bit is 1 byteIndex = num % 31 elemIndex = int ( num / 31 ) return self . array [ elemIndex ] & ( 1 << byteIndex ) Bloom Filter bloom filter 是一个很节约空间的概率数据结构。但是会存在 False positive 的情况。意思是，它返回的要么是肯定不在这个集合中，或者可能在这个集合中。 bloom Filter是bitmap的升级版，在执行的过程根据不同的hash函数生成不同的value，然后 把这些value使用bitmap的形式映射在array中，查找的过程中，必须确定每个hash函数生成的value 都在array中，但是由于hash函数的碰撞性，因此有些假的数据也可能通过测试。 具体实现如下: class BloomFilter ( object ): def __init__ ( self , array_size = ( 1 * 1024 ), hashes = 7 ): self . filter = bytearray ( array_size ) # The filter itself self . bitcount = array_size * 8 # Bits in the filter self . hashes = hashes # The number of hashes to use (different hash function) def _hash ( self , value ): # Build an int() around the sha256 digest of int() -> value digest = int ( sha512 ( value . __str__ ()) . hexdigest (), 16 ) for i in range ( self . hashes ): yield digest & ( self . bitcount - 1 ) # digest % self.bitcount digest >>= ( 256 / self . hashes ) def insert ( self , value ): for digest in self . _hash ( value ): self . filter [ digest >> 3 ] |= ( 2 ** ( digest & 7 )) def find ( self , value ): return all ( self . filter [ digest >> 3 ] & ( 2 ** ( digest & 7 )) for digest in self . _hash ( value )) Bloom Filter无法删除元素，只能删除，因此出现了一个改进的可以删除元素的BloomFilter， 计数Bloom Filter。它的基本设计思路是使用多个比特位表示基本的信息单元。将集合成员 加入位数组使，根据k个哈希函数计算，将原先的数值加1即可。删除的时候减1.只要不为0，就是 该成员属于集合。 BloomFilter因其极高的空间利用率而得到广泛的使用。Google Chrome 使用它进行恶意的URL的判断；缓存使用BF来对海量数据进行查找；网络爬虫 使用它对已经爬取过的URL进行判断。","tags":"编程","loc":"www.houcj.net/blog/2014/10/05/bitmap-bloom-filter/","title":"Bitmap & Bloom Filter"},{"text":"程序的编译汇编链接装载 总体来说，程序源代码被编译以后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和BSS短属于程序数据。C语言指针大小的位数和虚拟空间的位数相同。 ELF可执行文件引入了一个概念叫做Segment，一个Segment包含一个或多个属性类似的Section。 对于相同权限的段，把它们合并到一起当作一个段进行映射。 数据段和BSS的唯一区别就是：数据段从文件中初始化内容，而BSS段内容全部初始化为0. 操作系统通过给进程空间划分出一个个VMA（Virtual Memory Area，Linux中进程虚拟空间的一个段）来管理进程的虚拟空间。 基本原则是将相同权限属性的、有相同映像文件的映射成一个VMA；一个进程基本上可以分为如下集中VMA区域： 代码VMA，权限只读、可执行；有映像文件 数据VMA，权限可读写、可执行；有映像文件 堆VMA，权限可读写、可执行；无映像文件，匿名，可向上扩展 栈VMA，权限可读写、不可执行；无映像文件，匿名，可向下扩展 影响C语言ABI（Application Binary Interface, 二进制接口）的因素 内置类型（int、float、char）的大小和在存储器中的放置方式（大端小端对齐方式） 组合类型（struct、union、array）的存储方式和内存分布 外部符号（extern-linkage）与用户定义的符号之间的命名方式和解析方式，如函数名func在C语言的目标文件中是否被解析成外部符号_func. 函数调用方式，比如参数入栈顺序、返回值如何保持等。 堆栈的分布方式，比如参数和局部变量在堆栈里的位置，参数传递方法等。 寄存器使用约定，函数调用时那些寄存器可以修改，哪些需要保存，等等 影响CPP语言ABI的因素 继承类体系的内存分布，如基类，虚基类在继承类中的位置等 指向成员函数的指针的内存分布，如果通过指向成员函数的指针来调用成员函数，如何传递this指针 如何调用虚函数，vtable的内容和分布形式，vtable指针在object中的位置等。 template如何实例化 外部符号的修饰 全局对象的构造和析构 异常的产生和捕获机制 标准库的细节问题，RTTI如何实现 内嵌函数的访问细节 进程栈线程栈 进程栈大小执行时确定的，与编译链接无关 进程栈大小是随机确定的，至少可以比线程栈要大，但不会超过2倍。 线程栈是固定大小的，可以使用ulimit -a查看。 关于模块 在静态链接中，整个程序最终只有一个可执行文件，它是一个不可以分割的整体， 但是在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件和程序 所依赖的共享对象，很多时候我们也把这些部分称为模块，即在动态链接下的可执行文件和 共享文件对象都可以看作是程序的一个模块。 固定装载地址 共享对象在编译时不能假设自己在进程虚拟地址空间的为孩子，于此不同的是，可执行 文件基本可以确定自己在进程虚拟空间中的其实位置,因为可执行文件往往是 第一次个加载的文件,它可以选择一个固定空闲的地址,比如Linux下一般都是OX08040000, Windows下一般都是0x00400000. 延迟绑定 动态链接比静态链接慢的原因是动态链接下对于全局的和静态的数据访问都要进行复杂的GOT(Global offset table) 定位,然后间接寻址;对于模块间的调用也要先定位GOT,然后再进行间接跳转.另一个原因是动态链接的链接工作 在运行时完成,即在程序开始执行时,动态链接器都要进行一次链接工作,这时动态链接器会寻找并装载 所需要的共享对象,然后进行符号查找地址重定位等工作. 解决方案延迟绑定，基本思想是当函数第一次被用到时才进行绑定（符号查找、重定位），如果 没有用到就不进行绑定。ELF主要使用PLT（Procedure Linkage Table）的方法来实现。调用函数并不直接 通过GOT跳转，而是通过一个PLT项的结构来进行跳转。 动态符号表 为了动态链接这些模块之间的符号导入导出关系，ELF专门有一个叫做动态符号表的段来保存这些信息，这个 段的名字通常叫做\".dynsym\"(dynamic symbol).动态符号表也需要一些辅助的表，比如用于保存符号名 的字符串表，为了加快查找过程的符号哈希表。 动态链接重定位表 共享对象的重定位与静态链接目标文件的重定位的唯一区别是目标文件的重定位是在静态链接时完成的， 而共享对象的重定位是在装载时完成的。\".rel.text\"表示的是代码段的重定位表,\".rel.data\"书数据段的 重定位表,\".rel.dyn\"是对数据引用的修正，它所修正的位置位于\".got\"以及数据段；而 \".rel.plt\" 是对函数引用的修正，它所修正的位置位于\".got.plt\"。 动态链接器自举 动态链接器本身不可以依赖于其他任何共享对象，其次是动态链接器本身所需要的全局和静态变量的重定位工作需要自己完成提供， 这种具有一定限制条件的启动代码往往被称为自举。动态链接器本身是静态链接的。 环境变量 动态链接器会按照下列顺序依次装载或查找共享对象： - 由环境变量LD_LIBRARY_PATH指定的路径 - 由路径缓存文件/etc/ld.so.cache指定的路径 - 默认贡献爱那个库目录，先/usr/lib， 后/lib CPP 全局构造与解释 GCC中有类代码的CPP初始化代码如下： _start-> __libc_start_main -> __lib_csu_init -> _init -> __do_global_ctors_aux。对于每个编译单元（.cpp），GCC编译器会遍历其中 所有的全局对象，生成一个特殊函数，这个特殊函数的作用就是对本编译单元里的所有 全局对象进行初始化。 段错误 & 非法操作 这是典型的非法指针解引用造成的错误，当指针指向一个不允许读或者写的 内存地址，而程序却试图利用指针来读或写该地址的时候，就会出现这个错误。 造成这样的错误最普遍的原因有两种： 1. 程序员将指针初始化为NULL，之后却没有给它一个合理的值就开始使用指针 2. 程序员没有初始化栈上的指针，指针的值一般会是随机数，之后就直接开始使用指针。 if ( anybuf ( stream ) && stream -> _cnt != 0 ) { nbytes = ( count < stream -> _cnt ) ? count : stream -> _cnt ; memcpy_s ( data , dataSize , stream -> _ptr , nbytes ); count -= bytes ; stream -> _cnt -= nbytes ; stream -> _ptr += nbytes ; data ++ nbytes ; dataSize -= nbytes ; }","tags":"计算机科学","loc":"www.houcj.net/blog/2014/10/05/compilation-link-load/","title":"程序员的自我修养"},{"text":"Sublime 快捷键 通用（General） ↑↓←→：上下左右移动光标，注意不是不是KJHL！ Alt：调出菜单 Ctrl + Shift + P：调出命令板（Command Palette） Ctrl + `：调出控制台 编辑（Editing） Ctrl + Enter：在当前行下面新增一行然后跳至该行 Ctrl + Shift + Enter：在当前行上面增加一行并跳至该行 Ctrl + ←/→：进行逐词移动 Ctrl + Shift + ←/→进行逐词选择 Ctrl + ↑/↓移动当前显示区域 Ctrl + Shift + ↑/↓移动当前行 选择（Selecting） Ctrl + D：选择当前光标所在的词并高亮该词所有出现的位置，再次Ctrl + D选择该词出现的下一个位置，在多重选词的过程中，使用Ctrl + K进行跳过，使用Ctrl + U进行回退，使用Esc退出多重编辑 Ctrl + Shift + L：将当前选中区域打散 Ctrl + J：把当前选中区域合并为一行 Ctrl + M：在起始括号和结尾括号间切换 Ctrl + Shift + M：快速选择括号间的内容 Ctrl + Shift + J：快速选择同缩进的内容 Ctrl + Shift + Space：快速选择当前作用域（Scope）的内容 查找&替换（Finding&Replacing） F3：跳至当前关键字下一个位置 Shift + F3：跳到当前关键字上一个位置 Alt + F3：选中当前关键字出现的所有位置 Ctrl + F/H：进行标准查找/替换，之后： Alt + C：切换大小写敏感（Case-sensitive）模式 Alt + W：切换整字匹配（Whole matching）模式 Alt + R：切换正则匹配（Regex matching）模式 Ctrl + Shift + H：替换当前关键字 Ctrl + Alt + Enter：替换所有关键字匹配 Ctrl + Shift + F：多文件搜索&替换 跳转（Jumping） Ctrl + P：跳转到指定文件，输入文件名后可以： @ 符号跳转：输入@ symbol跳转到symbol符号所在的位置 # 关键字跳转：输入#keyword跳转到keyword所在的位置 行号跳转：输入:12跳转到文件的第12行。 Ctrl + R：跳转到指定符号 Ctrl + G：跳转到指定行号 窗口（Window） Ctrl + Shift + N：创建一个新窗口 Ctrl + N：在当前窗口创建一个新标签 Ctrl + W：关闭当前标签，当窗口内没有标签时会关闭该窗口 Ctrl + Shift + T：恢复刚刚关闭的标签 屏幕（Screen） F11：切换普通全屏 Shift + F11：切换无干扰全屏 Alt + Shift + 2：进行左右分屏 Alt + Shift + 8：进行上下分屏 Alt + Shift + 5：进行上下左右分屏 分屏之后，使用Ctrl + 数字键跳转到指定屏，使用Ctrl + Shift + 数字键将当前屏移动到指定屏 VS2013 快捷键 ctrl+-（shift+ctrl+-）：移动光标到上次位置或相反，比如定位一个函数，转到函数定义后想回到函数使用处，则用ctrl+-，若又想回到函数定义处则可以按shift+ctrl+- F12：Go to Definition，到变量或函数定义的地方，如变量声明处，函数实现处。与ctrl+-配合使用非常方便 Ctrl+]：匹配选中的括号（大括号、小括号都行），在多层循环+判断语句时非常方便 ctrl+Space：代码补全 ctrl+tab：在VS中切换打开的窗口，即切换各个文件 ctrl+I：递增搜索，与ctrl+F不同的是搜索期间不显示搜索对话框，且ctrl+F搜索下一个直接按Enter即可，而ctrl+I搜索下一个按ctrl+I或F3，Escape退出，连续按两次ctrl+I重复上次搜索 Ctrl+Shift+F：旧式的文件搜索对话框（与记事本中的搜索替换框差不多，可以替换） Ctrl+F3：为当前选中的部分进行搜索（不需要再输入要搜索的内容） Shift+Alt+Enter：最大化代码编写区域（代码全屏模式），即去掉所有其它辅助窗口只留下代码编写窗口，再按一次返回到原来界面 ctrl+K，Ctrl+C：注释一段代码块（先要选中一段代码） ctrl+K，Ctrl+U：取消注释一段代码块 ctrl+K，Ctrl+D：代码自动格式化（整个文档） ctrl+K，Ctrl+F：只格式化你选中的部分 Ctrl+K，Ctrl+K：在当前行创建一个书签 Ctrl+K, Ctrl+N：去下一个书签处 Ctrl+C, Ctrl+V：在当前行的下一行复制当前行内容（不用选中当前行），即复制当前行并粘贴到下一行，在两行内容差不多时很有用，可以先复制再改 Ctrl+L：删除当前行 Ctrl+M, Ctrl+M：展开或关闭当前的代码 PS: Vim Cheat Sheet","tags":"编程","loc":"www.houcj.net/blog/2014/10/05/editors/","title":"Editor"},{"text":"Markdown简介 Markdown遵循易写易读的设计理念，通过一些符号的标记来 插入图片 行内式的图片链接语法： ! [ Alt text ]( / path / to / img . jpg \"Optional title\" ) HTML 语法 <img src=\"/path/to/img.png\" class=\"img-responsive\" alt=\"Optional title\" align=center /> 插入表格 使用( : )来进行对齐，下面分别是左对齐，居中，右对齐。 | Write | the | code | |:- -------- |:- --------: | ---------: | | first | second | third | | 1 | 2 | 3 | 效果 A B C first second third 1 2 3 引用 使用 ( > )来进行引用 > Life is short, you need python! 效果 Life is short, you need python! 超链接 使用 [Github](https:/github.com/chaojunhou) 效果 Github 代码 使用( ``` )来把代码块包括起来，后面加上相应的语言可以高亮。 ```python print 'Hello World!' ``` 效果 print 'Hello World!' 转义字符 在不希望被转义的字符前加上( \\ )即可","tags":"编程","loc":"www.houcj.net/blog/2014/09/06/markdown/","title":"Introduction to Markdown"},{"text":"普通的有序链表在查询的时候，最坏的情况下需要遍历整个链表，而二叉搜索树 可以每次查询的时候，在和根节点比较后每次都可以跳过一半的元素。通过跳表 我们就可以使链表的查询更快。 跳表使用多级的层级结构来加快查询的速度。下面是一个具体的例子： 上面那一层是快速通道，主要用来连接主要的外部节点，譬如，当我们在快速通道上的节点找到一个比指定节点 50大的节点的时候，我们就转入普通通道进行线性查询。 下面是具体实现的伪代码： 查找操作 ：从链表的表头开始，从最高层的节点依次往低层级节点查找，在同一级节点查找的时候与普通 有序链表是一样的，当在本层级未找到时，就下降一个层级继续，直到最后。 def getitem ( self , i ): node = self . head i += 1 for level in reversed ( range ( self . maxlevels )): while node . width [ level ] <= i : i -= node . width [ level ] c # the left step node = node . next [ level ] return node . value 插入操作 ：首先进行类似的查找操作，找到节点后利用随机数确定新插入节点的层级。 def insert ( self , value ): # find first node on each level where node.next[levels].value > value chain = [ None ] * self . maxlevels steps_at_level = [ 0 ] * self . maxlevels node = self . head for level in reversed ( xrange ( self . maxlevels )): while node . next [ level ] . value <= value : steps_at_level [ level ] += node . width [ level ] node = node . next [ level ] chain [ level ] = node # insert a link to the newnode at each level d = self . random_level () newnode = Node ( value , [ None ] * d , [ None ] * d ) steps = 0 for level in xrange ( d ): newnode . next [ level ] = chain [ level ] . next [ level ] chain [ level ] . next [ level ] = newnode newnode . width [ level ] = chain [ level ] . width [ level ] - steps chain [ level ] . width [ level ] = steps + 1 steps += steps_at_level [ level ] for level in xrange ( d , self . maxlevels ): chain [ level ] . width [ level ] += 1 self . size += 1 删除操作 ：首先进行类似的查找操作，找到后根据chain数组调整相应的指针指向，然后删除节点. def remove ( self , value ): # find first node on each level where node.next[levels].value >= value chain = [ None ] * self . maxlevels node = self . head for level in reversed ( range ( self . maxlevels )): while node . next [ level ] . value < value : node = node . next [ level ] chain [ level ] = node if value != chain [ 0 ] . next [ 0 ] . value : raise KeyError ( 'Not Found' ) d = len ( chain [ 0 ] . next [ 0 ] . next ) for level in range ( d ): prevnode = chain [ level ] prevnode . width [ level ] += prevnode . next [ level ] . width [ level ] - 1 prevnode . next [ level ] = prevnode . next [ level ] . next [ level ] for level in range ( d , self . maxlevels ): chain [ level ] . width [ level ] -= 1 self . size -= 1 PS:需要注意的是每个节点的提升都是随机的，因此算法每次执行的结果 也可能不相同。 具体实现见 Github","tags":"计算机科学","loc":"www.houcj.net/blog/2014/09/06/skip-list/","title":"Skip List"},{"text":"AWK AWK is a language for processing text files. A file is treated as a sequence of records, and by default each line is a record. Each line is broken up into a sequence of fields, so we can think of the first word in a line as the first field, the second word as the second field, and so on. An AWK program is of a sequence of pattern-action statements. AWK reads the input a line at a time. A line is scanned for each pattern in the program, and for each pattern that matches, the associated action is executed — Alfred V. Aho 基本语法 condition '{action}' 其中单引号中被大括号括起来的就是awk语句。只能用单引号 awk '{print $10 }' file.txt 内置变量 NR : Keeps a current count of the number of input records . NF : Keeps a count of the number of fields in an input record . The last field in the input record can be designated by $NF . FILENAME : Contains the name of the current input - file . FS : Contains the \"field separator\" character used to divide fields on the input record . The default , \"white space\" , includes any space and tab characters . FS can be reassigned to another character to change the field separator . RS : 输出字段分隔符， 默认为换行符。 OFS : 输出字段分隔符， 默认是空格符。 ORS : 输出字段分隔符， 默认是换行符。 $n 表示第 n 列， $0 表示整行 OFMT : Stores the format for numeric output . The default format is \"%.6g\" . 指定分隔符 awk 'BEGIN{FS=' : '} {print $0}' file.txt 等价于 awk -F: '{print $0}' file.txt 如果有多个分隔符，可以 awk -F '[;:,]' 使用OFS参数就可以改变输出分割符。 awk -F: '{print $0}' OFS = \"\\t\" file.txt 字符串匹配 有效的电话号码 awk '/&#94;([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/' file.txt //中是匹配的pattern，遵循正则表达式的语法。 字符串连接操作 awk字符串转数字 awk 'BEGIN{a=\"1\";b=\"2\";print (a+b+3);}' # output is 6 + 连接运算自动把字符串转为整数类型 awk字符串连接 awk 'BEGIN{a=\"a\";b=\"b\";c=a\"\"b;print c}' 将变量与\"\"连接起来即可。 用户自定义函数 计算单词的频率 BEGIN { FS = \"[&#94;a-zA-Z]+\" } { for ( i = 1 ; i< = NF ; i++ ) words [ tolower ( $i )] ++ } END { for ( i in words ) print i, words [ i ] } BEGIN｛执行之前的语句｝ ｛处理每一行要执行的语句｝ END｛处理完所有的行后要执行的语句｝ sed sed是用来解析和转换文本文件的简单的编程语言，尤其擅长replace操作。 Sed editing Commands 这些编辑命令和vim编辑器的比较类似 sed 'm,ns/regexp/replacement/g' inputFileName > outputFileName # 如果是特殊字符,需要使用\"\\\"进行转义，如果特殊字符里包含单引号，需要使用双引号 sed \"m,ns/regexp/replacement/g\" inputFileName > outputFileName sed 'm,ns/regexp/replacement/mg' inputFileName > outputFileName # only replace the replacment from the mth. m,n分别代表第m，n行的文本。 s 代表替换操作， g 代表是全局替换。 特别地 sed 's/&#94;/repalcement/g' inputFileName # add the replacment charater to the front sed 's/$/repalcement/g' inputFileName # add teh replacment charater to the end 原地替换 sed -i 's/regexp/replacement/g' inputFileName 使用圆括号匹配 使用圆括号括起来的正则表达式所匹配的字符串可以当成变量来使用，sed 使用的是\\1\\2... sed 's/the line in the file \\(pattern1\\), and \\(pattern2\\)/\\1:\\2/g' a编辑命令i编辑命名c编辑命令 a命令：append text below current line sed 'na appendString' filename # na 表示在第n行以后进行append，如果n超过filename的行数，就不进行任何操作 sed '/pattern/a appendString' filename # 在匹配到pattern以后就append一行 i命令：insert text above current line 具体操作同a命令 c命令：change text in the current line with new text 具体操作同a命令 d编辑命令 删除匹配行 sed '&#94;,$,d' filename # 删除文件的内的所有行 p编辑命令 打印命令，单独使用会打印两遍处理的和sed -n 配合使用相当于grep命令 sed -n '1,/pattern/p' filename # 从第一行打印到匹配fish成功的那一行 sed options sed -f 当有大量的sed命令时，可以把这些sed命令放到一个文件中（每条命令都需要 单独成行）,可以然后使用下面的命令 sed -f sedscript filename # or the long version sed -file = sedscript filename sed -n Silent mode，suppresses automatic printing of lines， 即只打印匹配pattern的行。 sed -e 当有多个匹配的时候，可以使用下面的命令 sed -e 's/regexp1/replacement1/g' -e 's/regexp2/replacement2/g' inputFileName sed -r 支持扩展的正则表达式 sed -n -r '/regex/p' filename # 匹配file里所有符合regex的文件行 sed Hold Space 上面的命令几乎都遵循这样的格式 [address[,address]][!]{cmd} 其中 ！ 表示匹配成功后是否执行。 同时，如果cmd有多个，可以用分号分开，用大括号括起来作为嵌套命令。 sed 'm,n {/pattern1/{/pattern2/d}}' filename # 对第m行到n行，先匹配pattern1，在匹配pattern2，然后执行d删除命令 下面具体介绍 Hold space h H : copy/append pattern space to hold space. g G : copy/append hold space to pattern space. n N : Read/append the next line of input into the pattern sapce. 当sed逐行读取文件的时候，这些 已经被读取的文件行就放到pattern buffer（pattern space）里。Pattern buffer相当于一个缓存，当你 用sed进行输出的时候，它会输出pattern buffer的内容。 Hold buffer/hold space 相当于一个长久的存储。一般情况我们 不会直接处理hold buffer的内容，当需要处理的时候我就会把hold buffer的 内容copy到pattern buffer里进行处理. sed -n '1!G;h;$p' # 和tac的功能一样，print the file in reverse tail & head head:print the first part of a file tail:print the last part of a file tail & head options head|tail -q : 隐藏文件名 head|tail -v : 显示文件名 head|tail -c <m> : 显示字节数 head|tail -n <m> : 显示行数 wc wc 是用来读取标准输入输出文件中的行数，单词数目。如果有多个文件时 单个文件和综合的统计都会输出。 用法 wc -l print the line count (note that if the last line does not have \\n, it will not be counted) wc -c print the byte count wc -m print the character count wc -L print the length of longest line wc -w print the word count sort sort对文本文件的line进行排序 用法 sort -n The -n option makes the program sort according to numerical value sort -k The -k option makes the program sort using the k column of data sort -r The -r option just reverses the order of the sort sort -u The -u option with -c, check for strict ordering; without -c, output only the first of an equal run cut cut是用于获取文件的line中的指定部分。 用法 cut -c 以charactor为单位 cut -b 以byte为单位 cut -d \":\" 指定分隔符，默认为tab cut -n Used in combination with -b suppresses splits of multi-byte characters cut -fn 截取第n个section tr tr (translate) or delete character tr 语法 tr [-cds] [string1 [string2]] tr -c : complement the set of characters in string1 with respect to the universe of characters whose ASCII codes are 01 through 0377 tr -d : delete all input characters in string1 tr -s : squeeze all strings of repeated cut cut 别用来提取文件行中的特定部分。 cut -f : specifies a filed list, separated by a delimiter cut -s : bypasses lines which contain no field delimiters when -f is specified, unless otherwise indicated. cut -d : use delimter instead of TAB for field delimiter #Select a Specific Field from a File $ cut -d ':' -f1 /etc/passwd grep grep (Globel search a Regular Expression and Printing out the line)是一种强大 的文本搜索工具，它使用正则表达式搜索文本，并把匹配的line打印出来。 grep options grep -r : 递归搜索 grep -v : 反向选取，只显示不符合pattern的行 grep -o : 只显示被模式匹配到的字符串，而不是整个行 grep -i : 匹配时不区分大小写 grep -E : 使用扩展的正则表达式 Xargs xargs is a command is used to build and execute command lines from standard input. The xargs command (by default) expects the input from stdin, and executes /bin/echo command over the input。 After you type something, press ctrl+d, which will echo the string back to you on stdout as shown below. $ xargs -d \\n Hello, World.#Hello, #World. Limit Output per line Using -n option $ echo a b c d e f | xargs -n 3 a b c d e f # compare $ echo a b c d e f | xargs -n 2 a b c d e f Combine Xargs with other command find . -name '*.c' | xargs grep 'stdlib.h' # find the c file with stdlib.h find . -type f -print | sed -e 's/&#94;/\"/' -e 's/$/\"/' | xargs chmod 644 find . -name \"*.c\" | xargs rm -rf # delete the file with .c suffix nm The nm commands provides information on the symbols being used in an object file or executable file. The following command sorts the output by the size of symbols $ nm -g --size-sort 1 0000000000000002 T __libc_csu_fini 0000000000000004 R _IO_stdin_used 0000000000000004 B abc 0000000000000084 T main 0000000000000089 T __libc_csu_init","tags":"编程","loc":"www.houcj.net/blog/2014/07/19/shell/","title":"Introduction to Shell"},{"text":"常见位操作：获取、设置、清除位数据 获取num第i位的bit值 将1左移i位，从而得到形如00100000的值，然后将这个值与val执行and操作，从而将 第i位之外的所有位清零。 boolean getBit ( int num , int i ){ return (( num & ( 1 << i )) != 0 ); /*another solution*/ return (( num >> i ) & 1 ); } 将num第i位的bit值置为1 同获取操作类似，只是把and操作变为or操作即可。 int setBit ( int num , int i ){ return num | ( 1 << i ); } 将num第i位bit值置为0 同setBit相反，首先需要将1左移i位后取反，变为形如11011111的 掩码，让该掩码与num进行and操作即可。 int clearBit ( int num , int i ){ int mask = ~( 1 << i ); return num & mask ; } 把num从最高位到i位清零的算法如下： int clearBitsMthroughI ( int num , int i ){ int mask = ( 1 << i ) - 1 ; return num & mask ; } 把num从第i位至0位清零的算法如下： int clearBitsMthroughI ( int num , int i ){ int mask = ~(( 1 << ( i + 1 )) - 1 ); return num & mask ; } Single Number II Given an array of integers, every element appears three times except for one. Find that single one. Note : Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 分析 由于别的元素都出现三次,因此所有的元素的在第i为的bit值之和取模3时的余数 必然为只出现一次元素在第i位的bit值,同时需要注意元素为负数时的处理. Python Code class Solution : # @param {integer[]} nums # @return {integer} def singleNumber ( self , nums ): target = 0 count = 0 n = len ( nums ) for i in range ( n ): if nums [ i ] < 0 : count += 1 for i in range ( 32 ): bit = 0 for j in range ( n ): bit += ( nums [ j ] >> i ) & 1 # 让数组中的元素的bit位的数值相加 target |= ( bit % 3 ) << i return target if count % 3 != 1 else - target Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 分析 这里的trick是当m,n很大时,很容易超时! 但是我们发现and运算时,有0出现时,整个结果必为0. 同时n为m的2倍或者以上的时候, 每个bit位就都会有0出现,因此结果必为0. Python Code class Solution : # @param m, an integer # @param n, an integer # @return an integer def rangeBitwiseAnd ( self , m , n ): if m << 1 <= n : return 0 res = m for i in range ( m + 1 , n + 1 ): res = res & i return res Some Tricks n中包含1的数量 int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { ans ++ ; n = n & ( n - 1 ); } return ans ; } 判断X是否是2的N次方 bool f ( int x ) { return ! ( x & ( x - 1 )); } 求x和y的平均值 int f ( int x , int y ) { return ( x & y ) + (( x &#94; y ) >> 1 ) } x&y 是取相同的位进行与操作，这个结果是x和y相同位的一半，x&#94;y 是取x和y的不同位，右移相当于除于2. 求和不使用加减法 // 迭代版本 int add ( int a , int b ) { int ans = 0 ; while ( b ) { ans = a &#94; b ; b = ( a & b ) << 1 ; a = ans ; } return ans ; } // 递归版本 int add1 ( int a , int b ) { if ( b == 0 ) { return a ; } int ans = a &#94; b ; b = ( a & b ) << 1 ; return add1 ( ans , b ); } 交换高低位 // 交换高16位与低16位.右移时会高位补0，左移时低位补0，两个取或操作即可。 a = ( a >> 16 ) | ( a << 16 ) hash 操作里为什么一般使用异或操作？ 在等概率的0和1出现的情况下，and操作下的0出现的概率为25%，1出现的概率为75%；or操作正好和and 操作的结果相反。而xor操作则可以保证0和1以以相同的50%的概率出现。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/06/02/bit-manipulaiton/","title":"位操作"},{"text":"fork()通过复制现有的进程来创建一个新进程，现有进程就是父进程，新创建的 进程是子进程。子进程拷贝了父进程的绝大部分：栈、缓冲区等。系统为子进程 创建一个唯一的进程id，同时父子进程共享代码空间，但是当发生写数据的时候， 系统会为子进程申请新的页面。fork（）成功的时候返回父进程，失败的时候返回0。 具体情况看下面代码。 # include<stdio.h> # include <unistd.h> # include<sys/types.h> int main () { int i = 1 ; if ( ! fork ()) i ++ ; printf ( \"first call i is=%d,the pid=%d,the ppid=%d \\n \" , i , getpid (), getppid ()); if ( ! fork ()) i ++ ; printf ( \"second call i is=%d,the pid=%d,the ppid=%d \\n \" , i , getpid (), getppid ()); return 0 ; } 通过 PS 查看进程可以知道进程的关系为： 11445->11853->11854->11856 ->11855 从中我们得出父进程create了copy自己的两个子进程，其中第一次产生的子进程也进行了一次fork操作。 每次fork操作都会复制相应的代码和数据。","tags":"编程","loc":"www.houcj.net/blog/2014/04/25/fork/","title":"fork()系统调用"},{"text":"字符串匹配 Implement strStr() Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 暴力解法 在haystack中遍历，直到可以找到于needle相匹配的位置。O(nm)时间复杂度, O(1) 空间复杂度的暴力解法: def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) for x in range ( n - m + 1 ): if haystack [ x : m + x ] == needle : return x return - 1 KMP解法 匹配过程的时间复杂度为O(n)，预处理时间时间复杂度为O(m). O(m)的空间用来存储预处理数组。 KMP的核心就在于扫描字符串haystack，并更新可以匹配到needle的位置。 当haystack中的字符和needle中匹配的时候继续。 不匹配的时候让haystack向右移动，这里使用了一个预处理数组来 确定haystack应该移动的位置：不匹配字符所在位置 - 不匹配字符对应的预处理数组中的值 预处理数组在下面介绍。 def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) if m == 0 : return 0 prefix = self . compute_prefix ( needle ) j = - 1 for i in range ( n ): while j > - 1 and needle [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if needle [ j + 1 ] == haystack [ i ]: j = j + 1 if j == m - 1 : return i + 1 - m #j = prefix[j] find more possible position for the next match return - 1 计算某个字符对应的预处理的值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀。 具体算法如下。 def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix 应用:Shortest Palindrome Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. For example: Given \"aacecaaa\", return \"aaacecaaa\". Given \"abcd\", return \"dcbabcd\". 分析 我们知道回文的性质就是正反都相同。因此，我们以反转的字符串为母串，以原来的字符串为字串进行匹配。找到从源字符串 开始的最长的公共字串，然后把公共字串后面的字符串insert到源字符串。这道题的trick是容易超时，因此可以使用 kmp进行字符串的匹配。时间复杂度为O(n)的kmp字符串匹配长度，O(L)的字符串长度的空间复杂度。 具体见下面的代码 class Solution : def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix 其中 s[m-1:j:-1] 表示s中的字符串从j到最后一位的反转。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/03/21/kmp/","title":"字符串匹配"},{"text":"一、斐波那契博弈 题目 有一堆个数为n(n>=2)的石子，游戏双方轮流取石子，规则如下： 先手不能在第一次把所有的石子取完，至少取1颗； 之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。 约定取走最后一个石子的人为赢家，求必败态。 结论：当n为Fibonacci数的时候，先手必败。 用第二数学归纳法证明： 为了方便，我们将n记为f[i]。 当i=2时，先手只能取1颗，显然必败，结论成立。 假设当i<=k时，结论成立。 则当i=k+1时，f[i] = f[k]+f[k-1]。 则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。（一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]， 则后手可以直接取完f[k]，因为f[k] < 2*f[k-1]） 对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。 如果先手第一次取的石子数y>=f[k-1]/3，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时x=f[k-1]-y， 则x<=2/3*f[k-1]。 我们来比较一下2/3*f[k-1]与1/2*f[k]的大小。即4*f[k-1]与3*f[k]的大小，对两值作差后不难得出，后者大。 所以我们得到，x<1/2*f[k]。即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗， 所以后手必胜。 即i=k+1时，结论依然成立。 那么，当n不是Fibonacci数的时候，情况又是怎样的呢？ 这里需要借助\"Zeckendorf定理\"（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。分解的时候， 要取尽量大的Fibonacci数。 比如分解85：85在55和89之间，于是可以写成85=55+30， 然后继续分解30,30在21和34之间，所以可以写成30=21+9， 依此类推，最后分解成85=55+21+8+1。 则我们可以把n写成 n = f[a1]+f[a2]+……+f[ap]。（a1>a2>……>ap） 我们令先手先取完f[ap]，即最小的这一堆。由于各个f之间不连续， 则a(p-1) > ap + 1，则有f[a(p-1)] > 2*f[ap]。 即后手只能取f[a(p-1)]这一堆，且不能一次取完。 此时后手相当于面临这个子游戏（只有f[a(p-1)]这一堆石子，且后手先取）的必败态， 即先手一定可以取到这一堆的最后一颗石子。 同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。 二、 小岛的故事 题目 一个岛上有100个人，其中有5个红眼睛，95个蓝眼睛。这个岛有三个奇怪的宗教规则。 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就必须在当天夜里自杀。 某天，有个旅行者到了这个岛。 由于不知道这里的规矩，所以他在和全岛人一起的时候，不留神就说了一句话： 你们这里有红眼睛的人。 假设这个岛上的人足够聪明，每个人都可以做出缜密的逻辑推理。 问题一：请问这个岛上将会发生什么？ 分析一 假设岛上只有一个人是红眼睛，那么当天他看到有99个蓝眼睛就会自杀。 假设岛上有两个人是红眼睛，两个红眼睛的人都会假定自己不是红眼睛，结果发现第二天没有人会自杀， 因此他知道岛上有 两个红眼睛，而自己是其中的一个，于是两个人在第二天就都会自杀。 同理，当岛上有5个红眼睛时，它们就会在第五天一起自杀 问题二：那么旅行者存在的意义是什么呢？毕竟一开始岛上每个人都知道岛上存在红眼睛。 分析二： 假设岛上只有一个是红眼睛，他会看到99个都是蓝眼睛，但是他无法自己是红眼睛，因此他不会自杀。 假设岛上有两个人是红眼睛，虽然他会看到98个蓝眼睛，1个红眼睛，但他无法确定自己是红眼睛。 因此2个红眼睛是可以稳定存在。 同理，5个红眼睛是可以稳定存在的。 因此：旅行者出现的意义在于，他说了那句话，大家的推理方式就变了。 三、可怜的小白鼠 题目： 有8瓶酒，只有一瓶有毒。喝酒之后，1天会死，只有1天时间。请问至少需要多少只老鼠可以找到有毒的那只瓶子。 分析： 8瓶，1瓶有毒 即使某一个老鼠没有被毒死，也不会有时间重复利用了 老鼠开始喝酒，第一只要喝哪些，第二只要喝哪些呢？现在有什么依据么？显然酒瓶和老鼠都是一样的，不可区分的。 那么怎么来选择哪些老鼠喝哪瓶酒，进而进行判断呢？这是这个题目的关键点、核心点。8个酒瓶，我们对其编号0-7， 如下为二进制的表示， 编号 二进制 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 观察每一位的0和1的分布情况，从右向左，我们可以让第一只老鼠喝掉都是1的，即标号为1，3，5，7的瓶子 同样的，同时，另外两只老鼠测试第二位为1的瓶子以及第三位为1的瓶子。 假设结果为第一只死亡，第二只生存，第三只死亡，我们可以确定，那个有毒瓶子的编号为101，（有毒的瓶子出现，小白鼠必死，）即编号为5的瓶子为有毒的瓶子。 此类的题目分析的思路的关键就是找到突破口：表示为二进制的形式。 四、开灯关灯 题目： 有100盏灯，依次编号1-100，初始都是关着的。第1次遍历，打开全部的灯；第2次遍历，关掉第2盏、第4盏等被2整除的灯； 第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作 如果灯开着，就关掉 如果灯关着，就打开 如此交替进行，知道100次遍历完毕，请问，还有多少盏灯亮着。 分析： 例如编号为10的灯： 第1次能够操作，打开 第2次能够操作，关闭 第5次能够操作，打开 第10次能够操作，关闭 最终编号为10的灯是关闭的。 再来看编号为49这盏灯： 第1次能够操作，打开 第7次能够操作，关闭 第49次能够操作，打开 最终编号为49的灯打开着。 通过上面两个例子，编号为n的灯，有多少个因数，就有会被操作多少次。 很显然，如果是偶数次，则灯一定是关着的。那什么情况下，操作会是奇数次呢？一个数，每次分解，都是两个数相乘， 只有当这两个数相同的时候， 才会是偶数次。 所以，最终会亮着的灯，都能够开平方， 得到一个正整数：1,4,9,16,25,36,49,64,81,100. 【分析完毕】 五、天平称小球 题目 N个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。 分析 由于每次天平都有3种状态，左倾，右倾，平衡。因此每次可以为我们提供3种信息。因此我们应该尽量让N个小球切分为3份。 特别地，当不妨假设有6个球，来考虑一下3、3称和2、2称的区别： 在未称之前， 一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。 现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后， 不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）： 1重、2重、3重、4轻、5轻、6轻。 即这种称法能排除一半可能性。 现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。 假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。 假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。 总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！ 特别地，考虑N=3时，至少需要2次才能找到那个坏球。 因此这种方法最少的次数为 $$\\lfloor\\log3N\\rfloor+1$$ 六、称药丸 题目 有20瓶药丸，其中19瓶有1g/粒的药丸，余下一瓶装1.1g/粒的药丸。给你一台称重精准的天平，怎么找出比较 重的那瓶药丸？ 分析 由于天平只能用一次，因此必须利用预期重量和实际测量中间之间的差别，来得到那一瓶较重的药丸。就是放大他们的重量的差异。 假设有两瓶药丸，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，如果为3.1g，那么必然第一瓶为较重的。 否则，重量必然为3.2g。 同理，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，从第十瓶中取10粒药丸。如果都为1g那么总重量为210g（1+2+3+...10=20*21/2=210） 那么药品的编号可用 （weight-210）/ 0.1 得出。 赛跑 题目 25个人, 每5人1个跑道, 最少经过几次赛跑, 得到前3名? 具体如下： 1. 25个人分为五组进行比赛，决出每组的第一名 2. 用这五个第一名进行一次比赛，依照顺序称呼为A、B、C、D、E 3. 由于需要前三名，所以D、E所在的组已经没有意义了（他们组的人都比他们慢），B、C 与 A所在组的第二名第三名（可能A所在组的前三名就是25人中的前三名）， 再加上B所在组的第二名（可能为A、B + B组第二），五人进行比赛，决出的前两个即为25人中的第二与第三。 综上所述，共为7次。 或者使用胜者树，每次都可以淘汰4个人。然后把每次胜出的人和剩下的人中的四个进行比较，然后胜出的继续比较。这样一共需要 (1+4*6=25)6次比较就可以得到第一名，然后把剩下的第二名和第三名和胜者树中比较靠近根部的节点进行比赛。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2014/02/20/mind-trick/","title":"Mind trick"},{"text":"等概率：蓄水池问题 要求从N个元素中随机的抽取k个元素，其中N无法确定。 这种应用的场景一般是数据流的情况下，由于数据只能被读取一次，而且数据量很大，并不能全部保存，因此数据量N是无法在抽样开始时确定的；但又要保持随机性，于是有了这个问题。所以搜索网站有时候会问这样的问题。 这里的核心问题就是\"随机\"，怎么才能是随机的抽取元素呢？我们设想，买彩票的时候，由于所有彩票的中奖概率都是一样的，所以我们才是\"随机的\"买彩票。那么要使抽取数据也随机，必须使每一个数据被抽样出来的概率都一样。 分析： 由于N无法确定，数据只能读取一次，并且要求随机，就是每个元素抽出的概率一样，都是k/N。 解法一：最小k个指纹 找到一个哈希函数能产生随机数，同时用一个k个元素的堆用来保存最小的k个元素。那么过一遍所有的元素，计算每个的哈希值，通过堆来选择k个元素。 解法二：数学计算 先选中前k个， 从第k+1个元素到最后一个元素为止， 以1/i (i=k+1, k+2,...,N) 的概率选中第i个元素， 并且随机替换掉一个原先选中的元素， 这样遍历一次得到k个元素， 可以保证完全随机选取。 任意元素G在i轮留下来的概率： P(G留下) = P(G已经存在) * P(G没有被替换) = P(G已经存在) * (1 - P(G被替换)) = P(G已经存在) * (1 - P(第i个元素要替换某个元素) * P(某个元素是G)) = (k/i) * (1 - (k/(i+1)) * (1/k)) = (k/i) * (1 - (1/(i+1))) = (k/i) * (i/(i+1)) = (k/(i+1)) 证毕！ 拒绝采样 Given a function which generates a random integer in the range 1 to 7, write a function which generates a random integer in the range 1 to 10 uniformly. 分析： 下面是我们通过两次rand7()的位置，第一次代表行的位置，第二次代表列的位置，然后来唯一确定1-10的值， 其中\"*\"表示随机从下面的表中取出一个数字。 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 8 9 10 1 2 3 4 3 5 6 7 8 9 10 1 4 2 3 4 5 6 7 8 5 9 10 1 2 3 4 5 6 6 7 8 9 10 * * 7 * * * * * * * 具体算法如下 int rand10 () { int row , col , idx ; do { row = rand7 (); col = rand7 (); idx = col + ( row - 1 ) * 7 ; } while ( idx > 40 ); return 1 + ( idx - 1 ) % 10 ; } 洗牌算法 Given an array of distinct integers, give an algorithm to randomly reorder the integers so that each possible reordering is equally likely. In other words, given a deck of cards, how can you shuffle them such that any permutation of cards is equally likely? 分析 洗牌算法可以有效的解决这类问题，所谓的洗牌算法就是按顺序依次遍历所有的牌，然后从后面的元素中随机的取一个元素来与当前元素交换 import random def Shuffle ( li ): n = len ( li ) for x in xrange ( n - 1 , 0 , - 1 ): y = random . randint ( 0 , x ) # 从后面的数据中随机选取一个 li [ x ], li [ y ] = li [ y ], li [ x ] # 将随机选取的元素与当前位置元素互换 如果某个元素被放入第i（1≤i≤n ）个位置，就必须是在前i - 1次选取中都没有选到它，并且第i次选取是恰好选中它。 其概率为： \\begin{equation*} p_i=\\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\cdots\\times\\frac{n-i+1}{n-i+2}\\times\\frac{1}{n-i+1}=\\frac{1}{n} \\end{equation*} 条件概率 老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？ [假设生男生女的概率相等] 分析 根据题目可以得出，两个事件，事件A:至少有一个周二出生的男孩，事件B:两个孩子都是男孩。题目所求即为P(B|A)，即在A事件满足的条件下，B事件发生的机率。 由贝叶斯公式可得： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 依次计算公式中的各个概率值： 在已知两个孩子都是男孩的条件下，至少有一个是周二出生的男孩： \\begin{equation*} P(A|B)=1-{(\\frac{6}{7})}&#94;2=\\frac{13}{49} \\end{equation*} 两个孩子都是男孩： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 至少有一个孩子是周二出生的男孩： \\begin{equation*} P(A)=1-{(\\frac{1}{2}\\times\\frac{6}{7}+\\frac{1}{2})}&#94;2=\\frac{27}{196} \\end{equation*} 代入即可得： \\begin{equation*} P(B|A)=\\frac{P(A|B)P(B)}{P(A)}=\\frac{13}{49}\\times\\frac{1}{4}\\div\\frac{27}{196}=\\frac{13}{27} \\end{equation*} if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/18/equal-probability/","title":"概率问题"},{"text":"Trie (前缀树) Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. 分析 Trie ，又称前缀树或字典树，是一种有序树，用于保存关联数组， 其中的键通常是字符串，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的空字符串，而根节点对应空字符串。 由于Python是强类型语言，不支持隐式类型转换，因此使用字典来存储效果更好。 Python Code class TrieNode : def __init__ ( self ): self . word = None self . children = {} class Trie : def __init__ ( self ): self . root = TrieNode () def insert ( self , word ): node = self . root for char in word : if char not in node . children : node . children [ char ] = TrieNode () node = node . children [ char ] node . word = word def search ( self , word ): node = self . root for char in word : if char not in node . children : return False node = node . children [ char ] return node . word == word def startsWith ( self , prefix ): node = self . root for char in prefix : if char not in node . children : return False node = node . children [ char ] return True # Your Trie object will be instantiated and called as such: # trie = Trie() # trie.insert(\"somestring\") # trie.search(\"key\") 前缀树的应用 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. For example, Given words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] Return [\"eat\",\"oath\"]. Note: You may assume that all inputs are consist of lowercase letters a-z. 分析 如果直接使用回溯的方法在board里深搜或者宽搜，由于words里的单词很多， 很容易就会超时。因此可以考虑使用前缀树，使用words里的单词构造一棵前缀树， 然后从这棵前缀树上进行遍历。由于保证每次搜索都在可能出现单词的前缀中，因此 大大提高了剪枝的效率。 Python Code class TrieNode : def __init__ ( self ): self . flag = False self . children = {} class Solution : def __init__ ( self ): self . root = TrieNode () def insert ( self , word ): node = self . root for char in word : if char not in node . children : node . children [ char ] = TrieNode () node = node . children [ char ] node . flag = True def findWords ( self , board , words ): m = len ( board ) n = len ( board [ 0 ]) self . res = [] for word in words : self . insert ( word ) for i in range ( m ): for j in range ( n ): self . dfs ( self . root , i , j , board , m , n , '' ) return self . res def dfs ( self , node , row , col , board , m , n , word ): if node . flag : self . res . append ( word ) node . flag = False if 0 <= row < m and 0 <= col < n : char = board [ row ][ col ] if char in node . children : board [ row ][ col ] = '#' word += char self . dfs ( node . children [ char ], row - 1 , col , board , m , n , word ) self . dfs ( node . children [ char ], row + 1 , col , board , m , n , word ) self . dfs ( node . children [ char ], row , col - 1 , board , m , n , word ) self . dfs ( node . children [ char ], row , col + 1 , board , m , n , word ) board [ row ][ col ] = char LRU LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析 在常数时间内，可以使用一个双向链表来完成删除和插入到链表末尾的操作。而使用hash则可以在常数时间完成从key到value的映射。 因为这个算法的关键是用hash table + double link list来实现。 当使用get(key)时，这时双向链表中的key节点需要删除，然后插入到链表末尾。而 最近一直不使用的节点则放在链表的头部，等待被替换。Python中的collections.OrderedDict()就是用一个双向链表 来维护的一个字典（即map）见下面的代码。当然我们也可以自己实现一个双向链表，见 Github Python Code class LRUCache : def __init__ ( self , capacity ): self . capacity = capacity self . cache = collections . OrderedDict () def get ( self , key ): if key not in self . cache : return - 1 value = self . cache . pop ( key ) self . cache [ key ] = value # del the key item and insert to the last return value def set ( self , key , value ): if key in self . cache : self . cache . pop ( key ) if len ( self . cache ) == self . capacity : self . cache . popitem ( last = False ) # del from the front self . cache [ key ] = value","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/13/trie-lru/","title":"Trie-LRU"},{"text":"TCP为每个连接建立了七个定时器。下面讲按照这些定时器在一条连接生存期内出现的次序依次进行介绍。 Connection establishment Timer(​连接建立定时器) 为了防止client端一直等待服务器端的情况发生。 在Client发送SYN报文段建立新的链接时，该定时器启动，如果在75s内没有收到响应，连接建立将会终止。确定连接的有效建立。 Retransmission Timer(重传定时器) 重传定时器在TCP发送数据时设定。在该定时器超时，而没有收到另外一端的ACK的时候，将重传数据。重传定时器的值是动态计算的，取决于该连接RTT的值和被重传的次数。 Delayed ACK Timer(延迟ACK定时器)定时器在200ms 延迟ACK定时器负责在该终端（end）收到一个数据包时，无需马上发出ACK进行确认，而是等待200ms内，有数据要在该连接上发送，延迟的ACK响应就可随着数据一起发送回另一个终端。这种方式也被成为捎带确认。 Persist Timer（持续定时器） 持续定时器在收到连接另一端的发送通告窗口为零时，阻止该端继续发送数据时设定。因此当该端有数据要发送时， 但连接的另一端的通告窗口为零时，持续定时器就会启动，超时后向连接另一端发送1字节的数据，来判断另一方的接收窗口是否打开。被称为零窗口探测。持续定时器的值是动态计算的，取决于往返时间，时间在5s到60s之间取值。 Keep alive Timer（保活定时器） 如果连接的持续时间超过2hour，保活定时器就会超时，向对端发送连接探测报文，强迫对端发出响应。如果连续若干次保活测试收不到相应的相应，就认为对端发生了故障。 FIN_WAIT_2 Timer 当某个连接从FIN_WAIT_1状态变迁到FIN_WAIT_2状态，并且不能再收到任何新的数据时，该定时器就会启动设为10分钟。定时器超时重设为75s，第二次超时后连接被关闭。该定时器的目的是为了避免对方一直不发送FIN，某个连接一直处于FIN_WAIT_2状态。 TIME_WAIT_Timer (也成为2MSL定时器) 当连接转移到TIME_WAIT状态，定时器启动。2MSL等待时间的原因就是为了确保最后一个ACK在一个MSL丢包后重传 TCP包括连个定时器函数，快速定时器（200ms调用一次），慢速定时器（500ms）调用一次。延迟ACK定时器时，每个200ms超时后，延迟的ACK必须被发送。其他的定时器是每500ms递减一次，计数器减为0时，就触发相应的动作。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/01/02/timer/","title":"TCP中的七种定时器"},{"text":"回溯 对于搜索问题和优化问题，它们的解分布在一个解空间里，求解这些搜索问题的算法 就是一种遍历搜索解空间的系统方法。回溯算法将搜索空间看作一定的结构，一个解对应于树中的一片树叶。算法从 根节点出发，尝试所有可达的节点。当不能前进时，就后退一步或若干步，再从另一个节点继续 搜索，知道所有的节点都尝试过，为了加快搜索，通常使用分支限界等剪枝方法。同时需要记录解的路径 重复访问和重复解 重复访问 在图等数据结构的访问中，经常会出现重复访问的情况，这时需要记录临时访问到的节点，然后在访问结束时要恢复临时节点的值。 重复解 在枚举所有解的情况时，如果当前访问的层的节点值和pre层的节点值相等就会出现重复解的情况，需要记录pre层访问的节点值来解决这种情况。 N皇后 The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. For example, There exist two distinct solutions to the 4-queens puzzle: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] 分析 这里有个trick，就是可以用board[row] = col 来表示访问到第row行第col列。然后我们只要使用 长度为N的一纬数组就可以表示这个解。例如[4,2,7,1,3,5,8,6]，表示在第一行皇后放在第4列，...，第8行 中皇后放在第6列。同时DFS遍历时需要注意，排除那些不满足条件的解。 Python Code class Solution : def solveNQueens ( self , n ): self . res = [] self . dfs ( 0 ,[], n , [ - 1 for i in xrange ( n )]) return self . res def dfs ( self , depth , answer , n , board ): if depth == n : self . res . append ( answer [:]) # fast than self.res.append(answer) return for col in range ( n ): flag = True for row in range ( depth ): if board [ row ] == col or ( depth - row ) == abs ( col - board [ row ]): flag = False break if flag : board [ depth ] = col self . dfs ( depth + 1 , answer + [ '.' * col + 'Q' + '.' * ( n - col - 1 )], n , board ) Combination Sum III Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Ensure that numbers within the set are sorted in ascending order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] 分析 每次都在比前一个解大的基础上进行遍历，直到k个解的和为n。不会重现重复解的情况。 Python Code class Solution : # @param {integer} k # @param {integer} n # @return {integer[][]} def combinationSum3 ( self , k , n ): self . res = [] self . dfs ( k , n , 0 ) return self . res def dfs ( self , k , n , start , tmp = []): if n < 0 : return elif n == 0 and k == 0 : self . res . append ( tmp [:]) return else : for i in range ( start + 1 , 10 ): if n < i : return self . dfs ( k - 1 , n - i , i , tmp + [ i ]) SubSet II Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: - Elements in a subset must be in non-descending order. - The solution set must not contain duplicate subsets. For example, If nums = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 分析 这里在枚举所有解的时候，可能出现重复解的情况，同时需要一个变量来记录解的路径 Python Code class Solution : def subsetsWithDup ( self , nums ): self . res = [] nums . sort () n = len ( nums ) self . dfs ( 0 , 0 , n ,[], nums ) return self . res def dfs ( self , depth , start , n , ans , nums ): self . res . append ( ans ) if depth == n : return pre = - 2 << 10 for index in range ( start , n ): if pre != nums [ index ]: self . dfs ( depth + 1 , index + 1 , n , ans + [ nums [ index ]], nums ) pre = nums [ index ] Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [\"ABCE\"], [\"SFCS\"], [\"ADEE\"] ] word = \"ABCCED\", -> returns true, word = \"SEE\", -> returns true, word = \"ABCB\", -> returns false. 分析 DFS搜索的时候，需要以该元素为中心，上下左右进行递归搜索，这时可能出现重复访问的情况。 同时递归搜索要注意边界条件 Python Code m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): if board [ i ][ j ] == word [ 0 ]: if self . dfs ( i , j , word [ 1 :], board , m , n ): return True return False def dfs ( self , row , col , word , board , m , n ): if len ( word ) == 0 : return True tmp = board [ row ][ col ] board [ row ][ col ] = '#' #up if row > 0 and board [ row - 1 ][ col ] == word [ 0 ]: if self . dfs ( row - 1 , col , word [ 1 :], board , m , n ): return True #down if row < m - 1 and board [ row + 1 ][ col ] == word [ 0 ]: if self . dfs ( row + 1 , col , word [ 1 :], board , m , n ): return True #left if col > 0 and board [ row ][ col - 1 ] == word [ 0 ]: if self . dfs ( row , col - 1 , word [ 1 :], board , m , n ): return True #right if col < n - 1 and board [ row ][ col + 1 ] == word [ 0 ]: if self . dfs ( row , col + 1 , word [ 1 :], board , m , n ): return True board [ row ][ col ] = tmp return False Permutations Given a collection of numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 分析 对于排列问题，首先第一个元素可以出现在排列中的任一个位置，剩下的元素递归的处理， 直到只剩一个元素的时候返回. Python Code class Solution : # @param num, a list of integer # @return a list of lists of integers def permute ( self , num ): n = len ( num ) if n == 1 : return [ num ] res = [] for i in xrange ( n ): for x in self . permute ( num [: i ] + num [ i + 1 :]): res . append ([ num [ i ]] + x ) return res","tags":"编程","loc":"www.houcj.net/blog/2013/12/22/hui-su-yu-fen-zhi-xian-jie/","title":"回溯与分支限界"},{"text":"二叉查找树 由于红黑树本质上就是一棵 二叉查找树 ，所以在了解红黑树之前先来看下二叉查找树。 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值 任意结点的左、右子树也分别为二叉查找树 没有键值相等的结点（no duplicate nodes） 因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn） 红黑树 红黑树是一棵二叉搜索树，并且满足以下性质： 1. 每个节点或者是红色的，或者是黑色的 2. 根节点为黑色 3. 每个叶子节点(NIL)是黑色 4. 如果一个节点是红色的，则它的两个子节点必须是黑色的。 5. 对每个节点，从该节点到其所有后代叶节点的简单路径上，都包含相同数目的黑色节点 PS： - 特性3中的叶子节点，是为空的节点 - 特性5确保没有一条路径比其他路径长两倍。 红黑树的应用 红黑树主要用来存储有序的数据，它的时间复杂度是O(lgn)，空间复杂度也是 O(lgn)。C++ STL中的set、map，linux虚拟内存管理都是通过红黑树去实现。 红黑树的操作 红黑树中有两种基本操作，插入和删除。需要注意的是，每次进行这样的操作的时候都会 有可能改变红黑树的性质，因此必须通过相应的INSERT-FIXUP和DELETE-FIXUP来保证红黑树的性质。 具体情况见 算法导论 ，而它们都会用到旋转的方法。 下面就具体介绍旋转和相应的插入删除操作。 旋转 这里主要介绍左旋，右旋的操作基本类似。 左旋的伪码如下： LEFT_ROTATE ( T , x ) y = x . right # set y x . right = y . left # turn y's left subtree into x's right subtree if y . left != T . nil y . left . parent = x y . parent = x . parent # link x's parent to y if x . parent == T . nil T . root = y elif x == x . parent . left x . parent . left = y else x . parent . right = y y . left = x # put x on y's left x . parent = y 插入 红黑树本身就是一种二叉查找树，插入的时候也需要首先不能改变二叉查找树的性质，然后将该节点着色为 红色(插入红色节点是为了保证满足性质5)。最后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的插入操作 RB_INSERT ( T , z ) y = T . NIL x = T . root while x != T . NIL y = x if z . key < x . key x = x . left else x = x . right z . parent = y if y == T . nil T . root = z elif z . key < y . key y . left = z else y . right = z z . left = T . nil z . right = T . nil z . color = RED RB_INSERT_FIXUP ( T , z ) 插入之后可能破坏红黑树的性质2和4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 z的叔节点y是红色的 1)将父节点设为黑色 2)将叔节点设为黑色 3)将祖父节点设为红色 4)将祖父节点设为当前节点，继续处理 case2 z的叔节点y是黑色的且z是一个右孩子 1)将父节点设为当前节点 2)对当前节点进行左旋操作 case3 z的叔节点y是黑色的且z是一个左孩子 1)将父节点设为黑色 2)将祖父节点设为红色 3)对祖父节点进行右 旋操作 其中z表示当前节点，y表示z的叔节点，z的父节点是红色的。 修复插入操作 RB_INSERT_FIXUP ( T , z ) while z . parent . color == RED if z . parent == z . parent . parent . left y = z . parent . parent . right if y . color == RED # CASE 1 z . parent . color = BLACK y . color = BLACK z . parent . parent . color = RED z = z . parent . parent elif z == z . parent . right # CASE 2 z = z . parent LEFT_ROTATE ( T , z ) z . parent . color = BLACK # CASE 3 z . parent . parent . color = RED RIGHT_ROTATE ( T , z . parent . parent ) else ( same as the previous \"if\" clause # z's parent is a right child with \"right\" and \"left\" extranged ) T . root . color = BLACK 删除 将红黑树内的某一个节点删除花费O(lgn)时间。红黑树本身就是一种二叉查找树，删除的时候也需要首先不能改变二叉查找树的性质， 然后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的删除操作 RB_DELETE ( T , z ) y = z y - original - color = y . color if z . left == T . nil x = z . left RB - TRANSPLANT ( T , z , z . right ) elif z . right == T . nil x = z . right RB - TRANSPLANT ( T , z , z . left ) else y = TREE - MINIMUM ( z . right ) y - original - color = y . color x = y . right if y . parent == z x . parent = y else RB - TRANSPLANT ( T , y , y . right ) y . right = z . right y . right . parent = y RB - TRANSPLANT ( T , z , y ) y . left = z . left y . left . parent = y y . color = z . color if y - original - color == BLACK RB_DELETE_FIXUP ( T , x ) RB - TRANSPLANT ( T , u , v ) if u . parent == T . nil T . root = v elif u == u . parent . left u . parent . left = v else u . parent . right = v v . p = u . p 删除之后可能破坏红黑树性质的1，2，4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 x的兄弟节点w是红色的 1)将x的兄弟节点设为黑色 2)将x的父节点设为红色 3)对x的父节点进行左旋 4)左旋后，重新设置x的兄弟节点 case2 x的兄弟节点w是黑色，w的两个子节点都是黑色的 1)将x的兄弟节点设为红色 2)设置x的父节点为新的x节点 case3 x的兄弟节点w是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的 1)将x兄弟节点的左孩子设为黑色 2)将x兄弟节点设为红色 3)对x的兄弟节点进行右旋 4)右旋后，重新设置x的兄弟节点 case4 x的兄弟节点w是黑色；w的右孩子是红色的 1)将x父节点颜色赋值给x的兄弟节点 2)将x父节点设为黑色 3)将x兄弟节点的右子节设为黑色 4)对x的父节点进行左旋 5)设置x为根节点 其中x为当前节点，w是x的兄弟节点。 修复删除操作 RB_DELETE_FIXUP ( T , x ) while x != root and x . color == BLACK if x == x . parent . left w = x . parent . right # CASE 1 if w . color == RED w . color = BLACK x . parent . color = RED LEFT_ROTATE ( T , p [ x ]) w = x . parent . right if w . left . color == BLACK and w . right . right == BLACK #CASE 2 w . color = RED x = x . parent elif w . right . color == BLACK #CASE 3 w . left . color = BLACK w . color = RED RIGHT_ROTATE ( T , w ) w = x . parent . right w . color = x . parent . color #CASE 4 x . parent . color = BLACK w . right . color = BLACK LEFT_ROTATE ( T , x . parent ) x = T . root else same as the previous \"if\" clause with \"right\" and \"left\" exchanged ; x . color = BLACK ; 下面是一个简单的 Python 实现.","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/red-black-tree/","title":"Black Red Tree"},{"text":"子字符串 最长不重复子串 Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3. For \"bbbbb\" the longest substring is \"b\", with the length of 1. 分析 O(n)时间复杂度， O(1)空间复杂度 可以考虑使用字典，记录字符下标出现的位置。遍历整个字符串，如果发现其中的一个字符存在字典中，说明它出现过，即为重复的字符，那么从该字符后重新计算，并记录出现的不重复子串的最大长度。 class Solution : def lengthOfLongestSubstring ( self , s ): dic = { chr ( i ) : - 1 for i in range ( 256 ) } length , res , j = len ( s ), 0 , 0 for i in range ( length ): if dic [ s [ i ]] >= j : j = dic [ s [ i ]] + 1 dic [ s [ i ]] = i if i - j + 1 > res : res = i - j + 1 return res 最长回文子串 Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.** 分析 O(n&#94;2)时间复杂度， O(1)空间复杂度 从头开始遍历整个字符串。然后以每个字符串为中点向两边扩展，直到最长的Palindromic，记录中间出现的Palindromic的最大长度。需要注意的是Palindromic的长度可能为奇数也可能为偶数。 class Solution : # @return a string def longestPalindrome ( self , s ): length = len ( s ) def expand ( left , right ): while left >= 0 and right < length and s [ left ] == s [ right ]: left -= 1 right += 1 return right - left - 1 start , end = 0 , 0 for i in range ( length ): len1 = expand ( i , i ) len2 = expand ( i , i + 1 ) Len = max ( len1 , len2 ) if end - start < Len : start = i - ( Len - 1 ) / 2 end = i + Len / 2 return s [ start : end + 1 ] Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Here is an example: S = \"rabbbit\", T = \"rabbit\" Return 3. 分析 使用动态规划。 dp[i][j]表示匹配到S中的第i个字符与T中第j个字符相同时的 ···························Distinct Subsequences 的个数。那么若s[i-1] == t[j-1]时，t从j-1转移到j状态，或者原来就是j状态。无论如何，每次s都从 i-1状态移到i状态。 Python Code class Solution : # @param {string} s # @param {string} t # @return {integer} def numDistinct ( self , s , t ): m = len ( s ) + 1 n = len ( t ) + 1 dp = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): dp [ i ][ 0 ] = 1 # T is null for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ i ][ j ] = dp [ i - 1 ][ j ] if s [ i - 1 ] == t [ j - 1 ]: dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] return dp [ m - 1 ][ n - 1 ]","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/string-related/","title":"字符串相关"},{"text":"流量控制（Flow control） End-to-End,防止发送方速率过大，接收方来不及处理发送方的数据。- - 拥塞控制（Congestion control） 到达子网中某一部分的分组数量过多，中间路由缓存分组，queueing，造成RTT增加。反应网络整体状况 滑动窗口（Sliding Window） 位于发送方，由接收方的通告窗口（Advertised-Window）决定。接收方通过通告窗口告诉发送方自己还有多少buffer可以接收数据。 通告窗口（Advertised-Window） 接收方使用流量控制的方式 拥塞窗口（Congestion Window） 拥塞窗口的大小指能够发出，但还没有收ACK的最大数据报文段。Linux 3.0 把CWND初始化10个MSS。发送方使用流量控制的方式。发送方取拥塞窗口与通告窗口中的最小值作为发送上限 慢启动（Slow Start） 每个ACK，CWND增加一个报文段（CWND以字节为单位，一报文段为单位进行线性增加） 报文段（Segment） 传输层分组称为报文段，是TCP MSS（Maximum Segment Size ） vs MTU(Maximum Transmission Unit) 在以太网中，MSS最大值为1460（20字节的IP header和20字节的TCP header），MTU的值为1500字节。MSS用于控制发送数据的长度，避免以较小MTU连接到网络上的主机产生分组 往返时延(Round-Trip Time ) 表示从发送端发送数据开始，到发送端收到来自接收端的ACK，总共经历的时延，由传播时延，传输时延，排队时延（Queuing Delay），节点处理时延决定（Node processing Dela y）。可以反应网络的拥塞状况 传输时延（Transmission Delay），传播时延（Transmission Delay） 传输时延=L/R，L，表示分组长度，R，表示链路传输速率(带宽)。传播时延=d/s，d，表示两段的实际物力距离，s一般等于小于光速","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/15/the-parameters-in-tcp-congestion-control/","title":"TCP Congestion Control 中的相关参数"}]}