{"pages":[{"text":"Please contact me via Email cjhou1984@gmail.com or the links in the blog. Thanks! class Solution : # @param {string} s # @return {string} def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix","tags":"pages","loc":"www.houcj.net/pages/About.html","title":"About"},{"text":"Objects are data with methods attached, closures are functions with data attached. 闭包就是一个函数可以引用限定范围内的另一个函数中的变量。 def make_counter ( x ): constant = x def counter ( y ): # counter() is a closure return y + constant return counter c1 = make_counter ( 12 ) c2 = make_counter ( 4 ) print ( c1 ( 3 ), c1 ( 4 ), c2 ( 3 ), c2 ( 4 )) Python 闭包最重要的限制是你无法对outer-scoper赋值，就是说闭包是只读的 def outer ( x ): def inner_reads (): # Will return outer's 'x'. return x def inner_writes ( y ): # Will assign to a local 'x', not the outer 'x' x = y def inner_error ( y ): # Will produce an error: 'x' is local because of the assignment, # but we use it before it is assigned to. tmp = x x = y return tmp return inner_reads , inner_writes , inner_error 如果想这段代码正常运行，需要使用一个可变的容器类型 def outer ( x ): x = [ x ] def inner_reads (): # Will return outer's x's first (and only) element. return x [ 0 ] def inner_writes ( y ): # Will look up outer's x, then mutate it. x [ 0 ] = y def inner_error ( y ): # Will now work, because 'x' is not assigned to, just referenced. tmp = x [ 0 ] x [ 0 ] = y return tmp return inner_reads , inner_writes , inner_error","tags":"编程","loc":"www.houcj.net/blog/2015/06/22/python-closure/","title":"Python 闭包"},{"text":"构造过程抽象 在程序设计中，需要处理两类要素：数据和过程。数据是一种我们希望去操作的东西， 过程就是有关操作这些数据的规则的描述。 复合过程 数和算术运算是基本的数据和过程 组合式的嵌套提供了一种组织起多个操作的方法 定义是一种受限的抽象手段，它为名字关联相应的值。 用高阶函数做抽象 一般而言程序设计语言总会对计算元素的可能使用方式强加上某些限制。带有 最少限制的元素被称为第一级的状态。第一级元素的权利包括： - 可以用变量命名 - 可以提供给过程参数 - 可以由过程作为结果返回 - 可以包含在数据结构中 Lisp把过程作为第一级状态，带来强大的表达功能。可以使用过程构造参数， 用lambda构造过程，同时过程也可以作为一般性的方法或者返回值。 构造数据抽象 定义过程的能力使我们有可能在更高的概念层次上处理计算机工作一样，能够构造 符合数据的能力，也将使我们得以在比语言提供的基本数据对象更高的概念 层次上，处理与数据有关的各种问题。 将程序中处理数据对象的表示部分，与处理对象的使用的部分相互隔离的技术形成了 一种称为数据抽象的强有力的设计方法学. 在处理符合数据中的一个关键性思想是闭包的概念---也就是说，用于组合 数据对象的黏合剂不但能用于组合基本的数据对象，同样也可以用于复合的数据对象。 另一关键思想是，复合数据对象能够称为以混合与匹配的方式组合程序模块的方便界面。 数据抽象的基本思想，就是设法构造出一些使用符合数据对象的程序，使它们就像在抽象数据 上操作一样。 map是一种很重要的结构，不仅因为它代表了一种公共模式，而且因为它建立起了 一种处理表的高层抽象。通过map强调的是从元 素表到另一个结果表的缩放变换。从作用上看，map 帮我们建立起了一层抽象屏障，将实现表变换的过程实现与如何提取表中元素以及 组合结果的细节隔离开。 模块化、对象和状态 对于系统结构的两种非常不同的世界观。第一种策略将注意力集中在对象上，将一个大型系统看成一批对象， 它们的行为可能随着时间的进展而不断变化。另一种组织策略将注意力集中在流过系统的 信息流上。 只要我们不使用赋值，以同样的参数对同一过程的两次求值一定产生同样的结果，因此就可以认为 过程是在计算数学函数。不用任何赋值的程序设计称为函数式程序设计。 一个环境就是框架的一个序列，每个框架里包含着一些约束的表格，这些约束将一些变量名字 关联于对应的值。每个框架还包含着一个指针，指向这一框架的外围环境。如果由于当前讨论的目的， 将相应的框架看作是全局的，那么它将没有外围环境。一个变量相对于某个特定环境的值，也就是在 这一环境中，包含着该变量的第一个框架里这个变量的约束值。如果在序列中并不存在 这一变量的约束，那么我们就说这个变量在该特定环境中是无约束的。 过程应用的环境模型 - 将一个过程对象应用于实际参数，将构造出一个新框架，其中将过程的形式参数约束到调用时的 的实际参数，而后在构造起的这一新环境的上下文中求值过程体。这个新框架的外围环境 就是作为被应用的那个过程对象的一部分的环境 - 相对于一个给定环境求值一个lambda表达式，将创建起一个过程对象，这个过程对象是一个 序对，由该lambda表达式的正文和一个指向环境的指针组成。这一指针指向的就是创建这个过程对象 时的环境。 以局部过程定义作为程序模块化的有用技术中的两个关键性质： - 局部过程的名字不会与包含它们的过程之外的名字互相干扰，这是因为这些局部过程名都是 在该过程运行时创建的框架里面的约束的，而不是在全局环境里约束的。 - 局部过程只需要将包含着它们的过程的形参作为自由变量，就可以访问该过程的实际参数。这时 是因为对于局部过程体的求值所在的环境是外围过程求值所在环境的下属。 我们可以将世界模拟为一个相互分离的、受时间约束的，具有状态的相互交流的对象，或者 可以将它模拟为单一的、无时间也无状态的统一体。 附录： Scheme Scheme语法极其简洁，支持S（symbol）表达式，可以减少词法解析的时间。Scheme程序中充满了 一对对嵌套的小括号，这些嵌套的符号体现了最基本的数学思想----递归。下面的表格是Scheme语法的基本 结构. Procedures Data Primitive elements +,-,*,/,<,=,> 数字，字符，字符串，布尔值，列表，函数 Means of combination ()composition,COND,IF Means of abstraction Define List 命令 操作 car 取表的第一个元素 cdr 表在取car后的其余部分，对于正常表，其结果是一个表，对非正常表，结果可能是一个元素 cons 构造表，如果第二个参数是表，则将第一个参数作为整体放在第二个参数的表中 List 构造表，将各个参数做为整体放在一个表中 ( define ( appnd list1 list2 ) ( if ( null? list1 ) list2 ( cons ( car list1 ) ( appnd ( cdr list1 ) list2 )))) ( define one-two ( list 1 2 3 4 )) ( define odds ( list 1 3 5 7 )) ( appnd odds one-two ) ;return (1 3 5 7 1 2 3 4) 表达式 Scheme C (+ 2 3 4) (2 + 3 + 4) (< low x high) ((low < x) && (x < high)) (f x y) f(x, y) (define (sq x) (* x x)) int sq(int) #t true #\\c 'c' \"abc\" \"abc\" 语法糖 语法糖形式 解释器中形式 (define (sq x) (* x x)) (define sq (lambda (x) (* x x))) '(+ 2 3) (quote (+ 2 3)) if 表达式 cond 表达式 let 表达式和赋值 语法：(let ((var1 val1)...) exp1 exp2...) 说明：let表达式的赋值只在表达式内部有效 ( let (( f + )) ( f 2 3 )) ; return 5 ( let (( f + ) ( x 2 )) ( f x 3 )) ; return 5 ( let (( f + ) ( x 2 ) ( y 3 )) ( f x y )) ; return 5 用define 和 set! 赋值 语法：(define var exp), (set! var exp) 说明：define和 set! 表达式的赋值在全局有效。define 和 set! 的区别是define既能赋值又能定义变量，而set!只能对已经定义的变量赋值 ( define a 1 ) a ; return 1 ( set! a 2 ) a ; return 2 ( let (( a 3 )) a ) ; return 3 a ; return 2 ( let (( a 3 )) ( set! a 4 ) a ) ; return 4 a ; return 2 ( let (( a 3 )) ( define a 5 ) a ) ; return 5 a ; return 2 ( set! b 1 ) ; 错误，b尚未定义 lambda 语法：(lambda (var ...) exp1 exp2 ...) 说明：lambda 表达式用于定义函数。var ... 是参数，exp1 exp2 ...是函数的执行 部分。通常需要结合局部定义 let 或者全局定义表达式 define，再进行函数调用。 (( lambda ( x ) ( + x x )) ( * 3 4 )) ; return 24 if 表达式 语法：(if test consequent alternative) 说明：如果test表达式为真，返回 consequent，否则返回 alternative。 ( define ( abs n ) ( if ( < n 0 ) ( - 0 n ) n )) cond 表达式 语法：(cond (test exp) ... (else exp)) 说明：多路分支判断表达式，类似于C语言的 \"if ... else if ... else\"。 ( define abs ( lambda ( n ) ( cond (( = n 0 ) 0 ) (( < n 0 ) ( - 0 n )) ( else n )))) map 表达式 语法：(map procedure list1 list2 ...) 说明：列表 list1 list2 ... 必须具有同样的长度；过程 procedure 接受的参数个数同列表的个数，各个列表中对应的变量分别作为过程 procedure 的参数被执行， 将每次的运算结果以列表形式返回。 ( map ( lambda ( x y ) ( + x ( * 2 y ))) ( list 1 2 3 ) ( list 4 5 6 ) ) ; return (9 12 15) PS: 过程和定义 () 在Scheme中表示一个过程 ( define A ( * 2 3 )) ( define ( D ) ( * 2 4 )) 粗浅理解，带括号的表示一个过程，相当于C语言中的函数， 不带参数是一个符号表示， 相当于C语言中的宏。 注释 使用分号进行注释 ;(list 1 2 3) Python 闭包 Objects are data with methods attached, closures are functions with data attached. 闭包就是一个函数可以引用限定范围内的另一个函数中的变量。 def make_counter ( x ): constant = x def counter ( y ): # counter() is a closure return y + constant return counter c1 = make_counter ( 12 ) c2 = make_counter ( 4 ) print ( c1 ( 3 ), c1 ( 4 ), c2 ( 3 ), c2 ( 4 )) Python 闭包最重要的限制是你无法对outer-scoper赋值，就是说闭包是只读的 def outer ( x ): def inner_reads (): # Will return outer's 'x'. return x def inner_writes ( y ): # Will assign to a local 'x', not the outer 'x' x = y def inner_error ( y ): # Will produce an error: 'x' is local because of the assignment, # but we use it before it is assigned to. tmp = x x = y return tmp return inner_reads , inner_writes , inner_error 如果想这段代码正常运行，需要使用一个可变的容器类型 def outer ( x ): x = [ x ] def inner_reads (): # Will return outer's x's first (and only) element. return x [ 0 ] def inner_writes ( y ): # Will look up outer's x, then mutate it. x [ 0 ] = y def inner_error ( y ): # Will now work, because 'x' is not assigned to, just referenced. tmp = x [ 0 ] x [ 0 ] = y return tmp return inner_reads , inner_writes , inner_error","tags":"计算机科学","loc":"www.houcj.net/blog/2015/06/19/sicp/","title":"SICP"},{"text":"进程、线程、协程 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。基本上相当与用户空间下进行线程调度。 静态内存、栈内存、堆内存 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动 创建和销毁。对于栈对象仅在其定义的程序块运行时才存在，static对象在使用之前分配，在程序 结束时销毁。 程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制。 Const 顶层const表示指针本身是个常量 底层const表示指针所指的对象是个常量 尽量使用常量引用 ，使用引用可以避免拷贝，使用const则避免修改实参的值。 string::size_type & size_t size_t size_t是sizeof操作符的结果返回类型，它在头文件中的typedef为 unsigned int 类型。该类型保证实现所建立的最大对象的字节大小。 string::size_type string::size_type是一个无符号类型的值，而且能够存放下任何string对象的大小。所有 用于存放string类的size函数返回值的变量，都应该是string::size_type 类型的。 命名的强制类型转换 一个命名的强制类型转换具有如下形式： cast-name (expression); 其中，type是转换的目标类型，而expression是要转换的值。如果type是引用类型，则结果是左值。 cast-name 是static_cast、dynamic_cast、const_cast和reinterpret_cast的一种。 const char * pc ; char * p = const_cast < char *> ( pc ); //正确但是通过p写值是未定义的行为 实参入栈顺序 int b = 0 ; cout << b << b ++ << endl ; // 输出10，b++先使用b然后再加加 cout << ++ b << b ++<<++ b << endl ; // 输出5351 在处理printf或者cout时，压栈顺序为从右向左，对于a++的结果，是有ebp寻址函数栈 空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于 ++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。 尾置迭代器 迭代器的end成员负责返回指向容器尾元素的下一位置的迭代器，该迭代器表示容器的不存在的尾后 元素，作为处理完容器所有元素的标记。 int arr [] = { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 }; int * e = & arr [ 10 ]; // 指向arr尾元素的下一个位置的指针，相当于哨兵的作用。 使用尾置返回类型 任何函数的定义都可以使用尾置（trailing return type）返回，尾置返回类型跟在 形参列表后面并以一个->符号开头，同时为了表示函数真正的返回类型跟在形参列表之后， 可以在返回类型出现的地方放置一个auto： auto func ( int i ) -> int ( * )[ 10 ]; func返回一个函数指针，该指针指向一个含有10个整数的数组。 std :: string :: size_type pos ; // why string::size_type The std::string type defines size_type to be the name of the appropriate type for holding the number of characters in a string. Whenever we need a local variable to contain the size of a string, we should use std::string::size_type as the type of that variable. The reason that we have given cols a type of std::string::size_type is to ensure that cols is capable of containing the number of characters in greeting, no matter how large that number might be. We could simply have said that cols has type int, and indeed, doing so would probably work. However, the value of cols depends on the size of the input to our program, and we have no control over how long that input might be. It is conceivable that someone might give our program a string so long that an int is insufficient to contain its length. 列表初始化 下面四条语句都可以： int i = 0 ; int i = { 0 }; int i ( 0 ); int i { 0 }; void * 是一种特殊的指针类型，可以用于存放任意对象的地址。 const 和 constexpr 如果想在多个文件之间共享const对象，必须在变量的定义之前加extern关键字 常量表达式是指值不会在改变并且在编译过程就能得到计算结果的表达式。 const int max_files = 20 ; //是常量表达式 const int sz = get_size (); //不是常量表达式，具体值在运行时才能得到 C++11 规定允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量 表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化 const int * p = nullptr ; // p是一个指向整型常量的指针 constexpr int * q = nullptr ; // q是一个指向整数的常量指针。 类型别名 两种实现方式 - typedef - using using SI = Sales_item ; // SI是Sales_item的别名 C++11引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型 C++11引入decltype类型说明符，它的作用是选择并返回操作数的数据类型。 字面值类型： 常量表达式的值需要在编译使就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般都比较 简单，值也容易得到。就把它们称为\"字面值类型(literal type)\" 一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。 类模版 编译器根据模版创建类或函数的过程称为实例化，当使用模版时，需要指出编译器应把类或函数实例化成何种 类型。 内联函数和constexpr函数 将函数指定为内联函数，通常就是将它在每个调用节点上内联地展开。 constexpr函数是指用于常量表达式的函数，同时要求函数的返回类型及所有形参的类型 都是字面值类型，而且函数体中必须有且只有一条return语句。 constexpr int new_sz () { return 42 ;} constexpr int foo = new_sz (); // foo是一个常量表达式 对于某个给定的内联或者constexpr函数来说，它的多个定义必须完全一致，因此内联函数和 constexpr函数通常定义在头文件中。 class 和struct关键字 使用class和struct定义类唯一的区别就是默认的访问权限。使用struct关键字，定义在第一个访问说明 符之前的成员是public的，如果我们使用class关键字，则这些成员是private的。 函数指针 函数指针指向的是函数而非对象，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。 const 在成员函数后面加const表示，这个函数是只读函数，不会改变类的数据成员。 class Point { int xVal , yVal ; public : int GetY () const ; }; //关键字const必须用同样的方式重复出现在函数实现里，否则编译会把它们看成不同的函数 int Point :: GetY () const { return yVal ; } 如果把const放在函数声明前就意味着函数的返回值是常量。同时在const成员函数中，用mutable修饰 成员变量名后，就可以修改类的成员变量。 在C中const是外部链接，它总是占用内存，而且它的名字是全局符， C编译器不能把const看成一个编译器期间的常量，而在C++默认const是内部连接的，它 在编译期间就会确定值。 类 类是C++语言中最基本的特性，它允许我们为自己的应用定义新类型，从而使得程序更加简洁。类有 两项基本功能：一是数据抽象，即定义数据成员和函数成员的能力。二是封装，即保护类的成员不被随意 访问的能力。 构造函数 构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。 构造函数不能被声明成const的，当我们创建类的const对象时，直到构造函数完成初始化过程，对象才能 真正取得其常量属性，因此，构造函数在const对象的构造过程中可以向其写值。 默认构造函数 如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数， 默认构造函数无需任何实参。 如果类包含有内置类型或者复合类型的成员，则只有当这些成员都被赋予了类内的初始值时， 这个类才适合于使用合成的构造函数 类类型 struct First { int memi ; int geMem (); }; struct Second { int memi ; int getMem (); }; First obj ; Second obj2 = obj1 ; //错误，obj1和obj2类型不同 即使两个类的成员列表完全一致，它们也是不同的类型，对于一个类来说，它的成员 和其他任何类的成员都不是一回事。 友元 友元关系不存在传递性，每个类独立的负责自己的友元类或者友元函数。当第一个名字第一次 出现在一个友元声明中，我们隐式地假定该名字当前作用域是可见的，即使我们仅仅是用友元的类 的成员调用友元函数，它也必须是被显式的声明过。 成员初始化顺序 class test { public : test ( int val ) : j ( val ), i ( j ){} // i先初始化 private : int i ; int j ; }; 构造函数的初始化值的顺序和成员声明的顺序保持一致，同时尽量避免使用某些成员初始化其他成员。 静态成员 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键字则只 出现在类内部的声明语句中。 静态数据成员可以是不完全类型，非静态数据成员必须是完全类型才能使用。静态数据成员的类型可以是 它所属的类类型，而非静态数据成员则只能声明成它所属类的指针。 谓词 谓词是一个可调用的表达式，其返回结果是一个能用做条件的值。标准库使用两种谓词：一元 谓词（只接受单一参数）和二元谓词（它们有两个参数）。 使用emplace操作 当调用push或insert成员函数时，我们将元素类型的对象传递给它们， 这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数 传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接 构造元素。 适配器（adaptor） 容器、迭代器、和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为 看起来想另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其看起来像一种 不同的类型。 动态内存 程序使用动态内存出于以下三种原因： 1. 程序不知道自己需要使用多少对象 2. 程序不知道所需对象的准确类型 3. 程序需要多个对象间共享数据。 new & delete 在自由空间分配的内存是无名的，因此 new 无法为其分配的对象命名，而是返回一个指向该对象 的指针： int * pi = new int （ 1024 ） ; //pi 指向的对象的值为1024 vector * pv = new vector < int > { 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } // 列表初始化 我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者 将相同的指针值释放多次，其行为都是未定义的。 const int * pci = new const int ( 1024 ); delete pci ; 当我们delete一个指针后，指针值就变为无效了，但在很多机器上指针仍保存着已经释放的动态内存的地址，这时候 指针就会变成悬空指针，即，指向一块曾经保存数据对象但现在已经无效（delete）的的内存的指针。解放方法是：在指针 即将离开其作用域之前释放掉它所 关联 的内存。如果需要保存指针可以在delete之后将nullptr赋予指针。 shared_ptr 智能指针也是模块，我们创建一个智能指针时，必须提供指针可以指向的类型。 shared_ptr < Foo > factory ( T arg ) { // shared_ptr 负责释放内存 return make_shared < Foo > ( arg ); } void use_factory ( T arg ) { shared_ptr < Foo > p = factory ( arg ); // 使用p，p离开作用域，它指向的内存会被自动释放掉 } 智能指针与动态数组 // 为了使用shared_ptr必须提供一个删除器 shared_ptr < int > sp ( new int [ 10 ],[]( int * p ) { delete [] p ;}); // shared_ptr未定义下标运算符，并且不支持指针的算术运算 for ( size_t i = 0 ; i != 10 ; ++ i ) { * ( sp . get () + i ) = i ; // 使用get获取一个内置指针 } sp . reset () //使用lambda释放数组，它使用delete[] unique_ptr & weak_ptr unique_ptr拥有它所指指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向 一个给定的对象。当unique_ptr对象被销毁时，它所指向的对象也被销毁。 weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。 通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时的开销。通过 在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。 释放动态数组 typedef int arrT [ 42 ]; // arrT 是一个42个int的数组的类型别名 int * p = new arrT ; // 分配一个42个int的数组，p指向第一个元素 delete [] p ; // 方括号是必须的，因为被分配的是一个数组 析构函数 在一个析构函数中，首先执行函数体（析构函数体被不直接销毁成员），然后销毁成员，成员按初始化顺序的逆序销毁。通常析构函数释放 对象在生存期分配的所有资源。隐式销毁一个内置指针类型的成员不会delete它所指向的对象。与普通指针不同 ，智能指针是类类型，所以有析构函数，智能指针成员在析构阶段会被自动销毁。 自动调用析构函数的情况 - 变量在离开其作用域时被销毁 - 当一个对象被销毁时，其成员被销毁 - 容器被销毁时，其元素被销毁 - 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁 - 对于临时对象，当创建它的完整表达式结束时被销毁 删除的函数 我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。 struct NoCopy { NoCopy () = default ; // 使用合成的默认构造函数 NoCopy ( const NoCopy & ) = delete ; // 阻止拷贝 NoCopy & operator = ( const NoCopy & ) = delete ; // 阻止拷贝 ~ NoCopy () = default ; //使用合成析构函数 ｝ 如果有一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应 的成员函数将被定义为删除的。 引用计数 引用计数的工作方式如下： - 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少 对象与正在创建的对象共享状态。当创建一个对象时，计数器初始化为1 - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享 的计数器，指出给定对象的状态又被一个新用户所共享。 - 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构 函数释放状态。 - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器 变为0，拷贝赋值运算符就必须销毁状态。 拷贝和交换 ### HasPtr & HasPtr :: operator = ( HasPtr rhs ) { // rhs 是按值传递的， // 交换左侧运算对象和局部变量rhs的内容 swap ( * this , rhs ); // rhs指向本对象曾经使用的内存 return * this ; // rhs被销毁，从而delete了rhs中的指针 } 右值引用 右值引用就是必须绑定到右值的引用，右值引用有一个重要的性质--只能 绑定到一个将要销毁的对象。 一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是 对象的值。 int i = 42 ; int && rr = i ; // 错误：不能将一个右值引用绑定到一个左值上 int & r2 = i * 42 ; // 错误：i*42是个右值 int && rr2 = i * 42 ; // 正确：将rr2绑定到结果上 移动&拷贝 如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过 拷贝构造函数来移动的，拷贝赋值运算符和移动赋值运算符的情况类似。 三/五原则 三个基本的控制类的拷贝操作：拷贝构造函数，拷贝赋值函数，析构函数； 还有两个不新标准下的：移动构造函数，移动赋值函数。这所有五个拷贝控制成员应该看作一个整体； 一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。 引用限定符 引用限定符可以是&或&&，分别指出this可以指一个左值或者右值。类似const限定符，引用限定符 只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。 面向对象程序设计 面向对象程序设计 的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的 接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定 程度上忽略相似类型的区别，而以同意的方式使用它们的对象。 防止继承的发生 如果一个类不想被其他类继承，或者不想考虑它是否适合作为一个基类，C++11新标准提供了一种 防止继承发生的方法，即在类名后跟一个关键字final： class NoDerived final {}; // NoDerived 不能作为基类被继承 纯虚函数 一个纯虚函数无需定义，我们通过在函数体的位置书写=0就可以将一个虚函数 说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处： class base : { public : double f ( int ) const = 0 ; //纯虚函数 }; 尾置返回类型与类型转换 template < typename It > auto fcn ( It beg , It end ) -> decltype ( * beg ) { return * beg ; } 转发 模版转发 template < typename F , typename T1 , typename T2 > void flip ( F f , T1 && t1 , T2 && t2 ) { f ( std :: forward < T2 > ( t2 ), std :: forward < T1 > ( t1 )); } 可变参数模版转发 template < typename ... Args > void fun ( Args && .. args ) { work ( std :: forward < Args > ( args )...); } 命名空间 命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现 文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义 类及函数的方式： 命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象， 则这写成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。 命名空间的成员的定义部分则置于另外的源文件中。 虚继承 虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的 基类子对象称为虚基类（virtual base class）。在这种机制下，不论虚基类 在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类 子对象。 运行时类型识别 运行时类型识别（run-time type identification）的功能由两个运算符实现： - typeid运算符，用于返回表达式的类型 - dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用 在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。","tags":"编程","loc":"www.houcj.net/blog/2015/06/13/cpp/","title":"The Basic Knowledge in CPP"},{"text":"排序算法 归并排序 归并排序是分治模式的典型代表. 所谓的分治模式就是将原问题分解为几个 规模较小但类似于原问题的子问题, 递归地求解这些子问题,然后再合并这些子问题的 解来建立原问题的解. Sort List Sort a linked list in O(n log n) time using constant space complexity. 分析 链表的查找需要遍历整个链表,因为应该使用尽可能少的查找操作.这里使用归并排序的算法. 首先找到链表的中点,把链表递归的分成左右两部分,然后对左右两部分进行归并操作. Python Code class Solution : # @param head, a ListNode # @return a ListNode def sortList ( self , head ): if not head or not head . next : return head slow = head fast = head while fast . next and fast . next . next : slow = slow . next fast = fast . next . next head1 = head head2 = slow . next slow . next = None return self . merge ( self . sortList ( head1 ), self . sortList ( head2 )) def merge ( self , head1 , head2 ): if head1 is None : return head2 if head2 is None : return head2 dummy = ListNode ( - 1 ) pre = dummy while head1 and head2 : if head1 . val < head2 . val : pre . next = head1 head1 = head1 . next else : pre . next = head2 head2 = head2 . next pre = pre . next if head1 is None : pre . next = head2 if head2 is None : pre . next = head1 return dummy . next 同时归并排序有很好的并行性 def mergesort '(A, lo, hi): if lo + 1 < hi : # two or more elements mid = ( lo + hi ) / 2 fork mergesort '(A, lo, mid) mergesort '(A, mid, hi) join merge ( A , lo , mid , hi ) 快速排序 快速排序也是使用了分治的思想. 下面是对一个典型的子数组A[lo..hi]的三步分治过程: 分解: 数组A[lo..hi]被划分为左右两个子数组A[lo..q-1], A[q+1..hi],使得左边数组的每个 元素都小于等于A[q],而右边数组的每个元素都大于等于A[q].其中,计算下标q也是划分过程的一部分. 解决: 通过递归调用快速排序,对左右两个子数组进行排序 合并 因为子数组都是原地排序的,所以不需要合并操作:数组A[lo..hi]已经有序. Largest Number Given a list of non negative integers, arrange them such that they form the largest number. For example, given [3, 30, 34, 5, 9], the largest formed number is 9534330. Note: The result may be very large, so you need to return a string instead of an integer. 分析 将这两个数字，作为一个整体，进行比较。然后一次排序, 就可以得到结果.这里使用快速排序. 给定例子：3,30,34 比较3和30，实际上就是比较330和303哪个大 比较3和34，实际上就是比较334和343哪个大 比较30和34，实际上就是比较3034和3430哪个大 那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。 Python Code class Solution : # @param num, a list of integers # @return a string def largestNumber ( self , num ): def quickSort ( num , low , high ): def partition ( num , low , high ): x = num [ high ] i = low - 1 for j in range ( low , high ): if str ( num [ j ]) + str ( x ) > str ( x ) + str ( num [ j ]): i += 1 num [ i ], num [ j ] = num [ j ], num [ i ] num [ i + 1 ], num [ high ] = num [ high ], num [ i + 1 ] return i + 1 if low < high : q = partition ( num , low , high ) quickSort ( num , low , q - 1 ) quickSort ( num , q + 1 , high ) quickSort ( num , 0 , len ( num ) - 1 ) st = '' . join ( str ( element ) for element in num ) if st [ 0 ] == '0' : return '0' return st 堆排序 Merge k Sorted Lists Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 分析 可以使用大小为k的小顶堆,小顶堆初始化为各个链表中的首元素(最小值).当从小顶堆 中取出一个元素的时候,就把这个元素所在链表对应的下一个元素加入到 小顶堆中,知道堆为空. Python Code heap = [] dummy = ListNode ( - 1 ) for node in lists : if node : heap . append (( node . val , node )) heapq . heapify ( heap ) head = dummy while heap : tmp = heapq . heappop ( heap ) head . next = ListNode ( tmp [ 0 ]) head = head . next if tmp [ 1 ] . next : heapq . heappush ( heap ,( tmp [ 1 ] . next . val , tmp [ 1 ] . next )) return dummy . next 上面介绍的是基于比较的排序算法。 可以证明基于比较排序算法的下限为O(NlogN)的。 简单证明如下： N个数有N!个可能的排列情况，也就是说基于比较的排序算法的判定树有N!个叶子结点，比较次数至少为log(N!)=O(NlogN)(斯特林公式)。 下面介绍的非基于比较的线性排序，如计数排序，桶排序，和在此基础上的基数排序，则可以突破O(NlogN)时间下限。 但要注意的是，非基于比较的排序算法的使用都是有条件限制的，例如元素的大小限制，相反，基于比较的排序则没有这种限制(在一定范围内) 基数排序 基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。 实现方法： 将所有待比较数值（正整数）统一为同样的数位长度， 数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。 这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 Maximum Gap 分析 使用基数排序，由于是整数因此以2为底的基数排序即可。每次提取整数的第i位放到0 后者1的桶中。 Python Code class Solution : # @param num, a list of integer # @return an integer def maximumGap ( self , num ): length = len ( num ) if length < 2 : return 0 num = self . radixSort1 ( num ) res = 0 for i in range ( 1 , length ): if res < num [ i ] - num [ i - 1 ]: res = num [ i ] - num [ i - 1 ] return res def radixSort1 ( self , num ): for i in range ( 31 ): bucket = [[] for j in range ( 2 )] for val in num : if ( val >> i ) & 1 : bucket [ 1 ] . append ( val ) else : bucket [ 0 ] . append ( val ) num = [ val for lst in bucket for val in lst ] return num 桶排序 桶排序假设输入数据服从均匀分布，平均时间复杂度为O（n）。桶排序将区间划分为n个大小的子区间， 称为桶。然后先讲桶中的数进行排序，然后遍历每个桶，按照次序依次把各个桶中的元素列出来即可。 def BUCKET_SORT ( A ): n = len ( A ) B = [[ - 1 ] for i in range ( n )] for i in range ( n ): B [ A [ i ] / 10 ] . append ( A [ i ]) for i in range ( n ): B [ i ] . sort () res = [] for i in range ( n ): if len ( B [ i ]) != 1 : for val in B [ i ]: if val != - 1 : res . append ( val ) return res 计数排序 计数排序假设n个输入元素中的每一个都是o到k区间的一个整数,其中k为某个整数.当k=O(n)时 运行时间为O(n). 计数排序的基本思想是:对每一个输入元素x,确定小于x的元素的个数.利用这一信息,就可以直接把x 放到它在输出数组中的位置上了. 计数排序是稳定的 def counting_sort ( A , k ): B , C = [ 0 ] * len ( A ), [ 0 ] * ( k + 1 ) # 包括0和k，长度k+1 for a in A : C [ a ] += 1 for i in range ( 1 , k + 1 ): # 1 to k C [ i ] += C [ i - 1 ] for j in reversed ( range ( len ( A ) - 1 )): # 这里要注意索引从0开始的，所以要-1 B [ C [ A [ j ]] - 1 ] = A [ j ] C [ A [ j ]] -= 1 return B","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/31/sort1/","title":"排序算法"},{"text":"Straight-forward problems that don't require any special technique (e.g. simulation, searching, sorting etc.) In most cases, these problems will ask you to perform some step by step, straight-forward tasks. Their constraints are not high, and not too low. In most cases the first problems (the easiest ones) in topcoder Single Rounds Matches are of this kind. They test mostly how fast and properly you code, and not necessarily your algorithmic skills. Breadth First Search (BFS) Problems that use BFS usually ask to find the fewest number of steps (or the shortest path) needed to reach a certain end point (state) from the starting one. Besides this, certain ways of passing from one point to another are offered, all of them having the same cost of 1 (sometimes it may be equal to another number). Often there is given a N x M table (formed of N lines and M columns) where certain cells are passable and others are impassable, and the target of the problem is to find the shortest time/path needed to reach the end point from the start one. Such tables may represent mazes, maps, cities, and other similar things. These may be considered as classical BFS problems. Because BFS complexity is in most cases linear (sometimes quadratic, or N logN), constraints of N (or M) could be high – even up to 1 million. Flood Fill Sometimes you may encounter problems that are solved by the help of Flood Fill, a technique that uses BFS to find all reachable points. The thing that makes them different from BFS problems described above is that a minimum path/cost is not needed. For example, imagine a maze where 1 represents impassable cells and 0 passable cells. You need to find all cells that are reachable from the upper-left corner. The solution is very simple – take one-by-one a visited vertex, add its unvisited neighbors to the queue of visited vertices and proceed with the next one while the queue is still populated. Note that in most cases a DFS (Depth First Search) will not work for such problems due to stack overflows. Better use a BFS. For inexperienced users it may seem harder to implement, but after a little training it becomes a \"piece of cake\". Brute Force and Backtracking I have placed these 2 techniques in the same category because they are very similar. Both do the same thing – try all possible cases (situations) and choose the best one, or count only those that are needed (depending on the problem). Practically, Backtracking is just more advanced and optimized than Brute Force. It usually uses recursion and is applied to problems having low constraints (for example N<=20). Brute Force There are many problems that can be solved by the help of a simple brute force. Note that the limits must not be high. How does a brute force algorithm work? Actually, it tries all possible situations and selects the best one. It's simple to construct and usually simple to implement. If there is a problem that asks to enumerate or find all possible ways (situations) of doing a certain thing, and that doesn't have high limits – then it's most probably a brute force problem. Backtracking This technique may be used in many types of problems. Just take a look at the limits (N, M and other main parameters). They serve as the main hint of a backtrack problem. If these are very small and you haven't found a solution that's easier to implement – then just don't waste your time on searching it and implement a straight-forward backtracking solution. Dynamic Programming Quite a few problems are solved with the help of this technique. Knowing how to detect this type of problem can be very valuable. However in order to do so, one has to have some experience in dynamic programming. Usually a DP problem has some main integer variables (e.g. N) which are neither too small, nor too big – so that a usual DP complexity of N&#94;2, N&#94;3 etc. fits in time. Note that in the event that N is very small (for TC problems usually less than 30) – then it is likely the problem is not a DP one. Besides that there should exist states and one or more ways (rules) to reach one greater state from another lower one. In addition, greater states should depend only upon lower states. What is a so-called state? It's just a certain configuration or situation. PS:有超链接符号的都是已经写过的文章，xmind导出到pdf会丢失超链接信息","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/28/find-a-solution/","title":"How to find a solution"},{"text":"查找算法 顺序查找 条件： 无序或有序数组 原理： 按顺比较每个元素，直到知道关键字为止。 时间复杂度： O(n) Insert Interval Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. Example 1: Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9]. Example 2: Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16]. This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10]. 分析 intervals中的值已经排序,因此如果没有 可以直接append到result中.首先根据newInterval.start的值, 确定其在Intervals中的位置,然后再根据newInterval的start和end值进行 merge,如果最后的元素还有剩余就全部append到result中. Python Code class Solution : # @param {Interval[]} intervals # @param {Interval} newInterval # @return {Interval[]} def insert ( self , intervals , newInterval ): n = len ( intervals ) if n == 0 : return [ newInterval ] res = [] i = 0 while i < n and intervals [ i ] . end < newInterval . start : res . append ( intervals [ i ]) i += 1 start = newInterval . start end = newInterval . end while i < n and intervals [ i ] . start <= newInterval . end : start = min ( start , intervals [ i ] . start ) end = max ( end , intervals [ i ] . end ) i += 1 res . append ( Interval ( start , end )) while i < n : res . append ( intervals [ i ]) i += 1 return res First Missing Positive Given an unsorted integer array, find the first missing positive integer. For example, Given [1,2,0] return 3, and [3,4,-1,1] return 2. Your algorithm should run in O(n) time and uses constant space. 分析 这里只需要把正确的位置放上正确的元素即可。如把4放在A[3]的位置 Python Code class Solution : # @param A, a list of integers # @return an integer def firstMissingPositive ( self , A ): n = len ( A ) for i in range ( n ): while A [ i ] > 0 and A [ i ] <= n and A [ i ] != A [ A [ i ] - 1 ] : A [ A [ i ] - 1 ], A [ i ] = A [ i ], A [ A [ i ] - 1 ] for x in range ( n ): if A [ x ] != x + 1 : return x + 1 return n + 1 二分查找 条件： 有序数组 原理： 查找过程从数组的中间元素开始， 如果中间元素正好是要查找的元素，则搜素过程结束； 如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。 如果在某一步骤数组为空，则代表找不到。 每一次比较都使搜索范围缩小一半。 时间复杂度： O(lgn) Search in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). You are given a target value to search. If found in the array return its index, otherwise return -1. You may assume no duplicate exists in the array. 分析 虽然这个数组不是完全有序的，但是每次的左半部分或者右半部分都是 有序的，这样我们使用二分查找，每次都可以去掉一半的不符合条件的值。 同时注意边界条件。 Python Code class Solution : # @param A, a list of integers # @param target, an integer to be searched # @return an integer def search ( self , A , target ): if not A : return - 1 length = len ( A ) l = 0 r = length - 1 while l <= r : mid = ( l + r ) / 2 if A [ mid ] == target : return mid if A [ mid ] < A [ r ]: if A [ mid ] < target <= A [ r ]: l = mid + 1 else : r = mid - 1 else : if A [ l ] <= target < A [ mid ]: r = mid - 1 else : l = mid + 1 return - 1 下面是常见的二分查找的Algorithm puzzle exapmles： Given A a sorted array find out how many times does x occur in A. Given a real number x, find out its cubic root. Given A a sorted array with distinct numbers, find out an i such that A[i] == i. Given the +,-,*,/,sqrt operations and a real number x find an algorithm to get log_2_x. Given an array of distinct numbers A such that A[0] > A[1] and A[n-1] > A[n-2] find out a local minimum (find out an i such that A[i-1] > A[i] < A[i + 1]). Let A be a sorted array with distinct elements. A is rotated k positions to the right (k is unknown). Find out k. Let A be a sorted array with distinct elements. A is rotated k positions to the right (k is unknown). Find out if A contains a number x. Given two sorted arrays of length n and m, find out the kth element of their sorted union. Given A, an array comprised of an increasing sequence of numbers followed immediately by a decreasing one. Determine if a given number x is in the array. Given an array of N distinct int values in ascending order, determine whether a given integer is in the array. You may use only additions and subtractions and a constant amount of extra memory. Player A chooses a secret number n. Player B can guess a number x and A replies how does x compare to n (equal, larger, smaller). What's an efficient strategy for B to guess n. Hash表查找 条件： 先创建哈希表 原理： 根据key value进行查找，通过hash函数定位数据元素。 时间复杂度： 平均复杂度为O（1），取决于冲突的大小。 Two Sum Given an array of integers, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution. Input: numbers={2, 7, 11, 15}, target=9 Output: index1=1, index2=2 分析 可以使用字典存储该元素以及它所对应的下标，那么如果两个元素的和满足target。 就可以直接根据他们的值线性时间取出他们的下标，时间复杂度为 O(n)。 可能需要遍历表中的所有元素。 Python Code class Solution : # @return a tuple, (index1, index2) def twoSum ( self , num , target ): dic = {} length = len ( num ) for index in range ( length ): dic [ num [ index ]] = index + 1 for i in range ( length ): if dic . get ( target - num [ i ]): if i + 1 != dic [ target - num [ i ]]: return i + 1 , dic [ target - num [ i ]]","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/28/search/","title":"查找算法"},{"text":"动态规划本质是一种递推，使用空间存储中间的状态，动态规划的关键是 找到状态转移方程。复杂度是状态总数*某状态下的最大转移数。动态规划可以 自底向上或者自顶向下 Unique Binary Search Trees Given n, how many structurally unique BST's (binary search trees) that store values 1...n? For example, Given n = 3, there are a total of 5 unique BST's. 1 3 3 2 1 \\ / / / \\ \\ 3 2 1 1 3 2 / / \\ \\ 2 1 2 3 分析 定义状态: F[n]表示二叉树中有n个节点时unique BST的数目。 那么假设根节点为k时，这时unique BST的数目为以k为根节点的左子树数目*以k为节点的右子树数目。 那么F[n]的值就等于从1到n依次为根节点时的unique BST的数目之和。 \\begin{equation*} F[n]=\\sum_{i=1}&#94;{n}F[i]*F[n-i-1] \\end{equation*} 因此是个一维的动态规划。 Python Code class Solution : # @return an integer def numTrees ( self , n ): cunt = [ 0 for i in range ( n + 1 )] cunt [ 0 ] = 1 cunt [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( 0 , i ): cunt [ i ] += cunt [ j ] * cunt [ i - 1 - j ] return cunt [ n ] House Robber II Note: This is an extension of House Robber. After robbing those houses on that street, the thief has found himself a new place for his thievery so that he will not get too much attention. This time, all houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, the security system for these houses remain the same as for those in the previous street. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. 分析 首先先处理线性的情况。 由于只有相邻的house才会产生影响，与邻居的邻居是无关的。 dp[n]表示到第n个house是的最大收益。那么可以得到相应的 状态转移方程为： \\begin{equation*} dp[n] = max(dp[n-2]+num[n], dp[n-1]) \\end{equation*} 对于圆形的情况，当取第一个元素的时候，就不能取第n个元素。如果不取 第一个元素，剩下的元素就可以转化为线性的问题。比较这两种情况的最大值即可。 Python Code class Solution : # @param {integer[]} nums # @return {integer} def rob ( self , nums ): if len ( nums ) < 2 : return nums [ 0 ] if nums else 0 return max ( self . robber ( nums [: - 1 ]), self . robber ( nums [ 1 :])) def robber ( self , nums ): length = len ( nums ) if length < 2 : return nums [ 0 ] if nums else 0 dp = [ 0 for x in range ( length )] dp [ 0 ] = nums [ 0 ] dp [ 1 ] = max ( nums [ 0 ], nums [ 1 ]) for i in range ( 2 , length ): dp [ i ] = max ( dp [ i - 2 ] + nums [ i ], dp [ i - 1 ]) return dp [ length - 1 ] Edit Distance Given two words word1 and word2, find the minimum number of steps required to convert word1 to word2. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word: a) Insert a character b) Delete a character c) Replace a character 分析 我们采用自底向上的动态规划的解法，那么当前的状态可以由它的上一步的状态决定。 由于两个字符串，因此需要两维的数组来存储这些状态。 dp[i][j]表示word1的从最后一个字符到第i单词与word2从最后一个字符到第j个字符所需要的 最少的编辑距离。 \\begin{equation*} dp[i][j] = min(dp[i+1][j]+1, dp[i][j+1]+1, dp[i+1][j+1]+t[i][j]) \\end{equation*} \\begin{equation*} t[i][j] = \\begin{cases} 1, & \\mbox{word1}[i] == \\mbox{word2}[j] \\\\ 0, & \\mbox{word1}[i] != \\mbox{word2}[j] \\end{cases} \\end{equation*} Python Code class Solution : # @return an integer def minDistance ( self , word1 , word2 ): n = len ( word1 ) m = len ( word2 ) dp = [[ 0 for x in range ( m + 1 )] for y in range ( n + 1 )] for j in range ( m + 1 ): dp [ 0 ][ j ] = j for i in range ( n + 1 ): dp [ i ][ 0 ] = i for i in range ( n ): for j in range ( m ): tmp = 0 if word1 [ i ] == word2 [ j ] else 1 dp [ i + 1 ][ j + 1 ] = min ( dp [ i ][ j + 1 ] + 1 , dp [ i + 1 ][ j ] + 1 , dp [ i ][ j ] + tmp ) return dp [ n ][ m ] Maximal Square Given a 2D binary matrix filled with 0's and 1's, find the largest square containing all 1's and return its area. For example, given the following matrix: 1 0 1 0 0 1 0 1 1 1 1 1 1 1 1 1 0 0 1 0 Return 4. 分析 定义状态：dp[i][j]表示在第i行第j列时，最大的square size，我们知道 一个正方形的size，就可以很容易求它的面积。这里采用自定向下的动态规划。 当matrix里的元素为0时，dp[i][j]为0，因为这时候不能形成一个全为1的正方形。 当matrix里的元素为1时，很容易得到下面的递推方程。 \\begin{equation*} dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])+1 \\end{equation*} dp[i][j]在第一行，以及第一列时与matrix中的元素保持一致。 Python Code class Solution : # @param {character[][]} matrix # @return {integer} def maximalSquare ( self , matrix ): m = len ( matrix ) if not m : return 0 n = len ( matrix [ 0 ]) maxSize = 0 for j in range ( n ): if matrix [ 0 ][ j ] == '1' : maxSize = 1 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == '1' : matrix [ i ][ j ] = int ( min ( matrix [ i - 1 ][ j - 1 ], matrix [ i - 1 ][ j ], matrix [ i ][ j - 1 ])) + 1 if matrix [ i ][ j ] > maxSize : maxSize = matrix [ i ][ j ] return maxSize * maxSize if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2015/05/27/dong-tai-gui-hua/","title":"动态规划"},{"text":"选择问题 输入： 一个包含n个元素的集合A和一个整数i， 1 ≤ i ≤ n 输出： 元素x属于A，且A中恰好有i-1个元素小于（大于）它。 Find Minimum in Rotated Sorted Array Suppose a sorted array is rotated at some pivot unknown to you beforehand. (i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2). Find the minimum element. You may assume no duplicate exists in the array. 分析 我们知道，旋转后的左右部分都是有序的，若中间元素小于右边的元素，则最小值一定在 左边的集中，否则就在右边的集合中。 Python Code 递归版本 class Solution : # @param num, a list of integer # @return an integer def findMin ( self , num ): n = len ( num ) left , right = 0 , n - 1 while left < right and num [ left ] > num [ right ] : mid = left + ( right - left ) / 2 if num [ mid ] <= num [ right ]: right = mid else : left = mid + 1 return num [ left ] 迭代版本 class Solution : # @param num, a list of integer # @return an integer def findMin ( self , num ): length = len ( num ) if length < 4 : return min ( num ) left , right = 0 , length - 1 while left < right and num [ left ] > num [ right ]: mid = ( right - left ) / 2 + left if num [ mid ] > num [ right ]: left = mid + 1 else : right = mid return num [ left ] 第k大元素 Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element. For example, Given [3,2,1,5,6,4] and k = 2, return 5. Note: You may assume k is always valid, 1 ≤ k ≤ array's length. 分析 这里使用一个期望为O（n）的算法， 空间复杂度为O(lgn)的算法。 随机从集合中选出一个元素，使用和快排类似的partion算法，找到这个元素在集合中的新位置index 由于是第k大，因此比较 n-index-1 与 k 的大小。如果相等则即为找到的元素 如果n-index-1 < n-k，递归处理左半部分,其中k = k - (n-index-1) 否则递归处理右半部分。 Python Code import random class Solution : def findKthLargest ( self , nums , k ): n = len ( nums ) if n == 1 : return nums [ 0 ] q = random . randint ( 0 , n - 1 ) nums [ - 1 ], nums [ q ] = nums [ q ], nums [ - 1 ] pivort = nums [ - 1 ] i = - 1 for j in range ( n - 1 ): if nums [ j ] <= pivort : i += 1 nums [ i ], nums [ j ] = nums [ j ], nums [ i ] nums [ i + 1 ], nums [ - 1 ] = nums [ - 1 ], nums [ i + 1 ] cnt = n - i - 1 if cnt == k : return pivort if cnt > k : return self . findKthLargest ( nums [ n - cnt + 1 :], k ) elif cnt < k : return self . findKthLargest ( nums [: n - cnt ], k - cnt ) 下面的例子是findK应用的推广 两个排序数组的中的中位数 There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 分析 由于数组已经是排序的，因此使用上面的findK算法，每次都可以确定的缩小一半的查找范围。同时，如果两个数组长度 之和为偶数，中位数为连个中间数的平均数，如果为奇数，则中位数即为中间数。 Python Code class Solution : # @return a float def findMedianSortedArrays ( self , A , B ): lenA = len ( A ) lenB = len ( B ) length = lenA + lenB if length % 2 == 1 : return self . findKth ( A , B , length / 2 + 1 ) else : return ( self . findKth ( A , B , length / 2 ) + self . findKth ( A , B , length / 2 + 1 )) / 2.0 def findKth ( self , A , B , k ): if len ( A ) > len ( B ): return self . findKth ( B , A , k ) if len ( A ) == 0 : return B [ k - 1 ] if k == 1 : return min ( A [ 0 ], B [ 0 ]) pa = min ( k / 2 , len ( A )) pb = k - pa if A [ pa - 1 ] < B [ pb - 1 ]: return self . findKth ( A [ pa :], B , k - pa ) // select from the remainder A and B elif A [ pa - 1 ] > B [ pb - 1 ]: return self . findKth ( A , B [ pb :], k - pb ) else : return A [ pa - 1 ]","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/24/select/","title":"选择算法"},{"text":"把二叉查找树保存到文件中 Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. You must be able to restore to the exact original BST using the saved format. 由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历 或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过 中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来 构造一棵二叉树。 构造二叉树的代码如下： void readBSTHelper ( int min , int max , int & insertVal , BinaryTree *& p , ifstream & fin ) { if ( insertVal > min && insertVal < max ) { int val = insertVal ; p = new BinaryTree ( val ); if ( fin >> insertVal ) { readBSTHelper ( min , val , insertVal , p -> left , fin ); readBSTHelper ( val , max , insertVal , p -> right , fin ); } } } void readBST ( BinaryTree *& root , ifstream & fin ) { int val ; fin >> val ; readBSTHelper ( INT_MIN , INT_MAX , val , root , fin ); } Serialization|Deserialization of a Binary Tree Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called ‘serialization' and reading back from the file to reconstruct the exact same binary tree is ‘deserialization'. 在二叉排序树中，中序遍历是有序的，而普通的二叉树就没有这样的性质。因此需要使用哨兵来输出那些空的节点，来最终确定每个 节点的位置。这里使用前序遍历。 Cpp Code void writeBinaryTree ( BinaryTree * p , ostream & out ) { if ( ! p ) { out << \"# \" ; } else { out << p -> data << \" \" ; writeBinaryTree ( p -> left , out ); writeBinaryTree ( p -> right , out ); } } 从文件中读取这个二叉树的操作也是类似的。我们同样使用先序遍历，如果遍历到的节点是一个哨兵，说明是 空节点，我们忽视这个节点就好。如果是一个具体的数值，我们就把它插入到当前的节点，然后遍历它的左孩子， 然后遍历它的右孩子。 Cpp Code void readBinaryTree ( BinaryTree *& p , ifstream & fin ) { int token ; bool isNumber ; if ( ! readNextToken ( token , fin , isNumber )) return ; if ( isNumber ) { p = new BinaryTree ( token ); readBinaryTree ( p -> left , fin ); readBinaryTree ( p -> right , fin ); } } 当然我们也可以使用层次遍历。 Printing a Binary Tree in Level Order Given a binary tree, print out the tree in level order (ie, from left to right, level by level). Output a newline after the end of each level. 3 / \\ 9 20 / \\ 15 7 For example, the level order output of the tree above is: 3 9 20 15 7 可以使用BFS或者DFS BFS 使用BFS时，需要记录一层的节点数目，以及下层的节点数目。当这层的 节点数目为0的时候，说明这层的节点已经完全被输出。然后接着输出下一层。 void printLevelOrder ( BinaryTree * root ) { if ( ! root ) return ; queue < BinaryTree *> nodesQueue ; int nodesInCurrentLevel = 1 ; int nodesInNextLevel = 0 ; nodesQueue . push ( root ); while ( ! nodesQueue . empty ()) { BinaryTree * currNode = nodesQueue . front (); nodesQueue . pop (); nodesInCurrentLevel -- ; if ( currNode ) { cout << currNode -> data << \" \" ; nodesQueue . push ( currNode -> left ); nodesQueue . push ( currNode -> right ); nodesInNextLevel += 2 ; } if ( nodesInCurrentLevel == 0 ) { cout << endl ; nodesInCurrentLevel = nodesInNextLevel ; nodesInNextLevel = 0 ; } } } DFS 使用DFS时需要记录递归的深度，根据递归的深度来确定层数 class Solution : # @param root, a tree node # @return a list of lists of integers def levelOrder ( self , root ): res = [] def dfs ( root , depth ): if root : if self . cur == depth : res . append ([ root . val ]) self . cur += 1 else : res [ depth ] . append ( root . val ) dfs ( root . left , depth + 1 ) dfs ( root . right , depth + 1 ) if root : self . cur = 0 dfs ( root , 0 ) return res Morris二叉树遍历算法 对于二叉树的遍历，可以使用递归或者堆栈，但morris遍历，使用 无堆栈，O（1）空间进行二叉树遍历。 原理 利用所有叶子节点的右指针，指向其后继节点，形成一个环，在第二次遍历到这个节点时， 由于左子树已经遍历完了，则访问该节点。 中序遍历 算法伪码： 1. Initialize current as root 2. While current is not NULL If current does not have left child a) Print current's data b) Go to the right, i.e., current = current->right Else a) Make current as right child of the rightmost node in current's left subtree b) Go to this left child, i.e., current = current->left Python Code def morris_inorder ( self , root ): res = [] p = root while p : if p . left is None : res . append ( p . val ) p = p . right else : tmp = p . left while tmp . right and tmp . right != p : tmp = tmp . right if tmp . right is None : tmp . right = p p = p . left else : res . append ( p . val ) tmp . right = None p = p . right return res Morris的前序遍历和中序遍历比较类似，只不过在前驱节点为空的时候，直接输出当前的节点 后序遍历 后序遍历比较复杂，需要建立一个临时节点dump，令其左孩子为root，并且需要一个倒序输出某两个节点 之间路径的各个节点的自过程。 具体实现和测试代码见 Github Count Complete Tree Nodes Given a complete binary tree, count the number of nodes. In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. 分析 根据左右子树的高度判断下次从左子树还是右子树进行查找，类似二分查找，时间复杂度为O（lgn）*O(lgn)树高 因此总的时间复杂度为O（lgn&#94;2），具体实现有很多方式，需要注意的是，当判断这棵树为完全树的时候 应该马上返回它的节点数目，以此加快递归的返回速度。 CPP Code class Solution { public : int countNodes ( TreeNode * root ) { if ( root == NULL ) return 0 ; TreeNode * L = root ; TreeNode * R = root ; int height = 0 ; while ( R ) { height += 1 ; L = L -> left ; R = R -> right ; } if ( L == NULL ) { return ( 1 << height ) - 1 ; } return 1 + countNodes ( root -> left ) + countNodes ( root -> right ); } }; Convert Sorted List to Balanced Binary Search Tree (BST) Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 由于链表只能顺序遍历，因此最优的解法应该是在遍历链表的同时，构造这个二叉查找树。 因此我们采取bottom-up(而非通常的top-down)的方法，从底到上创建二叉查找树节点，然后把他们分配到它们的父亲节点中 这样就可以一边遍历，一遍构造二叉查找树。 BinaryTree * sortedListToBST ( ListNode *& list , int start , int end ) { if ( start > end ) return NULL ; // same as (start+end)/2, avoids overflow int mid = start + ( end - start ) / 2 ; BinaryTree * leftChild = sortedListToBST ( list , start , mid - 1 ); BinaryTree * parent = new BinaryTree ( list -> data ); parent -> left = leftChild ; list = list -> next ; parent -> right = sortedListToBST ( list , mid + 1 , end ); return parent ; } BinaryTree * sortedListToBST ( ListNode * head , int n ) { return sortedListToBST ( head , 0 , n - 1 ); } Convert Binary Search Tree (BST) to Sorted Doubly-Linked List 同上面的方法类似，我们可以采用中序遍历的方法，把每个遍历到的节点依次插入到 双向链表中，同时保持双向链表的有序性 void treeToDoublyList ( Node * p , Node *& prev , Node *& head ) { if ( ! p ) return ; treeToDoublyList ( p -> left , prev , head ); // current node's left points to previous node p -> previous = prev ; if ( prev ) prev -> next = p ; // previous node's right points to current node else head = p ; // current node (smallest element) is head of // the list if previous node is not available // as soon as the recursion ends, the head's left pointer // points to the last node, and the last node's right pointer // points to the head pointer. Node * right = p -> right ; head -> previous = p ; p -> next = head ; // updates previous node prev = p ; treeToDoublyList ( right , prev , head ); } // Given an ordered binary tree, returns a sorted circular // doubly-linked list. The conversion is done in-place. Node * treeToDoublyList ( Node * root ) { Node * prev = NULL ; Node * head = NULL ; treeToDoublyList ( root , prev , head ); return head ; }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/18/binary-tree/","title":"二叉树"},{"text":"和树的遍历类似，关于的图的遍历一般也有两种，深度优先和宽度优先。 课程安排 I&II There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 分析 核心是遍历图，确定图中节点的数目，以及图中是否有环。其中课程安排II的核心是根据拓扑排序后的节点约束的如果小于课程数目，则剩下的按正常排序即可（节点之间没有前后的约束关系），这里可以使用 Topological sorting 具体深度优先的算法如下 L = Empty list that will contain the sorted nodes while there are unmarked nodes do select an unmarked node n visit ( n ) function visit ( node n ) if n has a temporary mark then stop ( not a DAG ) if n is not marked ( i . e . has not been visited yet ) then mark n temporarily for each node m with an edge from n to m do visit ( m ) mark n permanently unmark n temporarily add n to head of L 具体实现 def findOrder ( self , numCourses , prerequisites ): self . lst = [] self . visited = [ - 1 ] * numCourses self . hascyle = False for edge in prerequisites : if self . visited [ edge [ 0 ]] == - 1 : self . visit ( edge [ 0 ], prerequisites ) if self . hascyle : return [] for i in range ( numCourses ): if i not in self . lst : self . lst . append ( i ) return self . lst def visit ( self , node , prerequisites ): if self . visited [ node ] == 0 : self . hascyle = True return if self . visited [ node ] == - 1 : self . visited [ node ] = 0 for edge in prerequisites : if edge [ 0 ] == node : self . visit ( edge [ 1 ], prerequisites ) #self.visited[node] =-1 self . visited [ node ] = 1 self . lst . append ( node ) 发现岛的数目 Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110 11010 11000 00000 Answer: 1 Example 2: 11000 11000 00100 00011 Answer: 3 分析 这道题其实是求连通分支的个数。可以采取DFS, 或者BFS。下面采用的是DFS，在每次的 DFS调用中，就会找到一个连通分支，直到遍历图中的所有节点找到所有的连通分支。 def numIslands ( self , grid ): m = len ( grid ) if m < 1 : return 0 n = len ( grid [ 0 ]) visited = [[ 0 for i in range ( n )] for j in range ( m )] def dfs ( row , col ): visited [ row ][ col ] = 1 if row > 0 and grid [ row - 1 ][ col ] == '1' and not visited [ row - 1 ][ col ]: dfs ( row - 1 , col ) if row < m - 1 and grid [ row + 1 ][ col ] == '1' and not visited [ row + 1 ][ col ]: dfs ( row + 1 , col ) if col > 0 and grid [ row ][ col - 1 ] == '1' and not visited [ row ][ col - 1 ]: dfs ( row , col - 1 ) if col < n - 1 and grid [ row ][ col + 1 ] == '1' and not visited [ row ][ col + 1 ]: dfs ( row , col + 1 ) count = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == '1' and not visited [ i ][ j ]: dfs ( i , j ) count += 1 return count","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/13/graph/","title":"图论"},{"text":"内存管理 ，对于Python这样的动态语言是必不可少的。通常的内存管理包括操作系统提供的虚拟内存，以及 垃圾回收机制。本文着重于Python中的垃圾回收机制。 首先我们介绍一下的垃圾回收中通用的基本概念 垃圾回收 如果一个程序可能直接或间接地引用一个对象，那么这个对象就是\"存活的\"，已经引用不到的对象就是\"死亡\" 的。垃圾回收就是要自动的收集并释放这些死亡的对象。 垃圾回收中常见的算法 1. 标记清除(Mark and Sweep) 原理 首先从根开始将可能引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。 根 所谓根就是判断对象是否可被引用的起始点。虽然不同的语言编译器对根的规定不同，但基本上是讲变量和运行栈 作为根。 标记清除算法的时间是和存活对象数与对象总数的综合相关的。 还有一种变形 缺点 在分配了大量的对象，并且其中只有一部分存活的情况下，所消耗的时间会大大超过必要的值，这时因为 在清除阶段还需要对大量死亡对象进行扫描。 标记压缩(Mark and Compact) 它不是将标记的对象清除，而是在清理无用对象完成后让所有存活的对象都向一端移动， 并更新引用其对象的指针，节约了内存空间 缺点 压缩过程较慢，效率较低。 复制收集(Copy and Collection) 将从根节点开始被引用的对象复制到另外的空间中，然后将复制的对象能够引用的对象用递归的方式不断复制 下去。 优点 有很好的局部性。在复制过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的 内存空间中的可能性会提高。 缺点 内存减少一半，可用空间减少 2. 引用计数 原理 在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。 引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束等时间点。当一个对象的引用计数变为0时， 则说明它将来不会被引用，因此可以释放相应的内存空间。 缺点 无法回收循环引用 维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 3. 分代回收 由于GC和程序处理的本质是无关的，因此它消耗的时间越短越好。分代回收的目的就是为了在程序运行期间，将GC所 消耗的时间尽量缩短，是一种空间换时间的策略。 思路 利用一般性程序所具备的性质，即大部分对象在短时间内都会成为垃圾，而经过一定时间依然存活的对象往往 拥有较长的寿命。 增量回收 不等GC全部完成，而是将GC操作细分成多个部分逐一执行。这种方式被成为增量回收。 GC大一统理论 像标记清除和复制收集这样，从根开始进行扫描以判断对象生死的算法，被称为追踪回收（Tracing）。引用 计数算法则是当对象之间的引用关系发生变化时，通过对引用技术进行更新来判断对象生死的。 任何一种GC算法，都是追踪回收和引用计数回收两种思路的组合。 下面就结合Python源码具体说下Python中垃圾回收的实现，更多源码见 Python 源码剖析 Python垃圾回收中的引用计数 每个Python对象都有一个Pyobject_HEAD // object.h struct _object { Py_ssize_t ob_refcnt ; // 应用计数值 struct PyTypeObject * ob_type ; } PyObject ; 其中 ob_refcnt就是利用引用技术来进行垃圾回收的数据结构。 在容器中有循环引用出现的情况下，Python就辅助使用标记清除和分代回收来解决这样的问题。 Python垃圾回收中的标记清除 Python中的垃圾回收机制完全是为了处理循环引用而设计的。 所有容器对象在PyObject_HEAD之前加入PyGC_HEAD来实现标记清除机制。 // objimpl.h typedef union _gc_head { struct { union _gc_head * gc_next ; union _gc_head * gc_prev ; Py_ssize_t gc_refs ; } gc ; long double dummy ; /* force worst-case alignment */ } PyGC_Head ; 垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)： // gcmodule.c static void update_refs ( PyGC_Head * containers ) { PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { assert ( gc -> gc . gc_refs == GC_REACHABLE ); gc -> gc . gc_refs = FROM_GC ( gc ) -> ob_refcnt ; assert ( gc -> gc . gc_refs != 0 ); } } 然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1： // gcmodule.c static void subtract_refs ( PyGC_Head * containers ) { traverseproc traverse ; PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { traverse = FROM_GC ( gc ) -> ob_type -> tp_traverse ; ( void ) traverse ( FROM_GC ( gc ), ( visitproc ) visit_decref , NULL ); } } 然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象。 // gcmodule.c static void move_unreachable ( PyGC_Head * young , PyGC_Head * unreachable ) { PyGC_Head * gc = young -> gc . gc_next ; while ( gc != young ) { PyGC_Head * next ; // 对于root object，把gc_refs设置为GC_REACHABLE if ( gc -> gc . gc_refs ) { PyObject * op = FROM_GC ( gc ); traverseproc traverse = op -> ob_type -> tp_traverse ; assert ( gc -> gc . gc_refs > 0 ); gc -> gc . gc_refs = GC_REACHABLE ; ( void ) traverse ( op , ( visitproc ) visit_reachable , ( void * ) young ); next = gc -> gc . gc_next ; } // 对于非root对象移到unreachable链表中，并标记为 // GC_TENTATIVELY_UNREACHABLE else { next = gc -> gc . gc_next ; gc_list_move ( gc , unreachable ); gc -> gc . gc_refs = GC_TENTATIVELY_UNREACHABLE ; } gc = next ; } } 在处理完finalizer等细节之后，就可以对unreasonable链表中的节点进行回收 Python垃圾回收中的分代回收 用来表示\"代\"的结构体是gc_generation， 包括了当前代链表表头、对象数量上限、当前对象数量： // gcmodule.c struct gc_generation { PyGC_Head head ; int threshold ; /* collection threshold */ int count ; /* count of allocations or collections of younger generations */ }; Python默认定义了三代对象集合，代数越大，对象存活时间越长。 #define NUM_GENERATIONS 3 #define GEN_HEAD(n) (&generations[n].head) /* linked lists of container objects */ static struct gc_generation generations [ NUM_GENERATIONS ] = { /* PyGC_Head, threshold, count */ {{{ GEN_HEAD ( 0 ), GEN_HEAD ( 0 ), 0 }}, 700 , 0 }, {{{ GEN_HEAD ( 1 ), GEN_HEAD ( 1 ), 0 }}, 10 , 0 }, {{{ GEN_HEAD ( 2 ), GEN_HEAD ( 2 ), 0 }}, 10 , 0 }, }; 最后在进行垃圾回收的时候，Python从最老的一代（第二代）开始，然后回收这个代 和比它年轻的代。 //gcmodule.c //NUM_GENERATIONS = 3 static Py_ssize_t collect_generations ( void ) { int i ; py_ssize_t n = 0 ; for ( i = NUM_GENERATIONS ; i >= 0 ; i -- ){ if ( generations [ i ]. count > generations [ i ]. threshold ){ n = collect ( i ); break ; } } return n ; } 总结： Python采用了最常用的引用计数来跟踪和回收垃圾。在引用计数的基础上， 通过\"标记-清除\"解决容器对象可能产生的循环引用问题， 通过\"分代回收\"以空间换时间的方法提高垃圾回收效率。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/10/garbage-collection-in-python/","title":"Python中的垃圾回收机制"},{"text":"无论使用什么编程语言，生产一条基本语句所需要的工数几乎是一定的。 —弗雷德里克·布鲁克斯 特定领域语言(Domain Specific Language) 指利用为特定领域所专门设计的词汇和语法，简化程序设计过程，提高 生产效率的技术。 优点 可以直接使用其对象领域中的概念，集中描述\"what\"部分，而不必对\"how\" 进行描述。 外部DSL 像这些迷你语言为代表的，由专用的语言引擎来实现的DSL，称为外部DSL。 XML、SQL、正则表达式就是典型的外部DSL 内部DSL 内部DSL是在现在语言中实现DSL，而作为DSL基础的这种现有语言，称为数组语言。 外部DSL是从UNIX脱胎发展而来的，而内部DSL则是发源于Lisp和Smalltalk Programming is a process of designing DSL for your own application —— 大卫·托马斯 DSL设计的构成要素 上下文（Context） 语句 （Sentence） 单位 （Unit） 词汇 （Vocabulary） 层次结构 （Hierarchy） 元编程 所谓元编程就是用程序来编写程序。在Ruby和Python这样的语言中，由于程序本身的信息是可以被访问的， 因此在程序运行中也可以对程序本身进行操作，这就是元编程。 反射 在C++中，一个对象是知道自己的数据类型的， 通过这个信息，可以在调用虚拟成员函数时，选择与自己的类型相匹配的函数。 像这样获取和变更程序本身信息的功能，被称为反射（Reflection）。 闭包 在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。 对象：在数据中以方法的形式包含了过程 闭包：在过程中以环境的形式包含了数据 动态运行 就是在运行后总的程序能够识别自身，并对自身进行操作。而程序对自身操作的编程也被称为元编程。 鸭子类型(Duck Typing) 不考虑某个对象到底是哪个类的实例，而只关心它拥有哪些方法，这就是鸭子类型。 结构子类型(Structuaral Subtyping) 以类型的结构来确定可代换性的类型关系，被称为结构子类型。 名义子类型 (Nominal Subtyping) 像Java这样根据声明拥有继承关系的类型具有可代换性的类型关系，被称为名义子类型。 非强制静态类型 在Dart中，没有指定类型的变量和表达式会被当做Dynamic型，其类型检查在运行时完成。 提高动态语言速度的三种技术 JIT(Just In Time Compiler)，指的是在程序运行时将其编译为机器语言的技术。由于编译为机器语言的程序可以以CPU原本的 速度来运行，因此能够克服解释器所带来的劣势。 特殊化，指的是一种在将函数转换为内部表达时所需用的技术。通常假定参数为特殊类型， 事先准备一个特殊化的高速版本，在函数调用的开头先执行类型检查，当前提条件成立时直接运行 高速版本，从而避免了在运行时伴随的大量的类型检查。 分代回收，见 垃圾回收 。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/09/programming-language/","title":"编程语言中的基本概念"},{"text":"编程&技术 1. 系统架构&设计模式 大型网站技术架构 [Done] 设计模式可重用面向对象软件的基础 [10%] HeadFirst 设计模式 [0%] 构建高性能的web站点 [0%] 简约之美：软件设计之道 [0%] 重构:改善既有代码的设计 [10%] 关于系统架构和设计模式的东西了解的不多，至少一些基本原理和方法还是需要懂的 2. 计算机科学 网络 TCP/IP详解卷1 [Done] TCP/IP详解卷2 [30%] Unix网络编程 [10%] 数据结构与算法 算法导论 [Done] 算法概论 [Done] 编程珠玑 [Done] 编程之美 [Done] 剑指offer [Done] Cracking the Coding Interview [60%] 具体数学 [10%] 算法竞赛入门经典训练指南 [10%] 操作系统 深入理解计算机系统 [Done] 鸟哥的Linux私房菜 [Done] Unix 环境高级编程 [20%] 编程语言&程序设计 C C专家编程 [Done] C陷阱和缺陷 [Done] C和指针 [10%] K&R [10%] C++ C++ primer [Done] Effective C++ [10%] More Effective C++ [20%] Python Python基础教程 [Done] Python核心编程 [Done] Django Web开发指南 [Done] 改善Python代码的91个意见[Done] Python高级编程 [40%] Python 源码剖析 [20%] 机器学习 数学之美 [Done] 集体智慧编程 [Done] 统计学习方法 [Done] 机器学习实战 [10%] 程序设计 计算机程序的构造与解释 [10%] 编程实践 代码的未来 [Done] 可读代码的艺术 [10%] 7周7语言 [10%] 代码大全 [0%] 程序员的自我修养-链接装载与库 [10%] 其它 Shell Mysql 正则表达式 3.软件开发 UNIX编程艺术 [30%] 程序员的修炼之道-从小工到专家 [15%] 人件 [10%] 人月神话 [30%] 高效能程序员的45个习惯：敏捷开发之道 [10%] 程序员的思维修炼: 开发认知潜能的九堂课 [25%] 4. 科技人文 浪潮之巅 [Done] 淘宝技术这十年 [Done] 乔布斯转 [Done] 悟空转 [Done] 黄金时代 [Done] 三体1 [Done] 三体2 [40%] 三体3 [0%] 白银时代 [30%] 世界是平的 [Done] 淘宝技术这十年 [Done] mactalk 人生元编程 [Done] 菊与刀 [Done] 5.思维 禅与摩托车维修艺术 [Done] 自控力 [Done] 天才在左，疯子在右 [Done] 黑客与画家 [Done] 失控 [30%] 禅者的初心 [30%] 影响力 [Done] 思维的乐趣[Done] 暗时间 [Done] 要读书单 思考的快与慢 [0%] 自私的基因 [0%] 乌合之众 [0%] 批判性思维：带你走出思维的误区 [0%] 学习之道 [0%] 黑天鹅：如何应对不可预知的未来 [0%] 从0到1开启商业与未来的秘密 [0%]","tags":"编程","loc":"www.houcj.net/blog/2015/05/08/my-booklist/","title":"我的书单"},{"text":"解压缩文件： $ cd /path/to/works $ tar cvzf game.tar.gz works // 压缩 $ tar zxvf game.tar.gz // 解压缩 SCP命令 scp hostfilename remotename@remoteIP:/path/to/remote $ scp ./works.zip root@192.168.56.101:/home/game 修改可执行权限 chmod +x //or chmod 755 Linux下TCP Socket编程 Socket端口重用: setsockopt()改善程序的健壮性 如果在已经处于 ESTABLISHED状态下的socket调用close socket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket,可以使用 SO_REUSEADDR 套接字选项，这个选项通知内核，如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口。如果端口忙，而TCP状态位于 其他状态，重用端口时依旧得到一个错误信息，指明\"地址已经使用中\"。 ： int opt = 1 ; setsockopt ( listenfd , SOL_SOCKET , SO_REUSEADDR , & opt , sizeof ( opt )); 如果要已经处于连接状态的soket在调用close socket后强制关闭，不经历 TIME_WAIT 的过程： bool bDontLinger = FALSE ; setsockopt ( s , SOL_SOCKET , SO_DONTLINGER , ( const char * ) & amp ; bDontLinger , sizeof ( bool )); 在send()，recv()过程中有时由于网络状况等原因，发收不能预期进行，而设置收发时限： int nNetTimeout = 1000 ; //1秒 //发送时限 setsockopt ( socket , SOL_S0CKET , SO_SNDTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); //接收时限 setsockopt ( socket , SOL_S0CKET , SO_RCVTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节 (异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据 和接收数据量比较大，可以设置socket缓冲区，而避免了send()，recv()不断的循环收发： // 接收缓冲区 int nRecvBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_RCVBUF , ( const char * ) & amp ; nRecvBuf , sizeof ( int )); //发送缓冲区 int nSendBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_SNDBUF , ( const char * ) & amp ; nSendBuf , sizeof ( int )); 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响 程序的性能： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_SNDBUF , ( char * ) & amp ; nZero , sizeof ( nZero )); 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_RCVBUF , ( char * ) & amp ; nZero , sizeof ( int )); 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性： BOOL bBroadcast = TRUE ; setsockopt ( s , SOL_SOCKET , SO_BROADCAST , ( const char * ) & amp ; bBroadcast , sizeof ( bool )); 在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可 以设置connect()延时，直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的 作用，在阻塞的函数调用中作用不大) bool bConditionalAccept = TRUE ; setsockopt ( s , SOL_SOCKET , SO_CONDITIONAL_ACCEPT , ( const char * ) & amp ; bConditionalAccept , sizeof ( bool )); 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket()，以前我们 一般采取的措施是\"从容关闭\"shutdown(s，SD_BOTH)，但是数据是肯定丢失了，如何设置让程序满足具体 应用的要求(即让没发完的数据发送出去后在关闭socket)？ struct linger { u_short l_onoff ; u_short l_linger ; }; linger m_sLinger ; m_sLinger . l_onoff = 1 ; //(在closesocket()调用，但是还有数据没发送完毕的时候容许逗留) // 如果m_sLinger.l_onoff=0;则功能和2.)作用相同; m_sLinger . l_linger = 5 ; //(容许逗留的时间为5秒) setsockopt ( s , SOL_SOCKET , SO_LINGER , ( const char * ) & amp ; m_sLinger , sizeof ( linger )); PS: 1. 在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用 2. 如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0； 还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息： (前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数，采用的 具体协议，以及出错的代码都可以记录下来） bool bDebug = TRUE ; setsockopt ( s , SOL_SOCKET , SO_DEBUG , ( const char * ) & amp ; bDebug , sizeof ( bool )); 粘包 指TCP协议中，发送方发送的若干包数据到接收时粘成以包，从接收缓存看，后一数据的 头紧接着前以包数据的尾。 粘包出现的原因 发送端需要等缓冲区满才发送出去，造成粘包 接收方不及时接受缓冲区的包，造成多个包接收 粘包解决方法 使用TCP中的强制数据立即传送操作指令PUSH 接收方提高接收进程的优先级，或者将一个包中的数据按结构字段，人为控制接受方式。","tags":"编程","loc":"www.houcj.net/blog/2015/05/07/huawei-related/","title":"TCP Socket"},{"text":"首先介绍最简单的反转链表 题目描述: Reverse a singly linked list. 分析： 题目比较简单，可以使用迭代或者递归分别实现。 迭代实现 原链表中的元素依次插入到新的链表中，作为新链表的第一个元素，这里需要注意的是，防止断链。 def reverseList ( self , head ): dummy = ListNode ( - 1 ) cur = None dummy . next = cur while head : q = head . next # 防止断链 dummy . next = head head . next = cur cur = head head = q return dummy . next 或者 原地迭代，每次都把当前的节点链接到到前一个节点。 def reverseList2 ( self , head ): pre = None cur = head while cur : p = cur . next # 保存下一个元素 cur . next = pre # 把当前的指针链接到前一个元素 pre = cur cur = p return pre 递归实现 每次都把下一个节点链接到当前节点。 def reverseList1 ( self , head ): if ( not head ) or ( not head . next ): return head q = self . reverseList1 ( head . next ) head . next . next = head head . next = None return q 进阶1 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL 分析 关键是找到反转位置的节点， def reverseBetween ( self , head , m , n ): pre = dummy = ListNode ( - 1 ) dummy . next = head count = 1 while count < m : pre = pre . next # 找到反转节点的前一个节点 head = head . next #当前的反转节点 count += 1 while count < n : p = head . next # 把当前反转节点的下一个节点依次插入到链表中 head . next = p . next # 保证head节点指向n以后的节点 p . next = pre . next pre . next = p count += 1 return dummy . next 进阶2 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 return 1->4->3->2->5->NULL 分析 找到反转字符串的起点和终点，然后再把它们连接起来。只需要扫描一遍链表即可，时间复杂度O(N)。 def reverseKGroup ( self , head , k ): pre = tail = dummy = ListNode ( - 1 ) dummy . next = head while 1 : count = k while tail and count : count -= 1 tail = tail . next if not tail : break head = pre . next # for the next cycle while pre . next != tail : p = pre . next # assign pre . next = p . next # delete p . next = tail . next #tail the beging of the reverse list tail . next = p # insert tail = head pre = head return dummy . next 完整代码见 Github","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/reverse-linked-list/","title":"反转链表"},{"text":"题目描述 : Count the number of prime numbers less than a non-negative number, n 分析 ： 这里需要注意的是n是很大的整数，因此不能在循环内使用函数的调用来判断一个数是否为素数，否则会超时。可以使用bool数组来确定这个数是否为素数。下面介绍一种素数筛选法来解决这个问题。 素数筛选法就是的理论基础就是每个合数都是可以分解为两个或者多个素数相乘的形式。首先除2以外的偶数都不是素数，另外，对于素数3，它的倍数3*5，3*7，...，3*n，都不是素数。 剩下都是素数。 具体见下面的代码。 class Solution { public : int countPrimes ( int n ) { if ( 2 >= n ) return 0 ; bool * a = new bool [ n ]; for ( int i = 0 ; i < n ; i ++ ){ if ( i % 2 == 0 ) { a [ i ] = false ; } // 除2以外的偶数都不是素数 else { a [ i ] = true ; } } a [ 1 ] = false ; // 1 不是素数 a [ 2 ] = true ; // 2 是素数 int sn = int ( sqrt ( n )); for ( int i = 3 ; i < sn + 1 ; i += 2 ){ if ( a [ i ]) { for ( int j = i * i ; j < n ; j += i << 1 ) // i的奇数倍都不是素数 { a [ j ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ]) { sum += 1 ; } } delete [] a ; return sum ; } }; Python代码实现见 Github ，需要注意的是Python中的bool数组必须声明为[True]*n.","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/sifting-prime/","title":"素数筛选法"},{"text":"间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 读未初始化的存储器 虽然bss存储器位置总是被加载器初始化为零，但对于堆存储器不是这样的。在堆中初始化的元素的值是不确定的 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 引用指针而不是它所指向的对象 int * binheapDelete ( int ** binheap , int * szie ) { int * packet = binheap [ 0 ]; binheap [ 0 ] = binheap [ * szie - 1 ]; * size -- ; //should be (*size)-- heapify ( binheap , * size , 0 ); return ( packet ); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } /*C程序中常见的与存储器有关的错误 */ 间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 引用指针而不是它所指向的对象 int *binheapDelete(int **binheap, int *szie) { int *packet = binheap[0]; binheap[0] = binheap[*szie -1]; *size--;//should be (*size)-- heapify(binheap, *size, 0); return(packet); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } strcpy（）函数 #include<stdio.h> int main ( int argc , char * argv []) { int flag = 0 ; char passwd [ 10 ]; memset ( passwd , 0 , sizeof ( passwd )); strcpy ( passwd , argv [ 1 ]); /*argv[1] = \"aaaaaaaaaaaaa\"是，下面的flag也为1*/ if ( 0 == strcmp ( \"LinuxGeek\" , passwd )) { flag = 1 ; } if ( flag ) { printf ( \" \\n Password cracked \\n \" ); } else { printf ( \" \\n Incorrect passwd \\n \" ); } return 0 ; } 破解上述加密的关键在于利用攻破strcpy()函数的漏洞。 所以用户在向\"passwd\"缓存输入随机密码的时候并没有提前检查\"passwd\"的容量是否足够。 所以，如果用户输入一个足够造成缓存溢出并且重写\"flag\"变量默认值所存在位置的内存的长\"密码\"， 即使这个密码无法通过验证，flag验证位也变成了非零，也就可以获得被保护的数据了。 要避免这样的问题， 建议使用 strncpy()函数 。 - 修改代码片段（只读代码） #include<stdio.h> int main ( void ) { char * ptr = \"China\" ; * ptr = 'A' ; printf ( \" \\n [%s] \\n \" , ptr ); return 0 ; } 通过*ptr = ‘T'，会改变内存中代码段（只读代码）\"China\"的第一个字母。 这个操作是无效的，因此会造成seg-fault或者崩溃。","tags":"编程","loc":"www.houcj.net/blog/2015/05/04/usual-error-in-c/","title":"C程序中常见的与存储器有关的错误"},{"text":"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. ~Donald Knuth 程序员必须再实现和维护程序的简单性与它的运行速度之间做出权衡。 优化编译器的能力和局限性 编译器必须很小心地对程序只使用安全的优化。程序中有两个妨碍优化的因素。 - 存储器别名使用 void add1 ( int * xp , int * yp ) { * xp += * yp ; * xp += * yp ; } void add2 ( int * xp , int * yp ) { * xp += 2 * * yp ; } 编译器并不会把第一个函数优化成第二个函数，因为如果考虑到 xp 等于 yp 的情况。twiddle1 中的 xp 会增加 4 倍，而 twiddle2 中的 xp 仅会增加 2 倍。 函数调用 作为一个示例，考虑下面这两个过程： int f (); int func1 () { return f () + f () + f () + f (); } int func2 () { return 4 * f (); } 编译器也不会吧第一个函数优化为第二个，考虑下面 f 的代码： int counter = 0 ; int f () { return counter ++ ; } 这个函数有个副作用：它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。 考虑下面所示的简单向量数据结构： typedef int data_t ; typedef struct { long int len ; data_t * data ; } vec_rec , * vec_ptr ; 一段合并运算的代码： void combine1 ( vec_ptr v , data_t * dest ) { long int i ; * dest = IDENT ; for ( i = 0 ; i < vec_length ( v ); i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 其中 vec_length 获取 v 的长度，get_vec_elemnet 获取内容。 特别的，使用声明： #define IDENT 0 #define OP + 它对向量的元素求和。 #define IDENT 1 #define OP * 它计算的是向量元素的乘积。 - 消除循环的低效率 void combine2 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 这种优化我们称之为代码移动。 减少过程调用 在 combine2 中，每次循环都要调用 get_vec_element ，为了减少过程调用，代码如下: data_t * get_vec_start ( vec_ptr v ) { return v -> data ; } void combine3 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { * dest = * dest OP data [ i ]; } } 但是这段代码得到的性能提高出乎意料的普通，只提高了整数求和的性能。 - 消除不必要的存储器引用 在我们将 combine3 生成汇编代码后，可以看出，在每次迭代中，程序都要读取出指针 dest 处的值，乘以 data[i]，再将结果存回到 dest。这样的读写显得很是浪费。 考虑如下代码： void combine4 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 我们引入一个临时变量 acc， 它在循环中用来累计计算来的值。只有再循环完成之后结果才存放到 dest 中。在汇编代码中可以看到，编译器会使用一个寄存器来保存累积值。与 combine3 中的循环相比，我们将每次迭代的存储器操作从两次读和一次写减少到只需要一次读。 循环展开 循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。（如果展开后不能很好的提高程序的并行性还是不要展开） void combine5 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_lenght ( v ); long int limit = length - 1 ; data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < limit ; i += 2 ) { acc = ( acc OP data [ i ]) OP data [ i + 1 ]; } for (; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 提高性能的技术 高级设计: 为遇到的问题选择适当的算法和数据结构。 基本编码原则: 消除连续的函数调用 消除不必要的存储器引用：引入临时变量来保持中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。 低级优化 展开循环，降低开销，并且使得进一步优化成为可能。 通过使用例如多个累积变量和重新结合技术，找到方法提高指令级并行。 用功能得风格重写条件操作，使得编译采用条件数据传送。 关于程序的优化，最常见的是优化是选择合适的算法和数据结构，这个是起决定性作用的，基本编码原则还是要遵守的，至于低级优化还要考虑程序的局部性等问题。Amdahl定律为我们描述了一个改进任何过程的通用原则，当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。 $$\\frac{1}{(1-\\alpha)+\\alpha/k}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/01/optimizing-program-performance/","title":"程序性能优化"},{"text":"24点游戏 是一种使用扑克牌来进行的益智类游戏，游戏内容是：从一副扑克牌中抽去大小王剩下52张，任意抽取4张牌，把牌面上的数（A代表1）运用加、减、乘、除和括号进行运算得出24。每张牌都必须使用一次，但不能重复使用。在不同版本中，对J、Q、和K的处理有些差异。一个常见的版本是把J、Q、和K去除，或当成10；还有一个版本是把J表示11，Q表示12，K代表13。 虽然大多数24点存在很多解法，有相当一部分数字组合只存在唯一的解法。这种组合往往较有难度，也较为有趣。这里总结一些常见的组合。 分数运算 虽然给出4个数字都是整数，中间步骤中有时会出现分数。这种4个数字的组合往往较有难度。一个经典的例子是1，5，5，5，其解答为5 × (5 − 1 ÷ 5) = 24；另外 一个例子是3，3，8，8，其解答为8 ÷ (3 - 8 ÷ 3) = 24。 大数／奇数运算 有些组合中会涉及到一些较大数字，这些组合通常较有难度。比如4、4、10、10的解法为(10 × 10 − 4) ÷ 4 = 24，5、6、6、9的解法为6 × 9 − 5 × 6 = 24。 下面的代码可以解决上面出现的情况。 Show the code def PointGame ( n ): i = 0 if ( n == 1 ): if matrix [ 0 ][ 0 ] == matrix [ 0 ][ 1 ] * 24 : return True else : return False for i in range ( 0 , n ): for j in range ( i + 1 , n ): # use two dimention array a = matrix [ i ][ 0 ] b = matrix [ i ][ 1 ] c = matrix [ j ][ 0 ] d = matrix [ j ][ 1 ] # python needs the deepcopy to copy the value to the destination matrix [ j ] = copy . deepcopy ( matrix [ n - 1 ]) expa = result [ i ] expb = result [ j ] result [ j ] = result [ n - 1 ] result [ i ] = '(' + expa + '+' + expb + ')' matrix [ i ][ 0 ] = a * d + b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '-' + expb + ')' matrix [ i ][ 0 ] = a * d - b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expb + '-' + expa + ')' matrix [ i ][ 0 ] = b * c - a * d matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '*' + expb + ')' matrix [ i ][ 0 ] = a * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True if c != 0 : result [ i ] = '(' + expa + '/' + expb + ')' matrix [ i ][ 0 ] = a * d matrix [ i ][ 1 ] = b * c if ( PointGame ( n - 1 )): return True if a != 0 : result [ i ] = '(' + expb + '/' + expa + ')' matrix [ i ][ 0 ] = b * c matrix [ i ][ 1 ] = a * d if ( PointGame ( n - 1 )): return True # restore the value matrix [ i ][ 0 ] = a matrix [ i ][ 1 ] = b matrix [ j ][ 0 ] = c matrix [ j ][ 1 ] = d result [ i ] = expa result [ j ] = expb i += 1 return False 完整的代码见 Github 代码持续更新，该算法的核心就是穷举每种出现的可能，为了更好的实现，上面的代码对数字出现的顺序有一定的要求。不同的顺序得到的结果可能不一样。","tags":"编程","loc":"www.houcj.net/blog/2015/04/25/cal24/","title":"24点游戏编程"},{"text":"操作系统内核是应用程序和硬件之间的媒介。它提供三个基本抽象： 文件是对I/O设备的抽象 虚拟存储器是对主存和磁盘的抽象 进程是对处理器、主存和I/O设备的抽象 系统中所有的信息，都是一串位表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文。 预处理->编译->汇编->链接 程序的机器级表达 数据传递、局部变量的分配和释放通过操作程序栈来实现。机器用栈来传递过程参数、存储返回信息、保存寄存器用于恢复，以及本地存储。为单个过程分配的那部分栈称为栈桢。最顶端的栈桢以两个指针界定，寄存器%ebp为帧指针，寄存器%esp为栈指针。 存储器层级结构 计算机系统中的一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。这个思想围绕着计算机程序的一个成为局部性（locality）的基本属性。 局部性通常有两种形式：时间局部性（temporal locality）和空间局部性（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 理解存储器层次结构的本质的程序员能够利用这些知识，编写出更有效的程序，无论具体的存储系统结构是怎样的，应使用以下技术： 将你的注意力一种在内部循环上，大部分计算机和存储器访问都发生在这里 通过按照数据对象存储在存储器中的顺序、以步长为1来读数据，从而使得你程序中的空间局部性最大 一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得你程序中的时间局部性最大 高速缓存行、组和块的区别： 块是一个固定大小的信息包，是高速缓存和主存来回传送信息的基本单位 行是高速缓存中存储块以及其他信息（有效位和标记位）的容器 组是一个或多个行的集合 直接映射高速缓存中，组和行是等价的。因为一行总是存储一个块，所以行和块通常可以互换使用。 cache friendly code 最常见的情况运行得最快 每个缓存内部缓存不明中数量最小。 对局部变量的反复引用是好的，因为编辑器能够将它们缓存在寄存器文件中（时间局部性） 步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储在连续的块。（空间局部性） 异常控制流 进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程。 从主程序返回 调用exit函数。 父进程通过fork函数创建一个新的运行子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括text，data，bss，heap以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。 父进程与新创建的子进程之间最大的区别在与它们有不同的PID。 fork函数调用一次却会返回两次，一次在是在调用父进程中，一次在新创建的子进程中。 父进程中，fork返回子进程的PID 子进程中，fork返回0。 父进程和子进程是并发运行的独立进程。 当fork在新进程中返回时，新进程现在的寻你存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中任一个后来进行写操作时，写时拷贝机制就会创建新页面。 回收子进程 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，相反，进程被保持在一种已终止的状态中，知道被它的父进程回收。当父进程回收已终止的子进程时，内核讲子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个被终止了但是还未回收的进程称为僵尸进程。 发送信号 Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。 每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。默认地，一个子进程和它的父进程同属于一个进程组。 unix> /bin/kill -9 -12345 一个负的PID会导致信号被发送到进程组PID中的每个进程。 因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和住函数并发低运行 非本地跳转 在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分治到另一个函数。 setjmp 函数在env缓冲区中保存当前调用环境，以供后面longjmp使用，并返回0.调用环境包括PC，stack pointer 和通用目的寄存器。 longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。 setjmp函数只被调用一次，但返回多次：一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时；一次是为每个相应的longjmp调用。另一方面longjmp调用一次，但从不返回。 可以把try语句中的catch自居看作类似与setjmp函数。throw语句类似与longjmp函数。 虚拟存储器 虚拟存储是对主存的一个抽象。支持虚拟存储器的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。 现代系统通过将虚拟存储器骗和磁盘上的文件片关联起来，以初始化虚拟存储器骗，这个过程叫做存储器映射。 SRAM缓存表示位于CPU和主存之间的L1、L2、L3高速缓存，DRAM缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。 由于大的不命中处罚，DRAM缓存是全相连的。因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。 按需也买年调度和独立的虚拟地址空间的结合，简化了连接和加载、代码和数据共享，以及应用程序的存储器分配。 一个给定的linux系统上每个进程都使用类似的存储器格式。文本节总是从虚拟地址0x08048000处开始（对于32位地址空间），或者从0x400000处开始（64位地址空间）。数据和bss节紧跟在text segement后面。栈占据进程地址空间最高的部分，并向下生长。 结合告诉缓存和虚拟存储器的主要思路是地址翻译发生在高速缓存查找之前。 在MMU中包含了一个关于PTE（page table entry）的小缓存，称为TLB。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。 用来压缩页表的常用方法是使用层级结构的页表 匿名文件 匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理存储器中找到一个合适的牺牲页面，如果页面被修改过就将这个页面换出，用二进制0覆盖牺牲页面并更新页表。 动态分配器 动态分配器维护着一个进程的虚拟存储器区域，称为堆。堆是一个请求二进制零的区域，它紧接在未初始化的bss区域后开始，并向上生长。 对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 动态分配器有两种基本风格。 显式分配器，要求应用显示地释放任何已经分配的块（block） 隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，就释放这个快，也叫垃圾收集器。 calloc是一个基于malloc的wrapper函数，它将分配的存储器初始化为零。想要改变一个以前已分配块的大小，可以使用realloc函数。 程序使用动态分配器分配的最重要原因是 经常知道程序实际运行时，它们才知道某些数据结构的大小 分配器的要求和目标 显示分配器必须在以下严格的约束条件下工作： 处理任意请求序列，即不可以假设分配和释放请求的顺序 立即响应请求，不允许分配器为了提供高性能重新排列或者缓冲请求 只使用堆，任何非标量数据结构都必须保存在堆里。 对齐块，分配器必须对齐块，使得它们可以保存任何类型的数据对象。 不修改已分配的快，压缩已分配的块这样的技术是不允许的。 碎片 内部碎片，是在一个已分配块比有效载荷大时发生的。 外部碎片，是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。 分配器长采用启发式策略来师徒维持少量的大空闲块，而不是维持大量的小空闲块。 如果分配器不能为请求块找到合适的空闲块，那么分配器就会通过调用sbrk函数，向内核申请额外的堆存储器。分配器讲额外的存储器转化为一个大的空闲块，将这个块插入到空闲链表中， 然后将被请求的块放置在这个新的空闲块中。 分离存储 就是维护多个空闲链表，其中每个链表中的块的大小大致相等。 简单分离存储，使用简单分离存储，每个大小类（size class）的空闲链表包含大小相等的块，每个块的大小就是这个大小类中的最大元素的大小。要释放一个块，分配器只要简单的讲这个块插入到相应的空闲链表的前部。 优点，分配和释放都是很快的常数时间 缺点，简单分离存储很容易造成内部和外部碎片 分离适配，使用分离适配，分配器维护着一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。 优点，对分离空闲链表的简单的首次适配搜索，其存储器利用率接近于对整个堆的最佳适配搜索的存储器利用率。 伙伴系统 伙伴系统是分离适配的特例，其中每个大小类都是2的幂。为了分配一个大小为2&#94;k的块，我们找到第一个可用的大小为2&#94;j的块，其中 k<=j<=m(堆的大小为2&#94;m)。如果j = k,搜索完成，否则递归二分割这个块，直到j = k。当我们进行这样的分割时，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。要释放一个大小为2&#94;k的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，就停止合并。 垃圾收集 在一个支持垃圾收集的系统中，应用显示分配堆块，但是从不显式释放它们。垃圾收集器定期识别垃圾块，并相应地调用free，将这些块放回到空闲链表中。 C程序中的 Marki&Sweep收集器必须是保守的，因为C语言不会用类型信息来标记存储器位置。想int或者float这样的标量可以伪装成指针。 并发编程 I/O多路服用技术 优点 它比基于进程的程序设计给了程序员更多的对程序行为的控制。 一个基于I/O多路服用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。 缺点 编码复杂 不能充分利用多核处理器 线程 运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文，包裹一个唯一的整数线程ID、栈，栈指针，程序计数器、通用目的寄存器和条件吗。 和一个线程相关的线程组成一个线程池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程第一个运行的线程。线程池主要的影响是，一个线程可以杀死它的任何对等线程，或者等待它的任何对等线程终止。 在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached）。 - 可结合的，一个可结合的线程能够被其他线程回收其至于那和杀死。在回收之前，它的存储器资源是没有释放的 - 可分离的，一个可分离的线程是不能别其他线程回收或杀死的。它的存储器资源在它终止时由系统自动释放。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/04/15/csapp/","title":"深入理解计算机系统"},{"text":"Programs must be written for people to read, and only incidentally for machines to execute. — Abelson & Sussman, Structure and Interpretation of Computer Programs 1. 交换变量 一般交换变量有以下三种方法： 最常用的，就是设置一个临时变量 temp = x ; x = y ; y = x ; 这种方法在python中可以更优雅的表示，而且效率更高。 x , y = y , x 不增加临时变量使用加法 b = a + b a = b - a # a = a + b - a = b 即 a = b b = b - a # b = a + b - b = a 使用位操作 b = a &#94; b a = a &#94; b b = a &#94; b 使用\"+\"和\"-\"的一行操作: a = ( a + b ) - ( b = a ) 2. Python字典中判断键值是否存在 一般情况会是用一个判断语句 dic = { 'key' : 'value' } if 'key' in dic : print dic [ 'key' ] else : print 'not found' 在python中可以内置的get函数即可 print dic . get ( 'key' , 'not found' ) 3. 读取文件 python中有三个方法来处理文件内容的输入： read（） 一次读取全部的文件内容。 f = open ( 'path/to/file.txt' , 'r' ) ff = f . read () f . close () readline() 每次读取文件的一行。 f = open ( 'path/to/file.txt' , 'r' ) line = f . readline () while 1 : if line : print line else : break f . close () readlines() 读取文件的所有行，返回一个字符串列表 f = open ( 'path/to/file.txt' , 'r' ) ff = f . readlines () f . close () 由于文件操作需要注意文件的打开和关闭操作，因此更优雅的做法是 with open ( 'path/to/file.txt' , 'r' ): for line in f : do_somenthing ( line ) 4. while 1 还是 while True？r 在python 2中，由于 True 不是关键字，因此可以对True进行赋值。下面的语句是可以的 True = 'Hello' 因此在无限循环中，我们应该使用while 1，因为while True在每次 while循环时都会有对True的判断操作。 下面使用dis，Disassembler for Python bytecode,即把python代码反汇编为字节码指令， 模块观察生成的字节码。 In [ 10 ]: import dis In [ 11 ]: def while_one (): .... : while 1 : .... : pass .... : In [ 12 ]: def while_true (): .... : while True : .... : pass .... : In [ 13 ]: if __name__ == '__main__' : .... : Print 'while 1' .... : dis . dis ( while_one ) .... : Print 'while True' .... : dis . dis ( while_true ) ##########output while 1 2 0 SETUP_LOOP 3 ( to 6 ) 3 >> 3 JUMP_ABSOLUTE 3 >> 6 LOAD_CONST 0 ( None ) 9 RETURN_VALUE while True 2 0 SETUP_LOOP 10 ( to 13 ) >> 3 LOAD_GLOBAL 0 ( True ) 6 POP_JUMP_IF_FALSE 12 3 9 JUMP_ABSOLUTE 3 >> 12 POP_BLOCK >> 13 LOAD_CONST 0 ( None ) 16 RETURN_VALUE 5. string的连接 对一个可迭代对象，经常需要对其中的字符串元素进行连接操作，这时候一般有下面两种方法 '+' 和 'join' 。 使用'+'进行操作时，每次都需要创建新的对象，然后再对新的对象进行操作。 计数出要join的所有字符串的长度，然后进行一一拷贝，这样只有一次对象生成 #This is good to glue a large number of strings for chunk in input (): my_string . join ( chunk ) 因此处于内存的考虑，应尽量使用join操作。 6. string的反转 string的反转可以使用for循环从右向做输出。代码如下 def reverse_str ( string ): return '' . join ( string [ i ] for i in range ( len ( string ) - 1 , - 1 , - 1 )) 或者使用递归 def reverse_str1 ( string ): if len ( string ) <= 1 : return string return reverse_str ( string [ 1 :]) + string [ 0 ] 当然最简单和效率最高的是使用切片。 def reverse_str1 ( string ): return string [:: - 1 ] 7. 字典中的setdefault函数 我们经常需要使用字典来初始化数据，每个字典的值是一个列表。通常使用以下的方法 dics = {} for ( val , dic ) in data : if val in dics : dics [ val ] . append ( dic ) else : dics [ val ] = [ dic ] 通过setdefault可以优化为 dics = {} for ( val , dic ) in data : dics . setdefault ( val , []) . append ( dic ) 8. 列举 在python中遍历list获得index和item。可以通过下面的代码： index = 0 for item in lst : print index , item index += 1 # or for index in range ( len ( lst )): print index , lst [ index ] 而使用enumerate可以使代码更清晰， 更易读。 for ( index , item ) in lst : print index , item 9. 列表展开（list comprehension） 列表展开比一般的循环操作的效率更高，而且更简单。 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] for i in range ( len ( a )): a [ i ] = i ** 2 // ** 比 pow （）的效率更高，因此它在 python 中是一个运算符 或者更高的实现 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] a = [ val ** 2 for val in a ] # or : a = map ( lambda i : i ** 2 , a ) 10. 很长的序列使用xrange() 相对于 range() 一次性载入整个序列， xrange() 可以帮你省下许多内存，因为它一次只载入一个元素。 11.字典和列表 在Python中，字典是基于hash table实现的。因此查找操作的复杂度是O(1),而list实际是个数组，查找操作的复杂度是O(n)。 def test (): t = time . time () lst = [ 'the' , 'zen' , 'of' , 'python' , 'Beautiful' , 'is' , 'better' , 'than' , 'ugly' ] found = [ 'Explicit' , 'is' , 'better' , 'than' , 'implicit' ] #lst = dict.fromkeys(lst,1) for i in xrange ( 10 ** 7 ): for token in found : if token not in lst : pass print time . time () - t 当直接在list中进行查找时上述代码执行了7.14800000191s，当去掉注释，使用字典使，上述代码执行了2.4960000515s，效率提高了大约1.9倍。因此当需要对数据进行频繁访问和查找的时候，dict比list具有更大的优势。 12. 生成器 要理解生成器，首先需要理解Python迭代的内部机制：Python中的迭代就是对可迭代对象实现了__iter__()方法和迭代器(iterator)实现了__next__()方法的一个操作过程。就是说，可迭代对象的__iter__()方法可以返回迭代器，迭代器通过调用next()方法获取其中的每一个值。 任何你可用 \"for... in...\" 处理的都是可迭代对象：列表，字符串，文件.... 这些迭代对象非常便捷，但是当有大量数据要使用内存的时候，必须要使用生成器了。 生成器是用来生成迭代器的函数，它的返回值是yield而不是return。因为生成器并没有将所有值放入内存中，而是实时地临时的生成这些值。 下面用打印出全排列来说明声明生成器的具体实现 def perm ( self , arr , pos = 0 ): if pos == len ( arr ): yield arr for i in range ( pos , len ( arr )): arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] #swap the elements sequential for x in self . perm ( arr , pos + 1 ): yield x arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] 当生成器要一个数时，生成器会执行，直至出现yield语句，生成器返回yield参数，之后生成器停止继续执行。 当需要下一个数时，生成器从上次的状态开始执行，直至出现yield语句，返回参数，停止。如此反复。 13. Python中有用的数据结构 Counter() Counter 用于统计可hash对象出现的次数。并以降序排序输出。 import collection string = \"the zen of python\" print collections . Counter ( string ) #output Counter ({ ' ' : 3 , 'e' : 2 , 'h' : 2 , ' \\n ' : 2 , 'o' : 2 , 'n' : 2 , 't' : 2 , 'f' : 1 , 'p' : 1 , 'y' : 1 , 'z' : 1 }) Deque Deque支持线程安全，内存优化的append和pop操作，在队列两端的插入和删除操作都近乎O(1)的时间复杂度。而list在处理即改变列表长度又改变元素位置的操作，如insert(0,v),pop(0)的时间复杂度就基本为O(n)。 Heapq heapq使用一个堆实现的优先队列。堆是一个二叉树，它的孩子节点的值都小于或者等于父亲节点（最小堆)。常见的有以下几种操作。 heapq.heappush(heap, item) 把item的值push到heap中，同时保持heap的性质。 heapq.heappop(heap) 弹出堆顶的元素 heapq.heapify(x) 在线性时间内把list x 转化为一个堆。","tags":"编程","loc":"www.houcj.net/blog/2015/04/01/life-is-short-use-python/","title":"人生苦短我用Python"},{"text":"链接 C++中允许重载方法，这些方法在源代码中有相同的名字，却有不同的函数列表。编译器讲每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这个编码过程叫做mangling。 链接器如何解析多重定义的全局符号 函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 Unix链接器使用下面的规则来处理多重定义的符号： 不允许有多个强符号。 如果有一个强符号和一个弱符号，那么选择强符号 如果有多个弱符号，那么从这些弱符号中任意选择一个 在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，连接会失败 加载器（loader）将可执行目标文件的代码和数据从磁盘拷到内存中，然后跳转到程序的第一条指令或入口点来运行程序。这个将程序拷贝到内存并运行的过程叫做加载。 无论我们在存储器中的何处加载一个目标模块，数据段总是分配成紧随代码段后面。因此，代码段中任何指令和数据段中任何一个变量之间的距离都是一个运行时常量，和代码段和数据段的绝对的存储位置无关 链接器的两个主要任务是符号解析和重定位 符号解析 讲姆讲目标文件中的每个全局符号都绑定到一个唯一的定义 重定位 确定每个符号的最终在内存中的位置，并修改对那些目标的引用。 链接器 分别编译：即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候将它们整合到一起。但是，链接器一般是与C编译器分离的。 链接器通常把由编译器或汇编器生成的若干个目标模块整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。 链接器通常把目标模块看成是由一组外部对象组成。每个外部对象代表机器内存中的某个部分，并通过一个外部名称来识别。 exit函数和return函数的主要区别是： exit用于在程序运行的过程中随时结束程序，exit的参数返回给操作系统。exit函数运行时会先执行由atexit（）函数等级的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile（）创建的临时文件。exit是结束一个进程，它将删除进程的内存空间，同时讲错误信息返回给父进程。exit是系统调用级别的，表示整个进程的结束。 return表示终止当前函数的运行，并将操作权返回给调用者。如果在main函数中，表示将操作权返回给操作系统，隐式调用exit。​如果return没有值就返回空，表示中断函数的执行，返回调用函数处。return是语言级别的，它表示了调用堆栈的返回； 理解复杂声明可用的\"右左法则\"：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。 分析下面的例子，答案见最后。 char * const * ( * next )(); char * ( * c [ 10 ]) int ( ** p ); 每个外部对象只在一个地方声明。这个声明的地方一般就在一个头文件中，需要用到该外部对象的所有模块都应该包括在这个头文件。特别注意：定义该外部对应的那个模块也应该包括这个头文件。 编译：生成目标平台的指令 -解释：在运行过程中才生成目标平台的指令。需要虚拟机来将编译后生成的中间代码翻译成目标平台的指令。 Interposition指用户定义的函数取代函数库中声明 完全相同的函数 ，不是重载. void mktemp () {..} void getwd () { mktemp ();} int main () { mktemp (); getwd (); // 即使库函数有 void mktemp(){}，操作系统也会调用用户自己定义的函数 return 0 ; } 链接库的五个特殊秘密 动态链接库的扩展名为 \".so\"，静态的为\".a\" 通过-lthread选项，告诉编译器链接到libthread.so 编译器期望在确定的目录下找到这些库函数 观察头文件，确定所使用的函数库 与提取动态库中的符号相比，静态库中的符号提取的方法限制更严格 动态库的优点： 动态链接可执行文件比功能相同的静态链接可执行文件的体积小。 所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。 关于库函数的使用，最好的用法就是尽量使用系统头文件。 预处理 宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。 宏定义中的空格不能忽视 #define f (x) ((x)-1） 的意思是f代表(x) ((x)-1而不是f(x)代表((x)-1 宏定义中出现的括号的作用是预防引起与优先级有关的问题。例如 #define abs(x) (((x)>=0)?:(x):-(x)) // 正确 #define abs(x) x>0?x:-x // 错误 abs(a-b)在错误的表达式中会展开为 a-b>0?a-b:-a-b 即使是用括号括起来也可能出错。 #define max(a,b) ((a)>(b)?(a):(b)) 在上面的表达式中，如果a大于b，那么a将会被求两次值，此时max(a++,b)就会产生错误的结果。 正确的做法如下： #define max(x, y) ({ typeof ( x ) _max1 = ( x ); typeof ( y ) _max2 = ( y ); ( void ) ( & _max1 == & _max2 ); // 当两个比较两个类型不同的变量的地址时,编译器会给出一个警告.提示我们在进行类型不同的比较. _max1 > _max2 ? _max1 : _max2 ; }) 前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果,编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误。 再看一个经典的例子 #define toupper(c) (( c ) >= 'a' && ( c ) <= 'z' ? ( c ) + ( 'A' - 'a' ) : ( c )) 这样做的原因是因为touppper(函数在调用时造成的系统开销要大大多于函数体内的实际计算操作。 动态语言和静态语言 通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。 动态类型语言：动态类型语言是指在 运行期间 才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言 静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在 编译期间 检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表 一般情况静态类型的语言运行速度要高于动态语言。 强类型定义语言和弱类型定义语言 强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言，可以有效的避免许多错误 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 Python是动态的强类型语言，C是静态的弱类型语言","tags":"编程","loc":"www.houcj.net/blog/2015/03/27/link-and-preprocess/","title":"链接和预编译"},{"text":"宏定义 一般情况下我们这样定义min宏 #define min(x,y) ((x) > (y) ? (y) : (x)) 但是当这样的宏执行： num = min ( a , b ++ ); 当编译时，宏展开后就是下面的代码 num = (( a ) > ( b ++ ) ? ( a ) : ( b ++ )) 这样b就会多加一次，下面是linux内核定义min宏的代码 #define min(x, y) ({ \\ typeof(x) _min1 = (x); \\ typeof(y) _min2 = (y); \\ (void) (&_min1 == &_min2); \\ _min1 < _min2 ? _min1 : _min2; }) (void) (&_min1 == &_min2); 这个语句的后半部分比较了两个变量的地址, 它的作用在于当两个比较两个类型不同的变量的地址时,编译器会给出一个警告. 提示我们在进行类型不同的比较.那么前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果, 编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误. 内存管理 虚拟内存通过 Page 的形式组织。Pages就是操作系统用于内存和磁盘之间移动或者进行保护的单位。Page in，Page out。磁盘上有个特殊的交换区来与内存进行交换。 进程只能操作位于屋里内存中的页面。 i = 0 ; while ( malloc ( 1 << 20 )) ++ i ; // to see the memory available in this process. printf ( \"Allocated %d MB total \\n \" , i ); cache cache 的类型 write-through cache : 每次写入cache时同时写入到内存，保持内存与cache的一致性。 write-back cache ： 当第一次写入时，只写入cache。如果已经写入过的cache行再次需要写入时，此时第一次写入的结果尚未保存，所以要先把它写入到内存中。当内存切换进程时，cache中所有的数据都要先写入到内存中。 line： 内存读取以行（32 bytes）为单位，整行的数据也会被装入到cache中。每行由两部分组成：一个数据部分以及一个标签，用于指定它所代表的地址。 block： 一个行内的数据块被称作块。块保存来回移动于Cache行和内存之间的字节数据。 -堆 堆区域用于动态 用于内存管理的调用是： malloc 和 free ------------从堆中获得内存以及把内存返回给堆 brk 和 sbrk --------------调整数据端的大小至一个绝对值。 堆中经常出现的两类问题： 释放或改写仍在使用的内存；（内存损坏） 未释放不再使用的内存；（内存泄露） 内存泄露的的检测： swap 观察交换区 netstat、vmstat等工具 对齐（alignment）：数据项只能存储在地址是数据项大小整数倍的内存位置上。数据项不能跨越页面或者cache边界 段（segment）错误原因： dereference Null pointer. int * p ; p = NULL ; * p ; 或者解引用一个包含非法值的指针。 p = malloc ( 256 ); p [ - 1 ] = 0 ; p [ 256 ] = 1 ; 在未得到正确的权限时进行访问。 const int i = 0 ; f (){ i = 1 ; // 表达式必须是可以修改的左值。 } 消耗完了堆栈或者堆空间。 C 语言中的运算规则 C语言中每个token应该尽可能多的包含更多的字符。如果编译器的输入流截止到某个字符之前已经被分解成一个个的token，那么从该字符之后应尽可能的组成一个最长的字符串的token。除了字符串与字符串常量，符号的中间不能嵌有空白（空格符、制表符，换行符）。 C语言中符号之间的空白将被忽略，这些符号包括空格符，制表符，换行符号： if ( a > b ) b = a ; if ( a > b ) b = a ; C语言变量的声明包括两部分：类型，以及声明符。 C语言运算符优先级 最高优先级包括：数组下标，函数调用操作符，各结构成员选择操作符。都是自左向右结合。 单目运算符的优先级仅次于最高级的运算符。单目运算符是自右向左结合。 双目运算符中，优先级为: 算术运算符 > 移位运算符 > 关系元算符 >逻辑运算符>赋值运算符>条件元算符 在所有的运算符中， 逗号 运算符的优先级最低。 C语言中，只有四种运算符存在规定的求值顺序（&&、||、?:、,）。运算符&&和||首先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符？：有三个操作数：在a？b:c中，操作数a首先别求值，根据a的值再求b后者c的值。而逗号操作符，首先对左侧操作数求值，然后该值被丢弃，再对右侧操作数求值。 C语言中常见的问题 如果一个整形常量的第一个字符是数字0，那么该常量将被视作八位数。譬如010会被当成十进制中的8。 在C语言中用单引号引起的字符所代表的是该字符ASCII码的整数值。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。 C语言中，每个case只有在遇到break时才会跳出switch语句。否则讲继续。 switch ( exp ) { case one : do something1 ; break ; case two : do something2 ; break ; default : do something3 : break ; } 如果strlen(s)的值是n，那么该字符串实际需要n+1个字符的空间，'\\0'作为结束标志。 char * p , * q ; p = \"xyz\" q = p ; p [ 0 ] = 'X' q [ 1 ] = 'Y' 复制指针并不同时复制指针所指向的数据，而是把指针所指向的地址复制给另一个指针。 int n = 4 ; int buffer [ n ] = { 1 , 2 , 3 , 4 }; int * bufptr = buffer ; int * p = buffer ; while ( n > - 1 ) { if ( bufptr == & buffer [ 4 ]) { printf ( \"Work well ! \\n \" ); break ; } * bufptr ++ = * p ++ ; n -= 1 ; } 所以上面的代码执行后，p，q共同指向字符串\"XYz\" - 当常量被转换为指针使用时，这个指针绝对不能解引用，即不能使用该指针所指向内存中的存储内容。ANSI规定：数组中实际不存在的溢界元素的地址位于数组所占用内存之后，这个地址可以用于进行赋值比较。但是不能引用该地址的元素。 类型提升：在表达式中，每个char类型都被转换为int，float都会转换为double。由于函数参数也是一个表达式，所以当参数传递给函数时也会发生类型转换。 整型提升：char、short int和位段类型（signed，unsigned）以及枚举类型将被提升为int，前提是int类型能够完整地容纳原先的数据，否则讲会被转换为 unsigned int。 X = Y Left Value（左值）: 表示存储结果的地方. X 代表存储的地址。 Right Value（右值）: Y中的内容 数组名是不可修改的左值 ，只有可修改的左值才能被赋值。 a +++++ b ; 由于编译器的中最长匹配的原则，上式会被翻译为 a ++++ + b ; //即 (( a ++ ) ++ ) + b ; 而 a++ 不能作为左值， 因为a++返回的是自身的值副本。因此上面的表达式是错误的。 C语言里函数的参数默认是从右往左处理的，输出时是从左往右。 #include<stdio.h> int main ( void ) { int a = 10 , b = 20 , c = 30 ; printf ( \" \\n %d..%d..%d \\n \" , a + b + c , ( b = b * 2 ), ( c = c * 2 )); return 0 ; } 答：输出结果是： 110..40 . .60 void*和C结构体 设计一个能接受任何类型的参数并返回interger（整数）结果的函数 答：如下： int func ( void * ptr ) 如果这个函数的参数超过一个，那么这个函数应该由一个结构体来调用， 这个结构体可以由需要传递参数来填充。 - 大端和小端 （数据在内存中的字节排列顺序） - 大端：最低位置存放高位字节，高位优先。 - 小端：最低位置存放低位字节，地位优先。 'NUL'和'NULL'的区别 一个'L'的'NUL'用于结束一个ASCII字符串。 两个'L'的'NULL'用于表示什么也不指向（空指针） C中的关键字： extern：用于变量，表示在其他地方（文件）定义。用于函数定义，表示全局可见，即可被任意文件内的函数访问。 const：相当于read only static：在函数内部，表示该变量的值在各个调用一直保持持续性。 联合（Union）和结构体（Struct） 一个联合的总的大小等于它的最大字段的大小 如果我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，以减少分配空间的总量。","tags":"编程","loc":"www.houcj.net/blog/2015/03/03/the-basic-knowledge-in-c/","title":"The basic Knowledge in C"},{"text":"线程安全 一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会产生一直产生正确的结果。 四个线程不安全函数类 不保护共享变量的函数 对一个未受保护的全局计数器变量加1. 改进：利用像P和V操作这样的同步操作来保护共享的变量。 优点，在调用程序中不需要做任何修改 缺点，同步操作讲减慢程序的执行时间 保护跨越多个调用的状态的函数 unsigned int next = 1 ; int rand ( void ) { next = next * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } void srand ( unsigned int seed ) { next = seed ; } 改进方法重写，使得它不再使用任何static数据，而是依靠调用者在参数中传递状态信息。 int rand_r ( unsigned int * nextp ) { * nextp = * nextp * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } 缺点，被迫修改调用程序中的代码。 返回指向静态变量的指针的函数。 改进方法，加锁-拷贝（lock-copy）技术。基本思想是将线程不安全函数与互斥锁联系起来。在每一个调用位置，对互斥锁解锁，调用线程不安全函数，讲函数返回的结果拷贝到一个私有的存储器位置，然后对互斥锁解锁。 char * ctime_ts ( const time_t * timep , char * privatep ) { char * sharedp ; P ( & mutext ); sharedp = ctime ( timep ); strcpy ( privatep , sharedp ); V ( & mutex ); return privatep ; } 调用线程不安全函数 改进方法，lock-copy","tags":"编程","loc":"www.houcj.net/blog/2015/02/27/multi-thread/","title":"多线程"},{"text":"一、大型网站构架演化发展历程 应用服务和数据服务分离 使用缓存改善网站性能 使用应用服务器集群改善网站的并发处理能力 数据库读写分离 使用反向代理和CDN加速网站响应 CDN部署在网络提供商的机房，使用户可以从最近的网络提供商机房获取数据 方向代码里部署在网站的中心机房，反向代理服务器中缓存着用户的请求资源。 使用分布式文件系统和分布式数据库系统 使用NoSQL和搜索引擎 业务拆分 分布式服务 网站架构模式 分层 分层就是将系统在横向纬度上切分成几个部分，每个部分负责一部分相对比较单一的 指责，然后通过上层对下层的依赖和调用组成一个完整的系统 层次 内容 应用层 具体业务和视图展示，如网站首页及搜索输入和结果展示 服务层 为应用层提供服务支持，如用户管理服务 数据层 提供数据存储访问服务，如数据库、缓存、文件、搜索引擎 分割 分割就是在纵向方面对软件进行切分，将不同的业务进行分割，包装成高内聚 低耦合的模块单元，有利于软件的开发和维护，同时也提供网站的并发处理能力 和功能扩展能力。 分布式 分布式意味着，可以使用更多的计算机完成同样的功能，将分成和分割的模块独立 部署。 集群 对于用户访问集中的模块，如网站首页，需要将独立部署相同应用 构成一个集群，通过负载均衡设备共同对外提供服务。 缓存 缓存就是将数据存放在距离计算最近的位置以加快处理速度。一般包括 CDN、反向代理、本地缓存、分布式缓存。使用缓存有两个条件，一是数据访问热点不均衡，而是数据在某个时间段内有效，不会 很快过期。 异步 业务之间的消息传递不是同步调用，而是将一个业务操作分成多个阶段，每个 阶段之间通过共享数据的方式一步执行进行协作。 在单一服务器内部，可通过多线程共享内存队列的方式实现异步，处在业务 操作前面的线程将输出写入到队列，后面的线程从队列中读取数据进行处理。在分布式 系统中，多个服务器集群通过分布式消息队列实现异步，分布式消息队列可以看作 内存队列的分布式部署。 冗余和自动化 数据库从了定期备份，存档保存，实现冷备份外，为了保证在线业务高可用，还需要对 数据库进行主从分离，实时同步实现热备份。 自动化代码管理，自动化测试，自动化安全检测，自动化部署，自动化监控 和报警，自动化失效转移，恢复，自动化降级，自动话分配资源。 安全 xss攻击，sql注入。 二、软件架构 软件架构就是有关软件整体结构与组件的抽象描述，用于指导大型软件系统各个方面的 设计。 一般说来，除了当前的系统功能需求，软件架构还需要关注性能、可用性、伸缩性、 扩展性、安全性这5个架构要素，架构设计过程中需要平衡这5个要素之间的关系以实现需求和架构目标， 也可以通过考察这些架构要素来衡量一个软件架构设计的优劣，判断其是否满足期望。 1、性能 在浏览器端可以，可以通过浏览器缓存、使用页面压缩、合理布局页面、 减少Cookie传输等手段改善性能。 在应用服务器端，可以使用服务器本地缓存和分布式缓存，通过缓存在 内存中的热点数据处理用户请求，加快请求处理过程，减轻数据库负载压力。 以及使用异步操作和CDN等缓存操作。 在代码层面可以使用多线程、改善内存管理手段优化性能。 在数据库服务器端，索引、缓存、SQL优化，以及使用NoSQL。 衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过这些指标以确定系统设计是否达到目标 可用性 网站高可用的主要手段是冗余，应用部署在多台服务器上同时提供访问，数据存储在多态服务器相互备份， 任何一台服务器宕机都不会影响应用的整体可用，也不会导致数据丢失。 衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种 不可预期的问题时，系统整体是否依然可用 伸缩性 伸缩性就是通过不断向及群众加入服务器的手段来缓解不断上升的用户并发访问压力和不断增长的 数据存储需求。 衡量架构伸缩性的主要标准就是是否可以用多台服务器构建集群，是否容易向集群中添加新的服务器.加入 新的服务器后是否可以提供和原来无差别的服务.集群中容纳的总的服务器数量是否有限. 对于应用服务器集群,通过使用合适的负载均衡设备就可以向及群众不断加入服务器. 对于缓存服务器集群,加入新的服务器可能会导致缓存路由失效,因此需要改进缓存路由算法保证缓存数据的 可访问性. 关系数据库支持数据复制,主从热备等机制,但很难做到大规模的可伸缩性,因此需要通过路由分区等手段将部署 有多个数据库的服务器组成一个集群. 扩展性 衡量网站扩展性好坏主要标准就是在网站增加新的业务产品时，是否可以实现对现有 产品透明无影响，不需要任何改动或者很少改动既有业务功能就可以上线新产品。不同产品 之间是否很少耦合， 一个产品的改动是否有影响，其他产品和功能不需要受牵连 进行改动。 网站可扩展架构的主要手段是事件驱动架构和分布式服务。 事件驱动架构在网站中通常利用消息队列实现，将用户请求和其他业务事件构造成消息发布到消息队列， 消息的处理者作为消费者从消息队列中获取消息进行处理，这样就把消息产生和消息处理分离开来 分布式服务则是将业务和可复用服务分离开来,通过分布式服务框架调用,新增产品可以通过调用可服用的服务 实现自身的业务逻辑,而对现有产品没有任何影响. 安全性 衡量网站安全架构的标准就是针对现存和潜在的各种攻击与窃密手段,是否有可靠的应对策略. 三、瞬时相应:网站的高性能架构 网站性能测试 一、性能响应指标 1、相应时间 指应用执行一个操作需要的时间，包括从发出请求开始到收到最后相应数据所需的时间。响应时间是系统最终哟啊的性能指标， 直观反应了系统的快慢。 2、并发数 指系统能够同时处理请求的数目，这个数字反应了系统的负载特性。 3、吞吐量 值单位时间内系统处理的请求数量，体现系统的整体处理能力。 4、性能计数器 它是描述服务器活操作系统性能的一些数据指标，包括system load、对象与线程数、内存使用、CPU使用、磁盘与网络 I/O等指标。 二、性能测试 性能测试是一个总称，具体可细分为性能测试、负载测试、压力测试、稳定性测试。 Web 前端性能优化 一、浏览器访问优化 1、减少http请求 减少http请求的主要手段是合并CSS、合并javascript、合并图片.如果每张图片都有不同的超连接,可通过CSS偏移响应 鼠标点击操作,构造不同的URL。 2、使用浏览器缓存 对于一些静态资源文件，可以通过设置HTTP头中Cache-Control和Expires属性来设定浏览器缓存。当这些静态资源发生 变化时，要通过改变文件名实现，即生成一个新的JS文件并更新HTML文件的引用，同时使用浏览器缓存策略的网站 在更新静态资源时，应采用逐量更新的方法，以免用户浏览器突然大量缓存失效，集中更新缓存，造成服务器 3、启用压缩 在服务器端对文件进行压缩，在浏览器端对文件解压缩，可有效减少通信传输的数据量。文本文件的压缩效率可达80%以上， 因此HTML、CSS、JavaScript文件启用 GZip 压缩可达到较好的效果。 4、CSS放在页面最上面、JavaScript放在也买年最下面 浏览器会在下载完全部CSS之后对整个页面进行渲染，因此最好的做法是将CSS放在页面最上面，让浏览器尽快下载CSS。 浏览器在加载JavaScript后立即执行，有可能会阻塞整个页面。 5、减少Cookie传输 Cookie包含在每次请求和响应中，太大的Cookie会严重影响数据传输，因此应尽量减少Cookie中传输的数据量。另一方面 对于静态资源的访问，可以考虑使用独立域名访问，避免请求静态资源时发送Cookie. 二、CDN加速 CDN的本质是一个缓存，而且将数据缓存在离用户最近的地方，是用户以最快的速度获取数据. 三、反向代理 反向代理位于网站机房一侧，代理网站web服务器接收HTTP请求。反向代理服务器具有保护网站安全的作用，同时代理 服务器也可以通过配置缓存功能加速web请求。方向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以 提高系统总体处理能力，进而改善网站高并发情况下的性能。 应用服务器性能优化 应用服务器就是处理网站业务的服务器，网站的业务代码都在这里。优化的主要手段有分布式缓存、集群、异步。 分布式缓存 网站性能优化第一定律：优先考虑使用缓存优化性能。 1、缓存的基本原理 一方面，缓存中的访问速度一般都很快。另一方面，如果缓存中的数据是经过计算处理得到的，那么被缓存的数据无需要重复 计算即可直接使用，缓存还起到减少计算时间的作用。 缓存的本质是Hash表，数据以Key、Value的形式存储在Hash表中，Hash表数据读写的时间复杂度都是O（1）.缓存能够很高效的 原因就是网站数据访问通常遵循二八定律,因此利用Hash表和内存的告诉访问特性,可以很好的改善系统性能. 2、合理使用缓存 一般数据的读写比例在2:1以上,缓存才有意义. 通过分布式缓存服务器集群,将缓存数据分布到集群多台服务器上可在一定程度 上改善缓存的可用性. 缓存预热 ：缓存中存放的是热点数据，热点数据又是缓存系统利用LRU对不断访问的数据筛选淘汰出来的。新启动的缓存 系统如果没有任何数据，在重建缓存数据的过程中，系统的性能和数据库负载都不太好， 那么最好在 缓存系统启动时就把热点数据加在号，这个缓存预加载手段叫做缓存预热。 3、分布式缓存架构 分布式缓存指缓存部署在多个服务器组成的集群中，以集群方式提供缓存服务，其架构方式有两种， 一种是以JBoss Cache为代表的需要更新同步的分布式缓存，一种是以Memcached为代表的 不互相通信的分布式缓存。 JBoss Cache 的分布式缓存在集群中所有服务器中保存相同的缓存数据，当某台服务器有缓存数据更新的 时候，会通知集群中其他机器更新缓存数据或清除缓存数据。由于海量数据的缓存的同步代价过大，因此 这种方案多见于企业应用系统中。 Memcached Memcached采用一种集中式的缓存集群管理，缓存与应用分离部署，缓存系统部署在一组专门的服务器上，应用 程序通过一致性Hash等路由算法选择缓存服务器远程访问缓存数据。 简单的通信协议 ：远程通信需要考虑两方面的问题，一是通信协议，如TCP，另一种是通信 序列化协议，数据传输的两端，必须使用彼此可识别的数据序列化方式才能使通信得以完成，如JSON等 稳步呢序列化协议。Memcached使用TCP协议通信，其序列化是哦i一个命令关键字开头，后面是一组 命令操作数。如读取一个数据的命令协议是get 高性能的网络通信 ，Memcached服务端通信模块基于Libevent。 高效的内存管理 ，内存管理的一个最大问题就是碎片，操作系统在垃圾回收方面做了很多工作：压缩，复制。Memcached使用 固定空间分配。 代码优化 多线程 使用多线程的原因主要有两个：I/O阻塞与多CPU. 一台服务器上启动多少线程合适? 启动线程数 = [任务执行时间/（任务执行时间 - IO等待时间）*CPU内核数] 资源复用 资源复用主要有两种模式：单例和对象池。 目前Web开发主要使用贫血模型，从Service到Dao都是些无状态对象，无需重复创建，因此很自然的使用单例。 对象池模式通过服用对象实例，减少对象创建和资源消耗。常用的连接池、线程池，本质上都是对象，池管理方式也基本相同。 数据结构 目前比较好的字符串Hash散列算法是Time33算法，即对字符串逐字符迭代乘以33，求得Hash值，算法原型为： \\begin{equation*} hash(i) = hash(i-1)*33 + str[i] \\end{equation*} Time33可以很好的解决冲突，但是相似的字符串的HashCode也可能比较相似。如‘AA'的HashCode是2210，字符串‘AB'的HashCode是 2211.一个可行的解决方案是，先用MD5对字符串提取质问，然后再对信息指纹求HashCode。 存储优化 B+树 vs LSM 树 B+树 是一种专门针对磁盘存储而优化的N叉排序树，以额点为单位存储在磁盘中，从根开始超早所需数据所在的节点编号和 磁盘位置，将其加载到内存中然后继续查找，直到找到所需的数据。目前数据库多采用两级索引的B+树，树的层次最多三层。 因此可能需要5次磁盘访问才能更新一次记录（三次磁盘访问获取数据索引及行ID，然后再进行一次数据文件读操作，及 一次数据文件写操作）。 LSM树 可以看作是一个N阶合并树。数据写操作都在内存中进行，并且会创建一个新纪录，这些数据在内出那种仍然是一棵排序树， 当数据量超过设定的内存阈值后，会将这棵排序树和磁盘上最新的排序树合并。当这棵排序树的数量也超过阈值后，和磁盘上下一级的 排序树合并。合并过程用最新的数据覆盖旧的数据。在LSM树上进行一次数据更新不需要磁盘访问，在内存中即可完成，因此当数据访问的 写操作大于读操作时，LSM可以加快访问速度。 RAID RAID 0：并发写入N块磁盘 RAID 1：将一份数据同时写入两块磁盘 RAID 10：将数据并发写入N/2块磁盘，另外一块磁盘作为备份 RAID 5：数据并发写入N-1块磁盘，螺旋式写入另外一块磁盘 四、万无一失：网站的高可用（Availiablity）架构 高可用的网站架构 实现高可用架构的主要手段是数据和服务的冗余备份以及失效转移。位于应用层的服务器通常为了应对高并发的访问请求， 会通过负载均衡设备将一组服务器组成一个集群共同对外提供服务，当负载均衡设备通过心跳检测等手段监控到某台应用 服务器不可用时，就将其从集群列表中删除，并将请求分发到集群中其他可用的服务器上，使整个集群保持可用，从而实现应用 高可用。 高可用的应用 应用层主要处理网站应用的业务逻辑，应用的一个显著特点是应用的无状态性，无状态的应用是指应用服务器不保存业务的 上下文信息，而仅根据每次请求提交的数据进行相应的业务逻辑处理，多个服务实例之间完全对等，请求提交到任意服务器， 处理结果都是完全一样的。 应用服务器集群的Session管理 利用独立部署的Session服务器集群统一管理Session，应用服务器每次读写Session时，都访问Session服务器。这种解决 方案事实上是将应用服务器的状态分离，分为无状态的应用服务器和有状态的Session服务器，然后针对这两种服务器的不同 特性分别设计其架构 高可用的数据 CAP原理 CAP原理认为，一个提供数据服务的存储系统无法同时满足数据一致性（Consisitency），数据可用性（Avalibility）， 分区耐受性（Partition Tolerance，系统具有跨网络分区的伸缩性）。在大型网站中，通常选择强化A和p，而在某种程度 上放弃C。 数据备份 数据热备份可分为两种：异步热备方式和同步热备方式。 在异步写入方式下，存储服务器分为主存储服务器（Master）和从存储服务器（Slave），应用程序正常情况下值连接主存储服务器 ，数据写入时，由主存储服务器的写操作代理模块将数据写入本机存储系统后立即返回写操作成功响应，然后通过异步线程将写操作 同步到从存储服务器。实践中，通常使用读写分离的方法， 写操作至访问Master数据库，读操作只访问Slave数据库。 失效转移 系统确认一台服务器是否宕机的手段有两种，心跳检测和应用程序访问失败报告。对于应用程序的访问失败报告，控制中心还需要再发送心跳检测进行确认，以免错误判断 服务器宕机。 代码控制 目前网站应用开发中主要使用的是分支开发，主干发布的方式。即任何修改都不得在主干上直接进行，需要开发一个新功能，或者修复一个bug时，从主干 拉一个分治进行开发，开发完成且测试通过后，合并回主干，然后从主干进行发布，主干上的代码永远是最新发布的版本。 自动化发布 火车发布模型：将每个应用的发布过程看作一次火车旅程，火车定点运行，期间有若干站点，每一站都进行例行检查，不同的项目下车，剩下的项目继续 作者火车旅行，直到火车到达重点。这个火车发布模型是基于规则驱动的流程，所以这个流程可以自动化。目前比较流行的Web自动化测试工具是ThoughtWorks 开发的Selenium。 灰度发布 灰度发布将集群服务器分成若干部分，每天只发布一部分服务器，观察运行稳定没有故障再发布另一部分服务器，期间如果有问题，只需要回滚已发布的一部分 服务器即可。灰度发布也常用于用户测试，别称为AB测试。 网站监控 目前网站使用比较广泛的开源性能监控工具是Ganglia，它支持大规模服务器集群，并支持以图形的方式在浏览器展示实时性能曲线。 五、永无止境：网站的伸缩性架构 负载均衡 HTTP重定向负载均衡 HTTP重定向服务器唯一的功能就是根据用户的HTTP请求计算一台真是的Web服务器地址，，并将该Web服务器地址写入HTTP重定向响应中（响应状态码302）， 返回给用户浏览器。缺点是浏览器需要两次请求才能完成一次访问，性能较差；重定向服务器自身的处理能力有可能称为瓶颈。 DNS域名解析负载均衡 在DNS服务器中配置多个A记录，每次域名解析请求都会根据负载均衡算法计算一个不同的IP地址返回，这样A记录中配置多个服务器就构成一个集群， 并可以实现负载均衡。目前的DNS是多级解析，每一级DNS都可能缓存A记录，当下线某台服务器，需要较长的更新时间。目前常用的方面是使用DNS作为第一级负载均衡，即将域名解析为提供负载均衡服务的内部服务器。 反向代理负载均衡 反向代理服务器管理一组Web服务器，将请求根据负载均衡算法转发到不同的Web服务器上。Web服务器处理完成的响应也需要通过反向代理代理服务器返回给用户。 因此反向代理服务器需要配置双网卡和内部外部两套IP地址。 由于反向代理服务器转发请求在HTTP协议层面，因此也叫应用层负载均衡。缺点是反向代理服务器是所有请求和响应的中转站，其性能可能成为瓶颈。 IP负载均衡 在网络层通过修改请求目标地址进行负载均衡。 IP负载均衡的关键在与真实物理Web服务器响应数据包如何返回给负载均衡服务器。一种方案是负载均衡服务器在修修改目的同时修改源地址，将数据包源地址设为 自身IP，即源地址转换。另一种方案是将负载均衡服务器同时作为真实物理服务器集群的网关服务器，这样所有响应数据都会到达负载均衡服务器。 数据链路层负载均衡 数据链路层负载均衡是指在通信协议的数据链路层修改mac地址进行负载均衡。 这种数据传输的方式又称为三角传输模式，负载均衡数据分发过程中不修改IP地址，只修改目的的mac地址。这种负载均衡方式又被称为直接路由方式。使用三角 传输模式的链路层负载均衡是目前大型网站使用最广的一种负载均衡手段。在Linux平台上最好的链路层负载均衡开源产品是LVS(Linux Virtual Server)。 负载均衡算法 负载均衡服务器的实现可以分为两个部分: 1. 将请求数据发送到该地址对应的web服务器上 2. 根据负载均衡算法和Web服务器列表计算得到集群中一台Web服务器的地址。 具体的算法有：轮询（Round Robin），加权轮询（Weighted Round Robin），随机（Random），最少连接（Least Connections），源地址散列 （Source Hashing）：根据请求来源的IP地址进行Hash计算，得到应用服务器，这样来自同一个IP地址的请求总在同一个服务器上处理，该请求的上下文信息 可以存储在这台服务器上，在一个会话周期内重复使用，从而实现回话粘滞。 分布式缓存集群的伸缩性设计 分布式缓存集群伸缩性设计的最主要目标就是使新加入缓存 服务器后的整个缓存服务器集群中已经缓存的数据尽可能还被访问到。 一致性Hash算法 一致性Hash算法通过一个叫做一致性Hash环的数据结构实现Key到缓存服务器的Hash映射。 具体算法过程为：先构造一个长度为2&#94;32的整数环（这个环被称做一致性Hash环），根据节点 名称的Hash值将缓存服务器节点放置在这个Hash环上。然后根据需要缓存的数据 的Key计算得到其Hash值，然后在Hash环上顺时针查找距离这个Key的Hash值最近的缓存服务器节点， 完成Key到服务器的Hash映射查找。具体应用中，这个Hash环通常是使用二叉查找树实现， Hash查找过程实际上是在二叉查找树中查找不小于查找数的最小数值。当然这个二叉树的最右边叶子节点和最左边的叶子节点相连接，构成环。 但是上述算法有个缺点就是可能造成节点负载的不均衡。 计算机的任何问题都可以通过增加一个虚拟层来解决 ，因此解决上述问题的 方法就是使用虚拟层的手段：将每台物理缓存服务器虚拟为一组虚拟缓存服务器，将虚拟服务器的Hash值放置在Hash环上，Key在环上先找到 虚拟服务器节点，再得到物理服务器的信息。虚拟节点的经验值为150. 数据存储服务器集群中的伸缩性设计 关系数据库集群： Cobar，相当于在应用程序与数据库之间加了一个调度的中间层。Cobar服务器集群的伸缩可用简单的负载均衡即可，MySQL要想保持集群扩容后数据 一致，可使用一致性Hash算法。 NoSQL数据库集群： Apache HBase。 六、随需应变:网站的可扩展架构 扩展性是指在系统影响最小的情况下，系统功能可持续扩展或提升的能力。它是系统架构设计层面的开闭原则，对扩展开放，对修改关闭。 设计网站可扩展架构的核心思想是模块化，并在次基础上，降低模块间的耦合性，提供模块的复用性。 利用分布式消息队列降低系统耦合性 事件驱动架构 事件驱动架构：通过在低耦合的模块之间传输事件消息，以保持模块的松散耦合，并借助事件消息的通信完成模块间合作，典型的 EDA架构就是操作系统中常见的生产者消费者模式，在大型网站中，最常用的是分布式消息队列。 分布式消息队列 队列是以中先进先出的数据结构，分布式消息队列可以看作将这种数据结构部署在对立的服务器上，应用程序可以通过远程访问接口使用 分布式消息队列，进行消息存取操作，进而实现分布式的异步调用。 利用分布式服务打造可复用的业务平台 分布式消息队列通过消息对象分解系统耦合性，不同子系统处理同一消息，而分布式服务通过借口分解系统耦合性，不同子系统通过相同的接口 描述进行服务调用。 解决方案就是拆分，将模块独立部署，降低系统耦合性。拆分可分为纵向拆分和横向拆分。 纵向拆分：将一个大应用拆分为多个小应用，如果新增业务比较独立，那么就直接将其设计部署为一个独立的Web应用系统。 横向拆分：将复用的业务拆分出来，独立部署为分布式服务，新增业务只需要调用这些分布式服务，不许哟啊依赖具体的模块代码，即可 快速搭建一个应用系统，而模块内业务逻辑变化的时候，只要接口保持一致就不会影响业务程序和其他模块。 可扩展的数据结构 传统的关系数据库需要指定表的schema（字段名称，数据类型，并遵循特定的设计方式），这样无法做到很好的扩展性。那么 如何才能无需改变表结构就可以新增字段呢？NoSQL数据库使用的ColumnFamily设计就是一个解决方案，它是一种面向列族的稀疏 矩阵存储格式。创建表的时候，只需要指定ColumnFamily的名字，无需指定字段（Column），可以在数据写入时在指定，这样就可以使得 应用程序的数据结构可以随意扩展。 七、固若金汤：网站的安全架构 网站应用攻击与防御 全球大约70%的Web应用攻击来自XSS攻击和SQL注入攻击。此外还有CSRF、Session劫持等手段。 XSS攻击 XSS（Cross Site Script）即跨站点脚攻击，指黑客通过篡改网页，注入恶意HTML脚本，在用户浏览网页时，控制用户 浏览器进行恶意操作的一种攻击方式 常见的XSS攻击有两种，反射型：攻击者诱使用户点击一个嵌入恶意脚本的链接，达到攻击的目的；持久型：黑客提交含有恶意脚步呢的请求，保存 在被攻击的Web站点的数据库中，用户浏览网页是，恶意脚本被包含在正常页面中，达到攻击的目的。 常见的防御手段有：消毒：对某些html危险字符转义，如\">\"转义为\"&gt\"，\"<\"转义为\"&lt\"；Httponly：浏览器禁止也买年JavaScript访问 带有HttpOnly属性的Cookie，防止xss攻击窃取Cookie； 注入攻击 注入攻击主要有两种形式，SQL注入和OS注入攻击。SQL攻击的原理是攻击者在HTTP请求中注入恶意SQL命令（drop table users），服务器 请求参数构造数据库SQL命令时，恶意SQL被一起构造并在数据库中执行。 使用预编译手段，绑定参数是最好的防SQL注入方法，攻击者的恶意SQL会被当作SQL的参数，而不是SQL命令。 CSRF攻击 CSRF（Cross Site Request Forgery）攻击者通过跨站请求，以合法用户的身份进行非法操作，CSRF的主要手法是利用跨站请求，在 用户不知情的情况下，以用户身份伪造请求。核心是利用了浏览器Cookie或服务器Session策略，盗取用户身份。 主要的防御手段是：表单Token（在页面表单中增加一个随机数为Token，每次响应页面的Token都不相同，从正常的页面提交的请求包含该Token）， 验证码，Referer check（HTTP请求头的Referer域中记录着请求源，可检查请求来源，验证其是否合法，可以实现图片防盗链） if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2014/12/22/architecture/","title":"大型网站技术架构"},{"text":"Markdown简介 Markdown遵循易写易读的设计理念，通过一些符号的标记来 插入图片 行内式的图片链接语法： ! [ Alt text ]( / path / to / img . jpg \"Optional title\" ) HTML 语法 <img src=\"/path/to/img.png\" class=\"img-responsive\" alt=\"Optional title\" align=center /> 插入表格 使用( : )来进行对齐，下面分别是左对齐，居中，右对齐。 | Write | the | code | |:- -------- |:- --------: | ---------: | | first | second | third | | 1 | 2 | 3 | 效果 A B C first second third 1 2 3 引用 使用 ( > )来进行引用 > Life is short, you need python! 效果 Life is short, you need python! 超链接 使用 [Github](https:/github.com/chaojunhou) 效果 Github 代码 使用( ``` )来把代码块包括起来，后面加上相应的语言可以高亮。 ```python print 'Hello World!' ``` 效果 print 'Hello World!' 转义字符 在不希望被转义的字符前加上( \\ )即可","tags":"编程","loc":"www.houcj.net/blog/2014/09/06/markdown/","title":"Introduction to Markdown"},{"text":"AWK AWK is a language for processing text files. A file is treated as a sequence of records, and by default each line is a record. Each line is broken up into a sequence of fields, so we can think of the first word in a line as the first field, the second word as the second field, and so on. An AWK program is of a sequence of pattern-action statements. AWK reads the input a line at a time. A line is scanned for each pattern in the program, and for each pattern that matches, the associated action is executed — Alfred V. Aho 基本语法 condition '{action}' 其中单引号中被大括号括起来的就是awk语句。只能用单引号 awk '{print $10 }' file.txt 内置变量 NR : Keeps a current count of the number of input records . NF : Keeps a count of the number of fields in an input record . The last field in the input record can be designated by $NF . FILENAME : Contains the name of the current input - file . FS : Contains the \"field separator\" character used to divide fields on the input record . The default , \"white space\" , includes any space and tab characters . FS can be reassigned to another character to change the field separator . RS : 输出字段分隔符， 默认为换行符。 OFS : 输出字段分隔符， 默认是空格符。 ORS : 输出字段分隔符， 默认是换行符。 $n 表示第 n 列， $0 表示整行 OFMT : Stores the format for numeric output . The default format is \"%.6g\" . 指定分隔符 awk 'BEGIN{FS=' : '} {print $0}' file.txt 等价于 awk -F: '{print $0}' file.txt 如果有多个分隔符，可以 awk -F '[;:,]' 使用OFS参数就可以改变输出分割符。 awk -F: '{print $0}' OFS = \"\\t\" file.txt 字符串匹配 有效的电话号码 awk '/&#94;([0-9]{3}-|\\([0-9]{3}\\) )[0-9]{3}-[0-9]{4}$/' file.txt //中是匹配的pattern，遵循正则表达式的语法。 字符串连接操作 awk字符串转数字 awk 'BEGIN{a=\"1\";b=\"2\";print (a+b+3);}' # output is 6 + 连接运算自动把字符串转为整数类型 awk字符串连接 awk 'BEGIN{a=\"a\";b=\"b\";c=a\"\"b;print c}' 将变量与\"\"连接起来即可。 用户自定义函数 计算单词的频率 BEGIN { FS = \"[&#94;a-zA-Z]+\" } { for ( i = 1 ; i< = NF ; i++ ) words [ tolower ( $i )] ++ } END { for ( i in words ) print i, words [ i ] } BEGIN｛执行之前的语句｝ ｛处理每一行要执行的语句｝ END｛处理完所有的行后要执行的语句｝ sed sed是用来解析和转换文本文件的简单的编程语言，尤其擅长 替代操作。 Sed editing Commands 这些编辑命令和vim编辑器的比较类似 sed 'm,ns/regexp/replacement/g' inputFileName > outputFileName # 如果是特殊字符,需要使用\"\\\"进行转义，如果特殊字符里包含单引号，需要使用双引号 sed \"m,ns/regexp/replacement/g\" inputFileName > outputFileName sed 'm,ns/regexp/replacement/mg' inputFileName > outputFileName # only replace the replacment from the mth. m,n分别代表第m，n行的文本。 s 代表替换操作， g 代表是全局替换。 特别地 sed 's/&#94;/repalcement/g' inputFileName # add the replacment charater to the front sed 's/$/repalcement/g' inputFileName # add teh replacment charater to the end 原地替换 sed -i 's/regexp/replacement/g' inputFileName 使用圆括号匹配 使用圆括号括起来的正则表达式所匹配的字符串可以当成变量来使用，sed 使用的是\\1\\2... sed 's/the line in the file \\(pattern1\\), and \\(pattern2\\)/\\1:\\2/g' a编辑命令i编辑命名c编辑命令 a命令：append text below current line sed 'na appendString' filename # na 表示在第n行以后进行append，如果n超过filename的行数，就不进行任何操作 sed '/pattern/a appendString' filename # 在匹配到pattern以后就append一行 i命令：insert text above current line 具体操作同a命令 c命令：change text in the current line with new text 具体操作同a命令 d编辑命令 删除匹配行 sed '&#94;,$,d' filename # 删除文件的内的所有行 p编辑命令 打印命令，单独使用会打印两遍处理的和sed -n 配合使用相当于grep命令 sed -n '1,/pattern/p' filename # 从第一行打印到匹配fish成功的那一行 sed options sed -f 当有大量的sed命令时，可以把这些sed命令放到一个文件中（每条命令都需要 单独成行）,可以然后使用下面的命令 sed -f sedscript filename # or the long version sed -file = sedscript filename sed -n Silent mode，suppresses automatic printing of lines， 即只打印匹配pattern的行。 sed -e 当有多个匹配的时候，可以使用下面的命令 sed -e 's/regexp1/replacement1/g' -e 's/regexp2/replacement2/g' inputFileName sed -r 支持扩展的正则表达式 sed -n -r '/regex/p' filename # 匹配file里所有符合regex的文件行 sed Hold Space 上面的命令几乎都遵循这样的格式 [address[,address]][!]{cmd} 其中 ！ 表示匹配成功后是否执行。 同时，如果cmd有多个，可以用分号分开，用大括号括起来作为嵌套命令。 sed 'm,n {/pattern1/{/pattern2/d}}' filename # 对第m行到n行，先匹配pattern1，在匹配pattern2，然后执行d删除命令 下面具体介绍 Hold space h H : copy/append pattern space to hold space. g G : copy/append hold space to pattern space. n N : Read/append the next line of input into the pattern sapce. 当sed逐行读取文件的时候，这些 已经被读取的文件行就放到pattern buffer（pattern space）里。Pattern buffer相当于一个缓存，当你 用sed进行输出的时候，它会输出pattern buffer的内容。 Hold buffer/hold space 相当于一个长久的存储。一般情况我们 不会直接处理hold buffer的内容，当需要处理的时候我就会把hold buffer的 内容copy到pattern buffer里进行处理. sed -n '1!G;h;$p' # 和tac的功能一样，print the file in reverse tail & head head:print the first part of a file tail:print the last part of a file tail & head options head|tail -q : 隐藏文件名 head|tail -v : 显示文件名 head|tail -c <m> : 显示字节数 head|tail -n <m> : 显示行数 wc wc 是用来读取标准输入输出文件中的行数，单词数目。如果有多个文件时 单个文件和综合的统计都会输出。 用法 wc -l print the line count (note that if the last line does not have \\n, it will not be counted) wc -c print the byte count wc -m print the character count wc -L print the length of longest line wc -w print the word count sort sort对文本文件的line进行排序 用法 sort -n The -n option makes the program sort according to numerical value sort -k The -k option makes the program sort using the k column of data sort -r The -r option just reverses the order of the sort sort -u The -u option with -c, check for strict ordering; without -c, output only the first of an equal run cut cut是用于获取文件的line中的指定部分。 用法 cut -c 以charactor为单位 cut -b 以byte为单位 cut -d \":\" 指定分隔符，默认为tab cut -n Used in combination with -b suppresses splits of multi-byte characters cut -fn 截取第n个section tr tr (translate) or delete character tr 语法 tr [-cds] [string1 [string]] tr -c : complement the set of characters in string1 with respect to the universe of characters whose ASCII codes are 01 through 0377 tr -d : delete all input characters in string1 tr -s : squeeze all strings of repeated cut cut 别用来提取文件行中的特定部分。 cut -f : specifies a filed list, separated by a delimiter cut -s : bypasses lines which contain no field delimiters when -f is specified, unless otherwise indicated. grep grep (Globel search a Regular Expression and Printing out the line)是一种强大 的文本搜索工具，它使用正则表达式搜索文本，并把匹配的line打印出来。 grep options grep -r : 递归搜索 grep -v : 反向选取，只显示不符合pattern的行 grep -o : 只显示被模式匹配到的字符串，而不是整个行 grep -i : 匹配时不区分大小写 grep -E : 使用扩展的正则表达式","tags":"编程","loc":"www.houcj.net/blog/2014/07/19/shell/","title":"Introduction to Shell"},{"text":"常见位操作：获取、设置、清除位数据 获取num第i位的bit值 将1左移i位，从而得到形如00100000的值，然后将这个值与val执行and操作，从而将 第i位之外的所有位清零。 boolean getBit ( int num , int i ){ return (( num & ( 1 << i )) != 0 ); /*another solution*/ return (( num >> i ) & 1 ); } 将num第i位的bit值置为1 同获取操作类似，只是把and操作变为or操作即可。 int setBit ( int num , int i ){ return num | ( 1 << i ); } 将num第i位bit值置为0 同setBit相反，首先需要将1左移i位后取反，变为形如11011111的 掩码，让该掩码与num进行and操作即可。 int clearBit ( int num , int i ){ int mask = ~( 1 << i ); return num & mask ; } 把num从最高位到i位清零的算法如下： int clearBitsMthroughI ( int num , int i ){ int mask = ( 1 << i ) - 1 ; return num & mask ; } 把num从第i位至0位清零的算法如下： int clearBitsMthroughI ( int num , int i ){ int mask = ~(( 1 << ( i + 1 )) - 1 ); return num & mask ; } Single Number II Given an array of integers, every element appears three times except for one. Find that single one. Note : Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 分析 由于别的元素都出现三次,因此所有的元素的在第i为的bit值之和取模3时的余数 必然为只出现一次元素在第i位的bit值,同时需要注意元素为负数时的处理. Python Code class Solution : # @param {integer[]} nums # @return {integer} def singleNumber ( self , nums ): target = 0 count = 0 n = len ( nums ) for i in range ( n ): if nums [ i ] < 0 : count += 1 for i in range ( 32 ): bit = 0 for j in range ( n ): bit += ( nums [ j ] >> i ) & 1 # 让数组中的元素的bit位的数值相加 target |= ( bit % 3 ) << i return target if count % 3 != 1 else - target Bitwise AND of Numbers Range Given a range [m, n] where 0 <= m <= n <= 2147483647, return the bitwise AND of all numbers in this range, inclusive. For example, given the range [5, 7], you should return 4. 分析 这里的trick是当m,n很大时,很容易超时! 但是我们发现and运算时,有0出现时,整个结果必为0. 同时n为m的2倍或者以上的时候, 每个bit位就都会有0出现,因此结果必为0. Python Code class Solution : # @param m, an integer # @param n, an integer # @return an integer def rangeBitwiseAnd ( self , m , n ): if m << 1 <= n : return 0 res = m for i in range ( m + 1 , n + 1 ): res = res & i return res Some Tricks n中包含1的数量 int hammingWeight ( uint32_t n ) { int ans = 0 ; while ( n ) { ans ++ ; n = n & ( n - 1 ); } return ans ; } 判断X是否是2的N次方 bool f ( int x ) { return ! ( x & ( x - 1 )); } 求x和y的平均值 int f ( int x , int y ) { return ( x & y ) + (( x &#94; y ) >> 1 ) } x&y 是取相同的位进行与操作，这个结果是x和y相同位的一半，x&#94;y 是取x和y的不同位，右移相当于除于2. 求和不使用加减法 // 迭代版本 int add ( int a , int b ) { int ans = 0 ; while ( b ) { ans = a &#94; b ; b = ( a & b ) << 1 ; a = ans ; } return ans ; } // 递归版本 int add1 ( int a , int b ) { if ( b == 0 ) { return a ; } int ans = a &#94; b ; b = ( a & b ) << 1 ; return add1 ( ans , b ); }","tags":"计算机科学","loc":"www.houcj.net/blog/2014/06/02/wei-cao-zuo/","title":"位操作"},{"text":"字符串匹配 Implement strStr() Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 暴力解法 在haystack中遍历，直到可以找到于needle相匹配的位置。O(nm)时间复杂度, O(1) 空间复杂度的暴力解法: def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) for x in range ( n - m + 1 ): if haystack [ x : m + x ] == needle : return x return - 1 KMP解法 匹配过程的时间复杂度为O(n)，预处理时间时间复杂度为O(m). O(m)的空间用来存储预处理数组。 KMP的核心就在于扫描字符串haystack，并更新可以匹配到needle的位置。 当haystack中的字符和needle中匹配的时候继续。 不匹配的时候让haystack向右移动，这里使用了一个预处理数组来 确定haystack应该移动的位置：不匹配字符所在位置 - 不匹配字符对应的预处理数组中的值 预处理数组在下面介绍。 def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) if m == 0 : return 0 prefix = self . compute_prefix ( needle ) j = - 1 for i in range ( n ): while j > - 1 and needle [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if needle [ j + 1 ] == haystack [ i ]: j = j + 1 if j == m - 1 : return i + 1 - m #j = prefix[j] find more possible position for the next match return - 1 计算某个字符对应的预处理的值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀。 具体算法如下。 def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix 应用:Shortest Palindrome Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. For example: Given \"aacecaaa\", return \"aaacecaaa\". Given \"abcd\", return \"dcbabcd\". 分析 我们知道回文的性质就是正反都相同。因此，我们以反转的字符串为母串，以原来的字符串为字串进行匹配。找到从源字符串 开始的最长的公共字串，然后把公共字串后面的字符串insert到源字符串。这道题的trick是容易超时，因此可以使用 kmp进行字符串的匹配。时间复杂度为O(n)的kmp字符串匹配长度，O(L)的字符串长度的空间复杂度。 具体见下面的代码 class Solution : def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix 其中 s[m-1:j:-1] 表示s中的字符串从j到最后一位的反转。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/03/21/kmp/","title":"字符串匹配"},{"text":"一、斐波那契博弈 题目 有一堆个数为n(n>=2)的石子，游戏双方轮流取石子，规则如下： 先手不能在第一次把所有的石子取完，至少取1颗； 之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。 约定取走最后一个石子的人为赢家，求必败态。 结论：当n为Fibonacci数的时候，先手必败。 用第二数学归纳法证明： 为了方便，我们将n记为f[i]。 当i=2时，先手只能取1颗，显然必败，结论成立。 假设当i<=k时，结论成立。 则当i=k+1时，f[i] = f[k]+f[k-1]。 则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。（一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]， 则后手可以直接取完f[k]，因为f[k] < 2*f[k-1]） 对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。 如果先手第一次取的石子数y>=f[k-1]/3，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时x=f[k-1]-y， 则x<=2/3*f[k-1]。 我们来比较一下2/3*f[k-1]与1/2*f[k]的大小。即4*f[k-1]与3*f[k]的大小，对两值作差后不难得出，后者大。 所以我们得到，x<1/2*f[k]。即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗， 所以后手必胜。 即i=k+1时，结论依然成立。 那么，当n不是Fibonacci数的时候，情况又是怎样的呢？ 这里需要借助\"Zeckendorf定理\"（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。分解的时候， 要取尽量大的Fibonacci数。 比如分解85：85在55和89之间，于是可以写成85=55+30， 然后继续分解30,30在21和34之间，所以可以写成30=21+9， 依此类推，最后分解成85=55+21+8+1。 则我们可以把n写成 n = f[a1]+f[a2]+……+f[ap]。（a1>a2>……>ap） 我们令先手先取完f[ap]，即最小的这一堆。由于各个f之间不连续， 则a(p-1) > ap + 1，则有f[a(p-1)] > 2*f[ap]。 即后手只能取f[a(p-1)]这一堆，且不能一次取完。 此时后手相当于面临这个子游戏（只有f[a(p-1)]这一堆石子，且后手先取）的必败态， 即先手一定可以取到这一堆的最后一颗石子。 同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。 二、 小岛的故事 题目 一个岛上有100个人，其中有5个红眼睛，95个蓝眼睛。这个岛有三个奇怪的宗教规则。 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就必须在当天夜里自杀。 某天，有个旅行者到了这个岛。 由于不知道这里的规矩，所以他在和全岛人一起的时候，不留神就说了一句话： 你们这里有红眼睛的人。 假设这个岛上的人足够聪明，每个人都可以做出缜密的逻辑推理。 问题一：请问这个岛上将会发生什么？ 分析一 假设岛上只有一个人是红眼睛，那么当天他看到有99个蓝眼睛就会自杀。 假设岛上有两个人是红眼睛，两个红眼睛的人都会假定自己不是红眼睛，结果发现第二天没有人会自杀， 因此他知道岛上有 两个红眼睛，而自己是其中的一个，于是两个人在第二天就都会自杀。 同理，当岛上有5个红眼睛时，它们就会在第五天一起自杀 问题二：那么旅行者存在的意义是什么呢？毕竟一开始岛上每个人都知道岛上存在红眼睛。 分析二： 假设岛上只有一个是红眼睛，他会看到99个都是蓝眼睛，但是他无法自己是红眼睛，因此他不会自杀。 假设岛上有两个人是红眼睛，虽然他会看到98个蓝眼睛，1个红眼睛，但他无法确定自己是红眼睛。 因此2个红眼睛是可以稳定存在。 同理，5个红眼睛是可以稳定存在的。 因此：旅行者出现的意义在于，他说了那句话，大家的推理方式就变了。 三、可怜的小白鼠 题目： 有8瓶酒，只有一瓶有毒。喝酒之后，1天会死，只有1天时间。请问至少需要多少只老鼠可以找到有毒的那只瓶子。 分析： 8瓶，1瓶有毒 即使某一个老鼠没有被毒死，也不会有时间重复利用了 老鼠开始喝酒，第一只要喝哪些，第二只要喝哪些呢？现在有什么依据么？显然酒瓶和老鼠都是一样的，不可区分的。 那么怎么来选择哪些老鼠喝哪瓶酒，进而进行判断呢？这是这个题目的关键点、核心点。8个酒瓶，我们对其编号0-7， 如下为二进制的表示， 编号 二进制 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 观察每一位的0和1的分布情况，从右向左，我们可以让第一只老鼠喝掉都是1的，即标号为1，3，5，7的瓶子 同样的，同时，另外两只老鼠测试第二位为1的瓶子以及第三位为1的瓶子。 假设结果为第一只死亡，第二只生存，第三只死亡，我们可以确定，那个有毒瓶子的编号为101，（有毒的瓶子出现，小白鼠必死，）即编号为5的瓶子为有毒的瓶子。 此类的题目分析的思路的关键就是找到突破口：表示为二进制的形式。 四、开灯关灯 题目： 有100盏灯，依次编号1-100，初始都是关着的。第1次遍历，打开全部的灯；第2次遍历，关掉第2盏、第4盏等被2整除的灯； 第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作 如果灯开着，就关掉 如果灯关着，就打开 如此交替进行，知道100次遍历完毕，请问，还有多少盏灯亮着。 分析： 例如编号为10的灯： 第1次能够操作，打开 第2次能够操作，关闭 第5次能够操作，打开 第10次能够操作，关闭 最终编号为10的灯是关闭的。 再来看编号为49这盏灯： 第1次能够操作，打开 第7次能够操作，关闭 第49次能够操作，打开 最终编号为49的灯打开着。 通过上面两个例子，编号为n的灯，有多少个因数，就有会被操作多少次。 很显然，如果是偶数次，则灯一定是关着的。那什么情况下，操作会是奇数次呢？一个数，每次分解，都是两个数相乘， 只有当这两个数相同的时候， 才会是偶数次。 所以，最终会亮着的灯，都能够开平方， 得到一个正整数：1,4,9,16,25,36,49,64,81,100. 【分析完毕】 五、天平称小球 题目 N个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。 分析 由于每次天平都有3种状态，左倾，右倾，平衡。因此每次可以为我们提供3种信息。因此我们应该尽量让N个小球切分为3份。 特别地，当不妨假设有6个球，来考虑一下3、3称和2、2称的区别： 在未称之前， 一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。 现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后， 不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）： 1重、2重、3重、4轻、5轻、6轻。 即这种称法能排除一半可能性。 现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。 假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。 假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。 总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！ 特别地，考虑N=3时，至少需要2次才能找到那个坏球。 因此这种方法最少的次数为 $$\\lfloor\\log3N\\rfloor+1$$ 六、称药丸 题目 有20瓶药丸，其中19瓶有1g/粒的药丸，余下一瓶装1.1g/粒的药丸。给你一台称重精准的天平，怎么找出比较 重的那瓶药丸？ 分析 由于天平只能用一次，因此必须利用预期重量和实际测量中间之间的差别，来得到那一瓶较重的药丸。就是放大他们的重量的差异。 假设有两瓶药丸，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，如果为3.1g，那么必然第一瓶为较重的。 否则，重量必然为3.2g。 同理，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，从第十瓶中取10粒药丸。如果都为1g那么总重量为210g（1+2+3+...10=20*21/2=210） 那么药品的编号可用 （weight-210）/ 0.1 得出。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2014/02/20/mind-trick/","title":"Mind trick"},{"text":"等概率：蓄水池问题 要求从N个元素中随机的抽取k个元素，其中N无法确定。 这种应用的场景一般是数据流的情况下，由于数据只能被读取一次，而且数据量很大，并不能全部保存，因此数据量N是无法在抽样开始时确定的；但又要保持随机性，于是有了这个问题。所以搜索网站有时候会问这样的问题。 这里的核心问题就是\"随机\"，怎么才能是随机的抽取元素呢？我们设想，买彩票的时候，由于所有彩票的中奖概率都是一样的，所以我们才是\"随机的\"买彩票。那么要使抽取数据也随机，必须使每一个数据被抽样出来的概率都一样。 分析： 由于N无法确定，数据只能读取一次，并且要求随机，就是每个元素抽出的概率一样，都是k/N。 解法一：最小k个指纹 找到一个哈希函数能产生随机数，同时用一个k个元素的堆用来保存最小的k个元素。那么过一遍所有的元素，计算每个的哈希值，通过堆来选择k个元素。 解法二：数学计算 先选中前k个， 从第k+1个元素到最后一个元素为止， 以1/i (i=k+1, k+2,...,N) 的概率选中第i个元素， 并且随机替换掉一个原先选中的元素， 这样遍历一次得到k个元素， 可以保证完全随机选取。 任意元素G在i轮留下来的概率： P(G留下) = P(G已经存在) * P(G没有被替换) = P(G已经存在) * (1 - P(G被替换)) = P(G已经存在) * (1 - P(第i个元素要替换某个元素) * P(某个元素是G)) = (k/i) * (1 - (k/(i+1)) * (1/k)) = (k/i) * (1 - (1/(i+1))) = (k/i) * (i/(i+1)) = (k/(i+1)) 证毕！ 拒绝采样 Given a function which generates a random integer in the range 1 to 7, write a function which generates a random integer in the range 1 to 10 uniformly. 分析： 下面是我们通过两次rand7()的位置，第一次代表行的位置，第二次代表列的位置，然后来唯一确定1-10的值， 其中\"*\"表示随机从下面的表中取出一个数字。 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 8 9 10 1 2 3 4 3 5 6 7 8 9 10 1 4 2 3 4 5 6 7 8 5 9 10 1 2 3 4 5 6 6 7 8 9 10 * * 7 * * * * * * * 具体算法如下 int rand10 () { int row , col , idx ; do { row = rand7 (); col = rand7 (); idx = col + ( row - 1 ) * 7 ; } while ( idx > 40 ); return 1 + ( idx - 1 ) % 10 ; } 洗牌算法 Given an array of distinct integers, give an algorithm to randomly reorder the integers so that each possible reordering is equally likely. In other words, given a deck of cards, how can you shuffle them such that any permutation of cards is equally likely? 分析 洗牌算法可以有效的解决这类问题，所谓的洗牌算法就是按顺序依次遍历所有的牌，然后从后面的元素中随机的取一个元素来与当前元素交换 import random def Shuffle ( li ): n = len ( li ) for x in xrange ( n - 1 , 0 , - 1 ): y = random . randint ( 0 , x ) # 从后面的数据中随机选取一个 li [ x ], li [ y ] = li [ y ], li [ x ] # 将随机选取的元素与当前位置元素互换 如果某个元素被放入第i（1≤i≤n ）个位置，就必须是在前i - 1次选取中都没有选到它，并且第i次选取是恰好选中它。 其概率为： \\begin{equation*} p_i=\\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\cdots\\times\\frac{n-i+1}{n-i+2}\\times\\frac{1}{n-i+1}=\\frac{1}{n} \\end{equation*} 条件概率 老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？ [假设生男生女的概率相等] 分析 根据题目可以得出，两个事件，事件A:至少有一个周二出生的男孩，事件B:两个孩子都是男孩。题目所求即为P(B|A)，即在A事件满足的条件下，B事件发生的机率。 由贝叶斯公式可得： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 依次计算公式中的各个概率值： 在已知两个孩子都是男孩的条件下，至少有一个是周二出生的男孩： \\begin{equation*} P(A|B)=1-{(\\frac{6}{7})}&#94;2=\\frac{13}{49} \\end{equation*} 两个孩子都是男孩： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 至少有一个孩子是周二出生的男孩： \\begin{equation*} P(A)=1-{(\\frac{1}{2}\\times\\frac{6}{7}+\\frac{1}{2})}&#94;2=\\frac{27}{196} \\end{equation*} 代入即可得： \\begin{equation*} P(B|A)=\\frac{P(A|B)P(B)}{P(A)}=\\frac{13}{49}\\times\\frac{1}{4}\\div\\frac{27}{196}=\\frac{13}{27} \\end{equation*} if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/18/equal-probability/","title":"概率问题"},{"text":"Trie (前缀树) Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. 分析 Trie ，又称前缀树或字典树，是一种有序树，用于保存关联数组， 其中的键通常是字符串，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的空字符串，而根节点对应空字符串。 由于Python是强类型语言，不支持隐式类型转换，因此使用字典来存储效果更好。 Python Code class TrieNode : def __init__ ( self ): self . word = None self . children = {} class Trie : def __init__ ( self ): self . root = TrieNode () def insert ( self , word ): node = self . root for char in word : if char not in node . children : node . children [ char ] = TrieNode () node = node . children [ char ] node . word = word def search ( self , word ): node = self . root for char in word : if char not in node . children : return False node = node . children [ char ] return node . word == word def startsWith ( self , prefix ): node = self . root for char in prefix : if char not in node . children : return False node = node . children [ char ] return True # Your Trie object will be instantiated and called as such: # trie = Trie() # trie.insert(\"somestring\") # trie.search(\"key\") 前缀树的应用 Given a 2D board and a list of words from the dictionary, find all words in the board. Each word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word. For example, Given words = [\"oath\",\"pea\",\"eat\",\"rain\"] and board = [ ['o','a','a','n'], ['e','t','a','e'], ['i','h','k','r'], ['i','f','l','v'] ] Return [\"eat\",\"oath\"]. Note: You may assume that all inputs are consist of lowercase letters a-z. 分析 如果直接使用回溯的方法在board里深搜或者宽搜，由于words里的单词很多， 很容易就会超时。因此可以考虑使用前缀树，使用words里的单词构造一棵前缀树， 然后从这棵前缀树上进行遍历。由于保证每次搜索都在可能出现单词的前缀中，因此 大大提高了剪枝的效率。 Python Code class TrieNode : def __init__ ( self ): self . flag = False self . children = {} class Solution : def __init__ ( self ): self . root = TrieNode () def insert ( self , word ): node = self . root for char in word : if char not in node . children : node . children [ char ] = TrieNode () node = node . children [ char ] node . flag = True def findWords ( self , board , words ): m = len ( board ) n = len ( board [ 0 ]) self . res = [] for word in words : self . insert ( word ) for i in range ( m ): for j in range ( n ): self . dfs ( self . root , i , j , board , m , n , '' ) return self . res def dfs ( self , node , row , col , board , m , n , word ): if node . flag : self . res . append ( word ) node . flag = False if 0 <= row < m and 0 <= col < n : char = board [ row ][ col ] if char in node . children : board [ row ][ col ] = '#' word += char self . dfs ( node . children [ char ], row - 1 , col , board , m , n , word ) self . dfs ( node . children [ char ], row + 1 , col , board , m , n , word ) self . dfs ( node . children [ char ], row , col - 1 , board , m , n , word ) self . dfs ( node . children [ char ], row , col + 1 , board , m , n , word ) board [ row ][ col ] = char LRU LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析 在常数时间内，可以使用一个双向链表来完成删除和插入到链表末尾的操作。而使用hash则可以在常数时间完成从key到value的映射。 因为这个算法的关键是用hash table + double link list来实现。 当使用get(key)时，这时双向链表中的key节点需要删除，然后插入到链表末尾。而 最近一直不使用的节点则放在链表的头部，等待被替换。Python中的collections.OrderedDict()就是用一个双向链表 来维护的一个字典（即map）见下面的代码。当然我们也可以自己实现一个双向链表，见 Github Python Code class LRUCache : def __init__ ( self , capacity ): self . capacity = capacity self . cache = collections . OrderedDict () def get ( self , key ): if key not in self . cache : return - 1 value = self . cache . pop ( key ) self . cache [ key ] = value # del the key item and insert to the last return value def set ( self , key , value ): if key in self . cache : self . cache . pop ( key ) if len ( self . cache ) == self . capacity : self . cache . popitem ( last = False ) # del from the front self . cache [ key ] = value","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/13/trie-lru/","title":"Trie-LRU"},{"text":"TCP为每个连接建立了七个定时器。下面讲按照这些定时器在一条连接生存期内出现的次序依次进行介绍。 Connection establishment Timer(​连接建立定时器) 为了防止client端一直等待服务器端的情况发生。 在Client发送SYN报文段建立新的链接时，该定时器启动，如果在75s内没有收到响应，连接建立将会终止。确定连接的有效建立。 Retransmission Timer(重传定时器) 重传定时器在TCP发送数据时设定。在该定时器超时，而没有收到另外一端的ACK的时候，将重传数据。重传定时器的值是动态计算的，取决于该连接RTT的值和被重传的次数。 Delayed ACK Timer(延迟ACK定时器)定时器在200ms 延迟ACK定时器负责在该终端（end）收到一个数据包时，无需马上发出ACK进行确认，而是等待200ms内，有数据要在该连接上发送，延迟的ACK响应就可随着数据一起发送回另一个终端。这种方式也被成为捎带确认。 Persist Timer（持续定时器） 持续定时器在收到连接另一端的发送通告窗口为零时，阻止该端继续发送数据时设定。因此当该端有数据要发送时， 但连接的另一端的通告窗口为零时，持续定时器就会启动，超时后向连接另一端发送1字节的数据，来判断另一方的接收窗口是否打开。被称为零窗口探测。持续定时器的值是动态计算的，取决于往返时间，时间在5s到60s之间取值。 Keep alive Timer（保活定时器） 如果连接的持续时间超过2hour，保活定时器就会超时，向对端发送连接探测报文，强迫对端发出响应。如果连续若干次保活测试收不到相应的相应，就认为对端发生了故障。 FIN_WAIT_2 Timer 当某个连接从FIN_WAIT_1状态变迁到FIN_WAIT_2状态，并且不能再收到任何新的数据时，该定时器就会启动设为10分钟。定时器超时重设为75s，第二次超时后连接被关闭。该定时器的目的是为了避免对方一直不发送FIN，某个连接一直处于FIN_WAIT_2状态。 TIME_WAIT_Timer (也成为2MSL定时器) 当连接转移到TIME_WAIT状态，定时器启动。2MSL等待时间的原因就是为了确保最后一个ACK在一个MSL丢包后重传 TCP包括连个定时器函数，快速定时器（200ms调用一次），慢速定时器（500ms）调用一次。延迟ACK定时器时，每个200ms超时后，延迟的ACK必须被发送。其他的定时器是每500ms递减一次，计数器减为0时，就触发相应的动作。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/01/02/timer/","title":"TCP中的七种定时器"},{"text":"回溯 对于搜索问题和优化问题，它们的解分布在一个解空间里，求解这些搜索问题的算法 就是一种遍历搜索解空间的系统方法。回溯算法将搜索空间看作一定的结构，一个解对应于树中的一片树叶。算法从 根节点出发，尝试所有可达的节点。当不能前进时，就后退一步或若干步，再从另一个节点继续 搜索，知道所有的节点都尝试过，为了加快搜索，通常使用分支限界等剪枝方法。同时需要记录解的路径 重复访问和重复解 重复访问 在图等数据结构的访问中，经常会出现重复访问的情况，这时需要记录临时访问到的节点，然后在访问结束时要恢复临时节点的值。 重复解 在枚举所有解的情况时，如果当前访问的层的节点值和pre层的节点值相等就会出现重复解的情况，需要记录pre层访问的节点值来解决这种情况。 N皇后 The n-queens puzzle is the problem of placing n queens on an n×n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution contains a distinct board configuration of the n-queens' placement, where 'Q' and '.' both indicate a queen and an empty space respectively. For example, There exist two distinct solutions to the 4-queens puzzle: [ [\".Q..\", // Solution 1 \"...Q\", \"Q...\", \"..Q.\"], [\"..Q.\", // Solution 2 \"Q...\", \"...Q\", \".Q..\"] ] 分析 这里有个trick，就是可以用board[row] = col 来表示访问到第row行第col列。然后我们只要使用 长度为N的一纬数组就可以表示这个解。例如[4,2,7,1,3,5,8,6]，表示在第一行皇后放在第4列，...，第8行 中皇后放在第6列。同时DFS遍历时需要注意，排除那些不满足条件的解。 Python Code class Solution : def solveNQueens ( self , n ): self . res = [] self . dfs ( 0 ,[], n , [ - 1 for i in xrange ( n )]) return self . res def dfs ( self , depth , answer , n , board ): if depth == n : self . res . append ( answer [:]) # fast than self.res.append(answer) return for col in range ( n ): flag = True for row in range ( depth ): if board [ row ] == col or ( depth - row ) == abs ( col - board [ row ]): flag = False break if flag : board [ depth ] = col self . dfs ( depth + 1 , answer + [ '.' * col + 'Q' + '.' * ( n - col - 1 )], n , board ) Combination Sum III Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers. Ensure that numbers within the set are sorted in ascending order. Example 1: Input: k = 3, n = 7 Output: [[1,2,4]] 分析 每次都在比前一个解大的基础上进行遍历，直到k个解的和为n。不会重现重复解的情况。 Python Code class Solution : # @param {integer} k # @param {integer} n # @return {integer[][]} def combinationSum3 ( self , k , n ): self . res = [] self . dfs ( k , n , 0 ) return self . res def dfs ( self , k , n , start , tmp = []): if n < 0 : return elif n == 0 and k == 0 : self . res . append ( tmp [:]) return else : for i in range ( start + 1 , 10 ): if n < i : return self . dfs ( k - 1 , n - i , i , tmp + [ i ]) SubSet II Given a collection of integers that might contain duplicates, nums, return all possible subsets. Note: - Elements in a subset must be in non-descending order. - The solution set must not contain duplicate subsets. For example, If nums = [1,2,2], a solution is: [ [2], [1], [1,2,2], [2,2], [1,2], [] ] 分析 这里在枚举所有解的时候，可能出现重复解的情况，同时需要一个变量来记录解的路径 Python Code class Solution : def subsetsWithDup ( self , nums ): self . res = [] nums . sort () n = len ( nums ) self . dfs ( 0 , 0 , n ,[], nums ) return self . res def dfs ( self , depth , start , n , ans , nums ): self . res . append ( ans ) if depth == n : return pre = - 2 << 10 for index in range ( start , n ): if pre != nums [ index ]: self . dfs ( depth + 1 , index + 1 , n , ans + [ nums [ index ]], nums ) pre = nums [ index ] Word Search Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. For example, Given board = [ [\"ABCE\"], [\"SFCS\"], [\"ADEE\"] ] word = \"ABCCED\", -> returns true, word = \"SEE\", -> returns true, word = \"ABCB\", -> returns false. 分析 DFS搜索的时候，需要以该元素为中心，上下左右进行递归搜索，这时可能出现重复访问的情况。 同时递归搜索要注意边界条件 Python Code m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): if board [ i ][ j ] == word [ 0 ]: if self . dfs ( i , j , word [ 1 :], board , m , n ): return True return False def dfs ( self , row , col , word , board , m , n ): if len ( word ) == 0 : return True tmp = board [ row ][ col ] board [ row ][ col ] = '#' #up if row > 0 and board [ row - 1 ][ col ] == word [ 0 ]: if self . dfs ( row - 1 , col , word [ 1 :], board , m , n ): return True #down if row < m - 1 and board [ row + 1 ][ col ] == word [ 0 ]: if self . dfs ( row + 1 , col , word [ 1 :], board , m , n ): return True #left if col > 0 and board [ row ][ col - 1 ] == word [ 0 ]: if self . dfs ( row , col - 1 , word [ 1 :], board , m , n ): return True #right if col < n - 1 and board [ row ][ col + 1 ] == word [ 0 ]: if self . dfs ( row , col + 1 , word [ 1 :], board , m , n ): return True board [ row ][ col ] = tmp return False Permutations Given a collection of numbers, return all possible permutations. For example, [1,2,3] have the following permutations: [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], and [3,2,1]. 分析 对于排列问题，首先第一个元素可以出现在排列中的任一个位置，剩下的元素递归的处理， 直到只剩一个元素的时候返回. Python Code class Solution : # @param num, a list of integer # @return a list of lists of integers def permute ( self , num ): n = len ( num ) if n == 1 : return [ num ] res = [] for i in xrange ( n ): for x in self . permute ( num [: i ] + num [ i + 1 :]): res . append ([ num [ i ]] + x ) return res","tags":"编程","loc":"www.houcj.net/blog/2013/12/22/hui-su-yu-fen-zhi-xian-jie/","title":"回溯与分支限界"},{"text":"二叉查找树 由于红黑树本质上就是一棵 二叉查找树 ，所以在了解红黑树之前先来看下二叉查找树。 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值 任意结点的左、右子树也分别为二叉查找树 没有键值相等的结点（no duplicate nodes） 因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn） 红黑树 红黑树是一棵二叉搜索树，并且满足以下性质： 1. 每个节点或者是红色的，或者是黑色的 2. 根节点为黑色 3. 每个叶子节点(NIL)是黑色 4. 如果一个节点是红色的，则它的两个子节点必须是黑色的。 5. 对每个节点，从该节点到其所有后代叶节点的简单路径上，都包含相同数目的黑色节点 PS： - 特性3中的叶子节点，是为空的节点 - 特性5确保没有一条路径比其他路径长两倍。 红黑树的应用 红黑树主要用来存储有序的数据，它的时间复杂度是O(lgn)，空间复杂度也是 O(lgn)。C++ STL中的set、map，linux虚拟内存管理都是通过红黑树去实现。 红黑树的操作 红黑树中有两种基本操作，插入和删除。需要注意的是，每次进行这样的操作的时候都会 有可能改变红黑树的性质，因此必须通过相应的INSERT-FIXUP和DELETE-FIXUP来保证红黑树的性质。 具体情况见 算法导论 ，而它们都会用到旋转的方法。 下面就具体介绍旋转和相应的插入删除操作。 旋转 这里主要介绍左旋，右旋的操作基本类似。 左旋的伪码如下： LEFT_ROTATE ( T , x ) 1 y = x . right # set y 2 x . right = y . left # turn y's left subtree into x's right subtree 3 if y . left != T . nil 4 y . left . parent = x 5 y . parent = x . parent # link x's parent to y 6 if x . parent == T . nil 7 T . root = y 8 elif x == x . parent . left 9 x . parent . left = y 10 else 11 x . parent . right = y 12 y . left = x # put x on y's left 13 x . parent = y 插入 红黑树本身就是一种二叉查找树，插入的时候也需要首先不能改变二叉查找树的性质，然后将该节点着色为 红色(插入红色节点是为了保证满足性质5)。最后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的插入操作 RB_INSERT ( T , z ) 1 y = T . NIL 2 x = T . root 3 while x != T . NIL 4 y = x 5 if z . key < x . key 6 x = x . left 7 else 8 x = x . right 9 z . parent = y 10 if y == T . nil 11 T . root = z 12 elif z . key < y . key 13 y . left = z 14 else 15 y . right = z 17 z . left = T . nil 18 z . right = T . nil 19 z . color = RED 20 RB_INSERT_FIXUP ( T , z ) 插入之后可能破坏红黑树的性质2和4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 z的叔节点y是红色的 1)将父节点设为黑色 2)将叔节点设为黑色 3)将祖父节点设为红色 4)将祖父节点设为当前节点，继续处理 case2 z的叔节点y是黑色的且z是一个右孩子 1)将父节点设为当前节点 2)对当前节点进行左旋操作 case3 z的叔节点y是黑色的且z是一个左孩子 1)将父节点设为黑色 2)将祖父节点设为红色 3)对祖父节点进行右 旋操作 其中z表示当前节点，y表示z的叔节点，z的父节点是红色的。 修复插入操作 RB_INSERT_FIXUP ( T , z ) 1 while z . parent . color == RED 2 if z . parent == z . parent . parent . left 3 y = z . parent . parent . right 4 if y . color == RED # CASE 1 5 z . parent . color = BLACK 6 y . color = BLACK 7 z . parent . parent . color = RED 8 z = z . parent . parent 9 elif z == z . parent . right # CASE 2 10 z = z . parent 11 LEFT_ROTATE ( T , z ) 12 z . parent . color = BLACK # CASE 3 13 z . parent . parent . color = RED 14 RIGHT_ROTATE ( T , z . parent . parent ) 15 else ( same as the previous \"if\" clause # z's parent is a right child with \"right\" and \"left\" extranged ) 16 T . root . color = BLACK 删除 将红黑树内的某一个节点删除花费O(lgn)时间。红黑树本身就是一种二叉查找树，删除的时候也需要首先不能改变二叉查找树的性质， 然后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的删除操作 RB_DELETE ( T , z ) 1 y = z 2 y - original - color = y . color 3 if z . left == T . nil 4 x = z . left 5 RB - TRANSPLANT ( T , z , z . right ) 6 elif z . right == T . nil 7 x = z . right 8 RB - TRANSPLANT ( T , z , z . left ) 9 else 10 y = TREE - MINIMUM ( z . right ) 11 y - original - color = y . color 12 x = y . right 13 if y . parent == z 14 x . parent = y 15 else 16 RB - TRANSPLANT ( T , y , y . right ) 17 y . right = z . right 18 y . right . parent = y 19 RB - TRANSPLANT ( T , z , y ) 20 y . left = z . left 21 y . left . parent = y 22 y . color = z . color 23 if y - original - color == BLACK 24 RB_DELETE_FIXUP ( T , x ) RB - TRANSPLANT ( T , u , v ) 1 if u . parent == T . nil 2 T . root = v 3 elif u == u . parent . left 4 u . parent . left = v 5 else 6 u . parent . right = v 7 v . p = u . p 删除之后可能破坏红黑树性质的1，2，4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 x的兄弟节点w是红色的 1)将x的兄弟节点设为黑色 2)将x的父节点设为红色 3)对x的父节点进行左旋 4)左旋后，重新设置x的兄弟节点 case2 x的兄弟节点w是黑色，w的两个子节点都是黑色的 1)将x的兄弟节点设为红色 2)设置x的父节点为新的x节点 case3 x的兄弟节点w是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的 1)将x兄弟节点的左孩子设为黑色 2)将x兄弟节点设为红色 3)对x的兄弟节点进行右旋 4)右旋后，重新设置x的兄弟节点 case4 x的兄弟节点w是黑色；w的右孩子是红色的 1)将x父节点颜色赋值给x的兄弟节点 2)将x父节点设为黑色 3)将x兄弟节点的右子节设为黑色 4)对x的父节点进行左旋 5)设置x为根节点 其中x为当前节点，w是x的兄弟节点。 修复删除操作 RB_DELETE_FIXUP ( T , x ) 1 while x != root and x . color == BLACK 2 if x == x . parent . left 3 w = x . parent . right # CASE 1 4 if w . color == RED 5 w . color = BLACK 6 x . parent . color = RED 7 LEFT_ROTATE ( T , p [ x ]) 8 w = x . parent . right 9 if w . left . color == BLACK and w . right . right == BLACK #CASE 2 10 w . color = RED 11 x = x . parent 12 elif w . right . color == BLACK #CASE 3 13 w . left . color = BLACK 14 w . color = RED 15 RIGHT_ROTATE ( T , w ) 16 w = x . parent . right 17 w . color = x . parent . color #CASE 4 18 x . parent . color = BLACK 19 w . right . color = BLACK 20 LEFT_ROTATE ( T , x . parent ) 21 x = T . root 22 else 23 same as the previous \"if\" clause with \"right\" and \"left\" exchanged ; 24 x . color = BLACK ; 下面是一个简单的 Python 实现.","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/red-black-tree/","title":"Black Red Tree"},{"text":"子字符串 最长不重复子串 Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3. For \"bbbbb\" the longest substring is \"b\", with the length of 1. 分析 O(n)时间复杂度， O(1)空间复杂度 可以考虑使用字典，记录字符下标出现的位置。遍历整个字符串，如果发现其中的一个字符存在字典中，说明它出现过，即为重复的字符，那么从该字符后重新计算，并记录出现的不重复子串的最大长度。 class Solution : def lengthOfLongestSubstring ( self , s ): dic = { chr ( i ) : - 1 for i in range ( 256 ) } length , res , j = len ( s ), 0 , 0 for i in range ( length ): if dic [ s [ i ]] >= j : j = dic [ s [ i ]] + 1 dic [ s [ i ]] = i if i - j + 1 > res : res = i - j + 1 return res 最长回文子串 Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.** 分析 O(n&#94;2)时间复杂度， O(1)空间复杂度 从头开始遍历整个字符串。然后以每个字符串为中点向两边扩展，直到最长的Palindromic，记录中间出现的Palindromic的最大长度。需要注意的是Palindromic的长度可能为奇数也可能为偶数。 class Solution : # @return a string def longestPalindrome ( self , s ): length = len ( s ) def expand ( left , right ): while left >= 0 and right < length and s [ left ] == s [ right ]: left -= 1 right += 1 return right - left - 1 start , end = 0 , 0 for i in range ( length ): len1 = expand ( i , i ) len2 = expand ( i , i + 1 ) Len = max ( len1 , len2 ) if end - start < Len : start = i - ( Len - 1 ) / 2 end = i + Len / 2 return s [ start : end + 1 ] Distinct Subsequences Given a string S and a string T, count the number of distinct subsequences of T in S. A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not). Here is an example: S = \"rabbbit\", T = \"rabbit\" Return 3. 分析 使用动态规划。 dp[i][j]表示匹配到S中的第i个字符与T中第j个字符相同时的 ···························Distinct Subsequences 的个数。那么若s[i-1] == t[j-1]时，t从j-1转移到j状态，或者原来就是j状态。无论如何，每次s都从 i-1状态移到i状态。 Python Code class Solution : # @param {string} s # @param {string} t # @return {integer} def numDistinct ( self , s , t ): m = len ( s ) + 1 n = len ( t ) + 1 dp = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): dp [ i ][ 0 ] = 1 # T is null for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ i ][ j ] = dp [ i - 1 ][ j ] if s [ i - 1 ] == t [ j - 1 ]: dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + dp [ i - 1 ][ j ] return dp [ m - 1 ][ n - 1 ]","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/string-related/","title":"字符串相关"},{"text":"流量控制（Flow control） End-to-End,防止发送方速率过大，接收方来不及处理发送方的数据。- - 拥塞控制（Congestion control） 到达子网中某一部分的分组数量过多，中间路由缓存分组，queueing，造成RTT增加。反应网络整体状况 滑动窗口（Sliding Window） 位于发送方，由接收方的通告窗口（Advertised-Window）决定。接收方通过通告窗口告诉发送方自己还有多少buffer可以接收数据。 通告窗口（Advertised-Window） 接收方使用流量控制的方式 拥塞窗口（Congestion Window） 拥塞窗口的大小指能够发出，但还没有收ACK的最大数据报文段。Linux 3.0 把CWND初始化10个MSS。发送方使用流量控制的方式。发送方取拥塞窗口与通告窗口中的最小值作为发送上限 慢启动（Slow Start） 每个ACK，CWND增加一个报文段（CWND以字节为单位，一报文段为单位进行线性增加） 报文段（Segment） 传输层分组称为报文段，是TCP MSS（Maximum Segment Size ） vs MTU(Maximum Transmission Unit) 在以太网中，MSS最大值为1460（20字节的IP header和20字节的TCP header），MTU的值为1500字节。MSS用于控制发送数据的长度，避免以较小MTU连接到网络上的主机产生分组 往返时延(Round-Trip Time ) 表示从发送端发送数据开始，到发送端收到来自接收端的ACK，总共经历的时延，由传播时延，传输时延，排队时延（Queuing Delay），节点处理时延决定（Node processing Dela y）。可以反应网络的拥塞状况 传输时延（Transmission Delay），传播时延（Transmission Delay） 传输时延=L/R，L，表示分组长度，R，表示链路传输速率(带宽)。传播时延=d/s，d，表示两段的实际物力距离，s一般等于小于光速","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/15/the-parameters-in-tcp-congestion-control/","title":"TCP Congestion Control 中的相关参数"}]}