{"pages":[{"text":"Please contact me via Email cjhou1984@gmail.com or the links in the blog. Thanks! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : # @param {string} s # @return {string} def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix","tags":"pages","loc":"www.houcj.net/pages/About.html","title":"About"},{"text":"把二叉查找树保存到文件中 Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. You must be able to restore to the exact original BST using the saved format. 由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历 或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过 中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来 构造一棵二叉树。 构造二叉树的代码如下： void readBSTHelper ( int min , int max , int & insertVal , BinaryTree *& p , ifstream & fin ) { if ( insertVal > min && insertVal < max ) { int val = insertVal ; p = new BinaryTree ( val ); if ( fin >> insertVal ) { readBSTHelper ( min , val , insertVal , p -> left , fin ); readBSTHelper ( val , max , insertVal , p -> right , fin ); } } } void readBST ( BinaryTree *& root , ifstream & fin ) { int val ; fin >> val ; readBSTHelper ( INT_MIN , INT_MAX , val , root , fin ); } Serialization|Deserialization of a Binary Tree Design an algorithm and write code to serialize and deserialize a binary tree. Writing the tree to a file is called ‘serialization' and reading back from the file to reconstruct the exact same binary tree is ‘deserialization'. 在二叉排序树中，中序遍历是有序的，而普通的二叉树就没有这样的性质。因此需要使用哨兵来输出那些空的节点，来最终确定每个 节点的位置。这里使用前序遍历。 Cpp Code void writeBinaryTree ( BinaryTree * p , ostream & out ) { if ( ! p ) { out << \"# \" ; } else { out << p -> data << \" \" ; writeBinaryTree ( p -> left , out ); writeBinaryTree ( p -> right , out ); } } 从文件中读取这个二叉树的操作也是类似的。我们同样使用先序遍历，如果遍历到的节点是一个哨兵，说明是 空节点，我们忽视这个节点就好。如果是一个具体的数值，我们就把它插入到当前的节点，然后遍历它的左孩子， 然后遍历它的右孩子。 Cpp Code void readBinaryTree ( BinaryTree *& p , ifstream & fin ) { int token ; bool isNumber ; if ( ! readNextToken ( token , fin , isNumber )) return ; if ( isNumber ) { p = new BinaryTree ( token ); readBinaryTree ( p -> left , fin ); readBinaryTree ( p -> right , fin ); } } 当然我们也可以使用层次遍历。 Printing a Binary Tree in Level Order Given a binary tree, print out the tree in level order (ie, from left to right, level by level). Output a newline after the end of each level. 3 / \\ 9 20 / \\ 15 7 For example, the level order output of the tree above is: 3 9 20 15 7 可以使用BFS或者DFS BFS 使用BFS时，需要记录一层的节点数目，以及下层的节点数目。当这层的 节点数目为0的时候，说明这层的节点已经完全被输出。然后接着输出下一层。 void printLevelOrder ( BinaryTree * root ) { if ( ! root ) return ; queue < BinaryTree *> nodesQueue ; int nodesInCurrentLevel = 1 ; int nodesInNextLevel = 0 ; nodesQueue . push ( root ); while ( ! nodesQueue . empty ()) { BinaryTree * currNode = nodesQueue . front (); nodesQueue . pop (); nodesInCurrentLevel -- ; if ( currNode ) { cout << currNode -> data << \" \" ; nodesQueue . push ( currNode -> left ); nodesQueue . push ( currNode -> right ); nodesInNextLevel += 2 ; } if ( nodesInCurrentLevel == 0 ) { cout << endl ; nodesInCurrentLevel = nodesInNextLevel ; nodesInNextLevel = 0 ; } } } DFS 使用DFS时需要记录递归的深度，根据递归的深度来确定层数 class Solution : # @param root, a tree node # @return a list of lists of integers def levelOrder ( self , root ): res = [] def dfs ( root , depth ): if root : if self . cur == depth : res . append ([ root . val ]) self . cur += 1 else : res [ depth ] . append ( root . val ) dfs ( root . left , depth + 1 ) dfs ( root . right , depth + 1 ) if root : self . cur = 0 dfs ( root , 0 ) return res Convert Sorted List to Balanced Binary Search Tree (BST) Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST. 由于链表只能顺序遍历，因此最优的解法应该是在遍历链表的同时，构造这个二叉查找树。 因此我们采取bottom-up(而非通常的top-down)的方法，从底到上创建二叉查找树节点，然后把他们分配到它们的父亲节点中 这样就可以一边遍历，一遍构造二叉查找树。 BinaryTree * sortedListToBST ( ListNode *& list , int start , int end ) { if ( start > end ) return NULL ; // same as (start+end)/2, avoids overflow int mid = start + ( end - start ) / 2 ; BinaryTree * leftChild = sortedListToBST ( list , start , mid - 1 ); BinaryTree * parent = new BinaryTree ( list -> data ); parent -> left = leftChild ; list = list -> next ; parent -> right = sortedListToBST ( list , mid + 1 , end ); return parent ; } BinaryTree * sortedListToBST ( ListNode * head , int n ) { return sortedListToBST ( head , 0 , n - 1 ); } Convert Binary Search Tree (BST) to Sorted Doubly-Linked List 同上面的方法类似，我们可以采用中序遍历的方法，把每个遍历到的节点依次插入到 双向链表中，同时保持双向链表的有序性 void treeToDoublyList ( Node * p , Node *& prev , Node *& head ) { if ( ! p ) return ; treeToDoublyList ( p -> left , prev , head ); // current node's left points to previous node p -> previous = prev ; if ( prev ) prev -> next = p ; // previous node's right points to current node else head = p ; // current node (smallest element) is head of // the list if previous node is not available // as soon as the recursion ends, the head's left pointer // points to the last node, and the last node's right pointer // points to the head pointer. Node * right = p -> right ; head -> previous = p ; p -> next = head ; // updates previous node prev = p ; treeToDoublyList ( right , prev , head ); } // Given an ordered binary tree, returns a sorted circular // doubly-linked list. The conversion is done in-place. Node * treeToDoublyList ( Node * root ) { Node * prev = NULL ; Node * head = NULL ; treeToDoublyList ( root , prev , head ); return head ; }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/18/binary-tree/","title":"二叉树"},{"text":"和树的遍历类似，关于的图的遍历一般也有两种，深度优先和宽度优先。 课程安排 I&II There are a total of n courses you have to take, labeled from 0 to n - 1. Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1] Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses? 分析 核心是遍历图，确定图中节点的数目，以及图中是否有环。其中课程安排II的核心是根据拓扑排序后的节点约束的如果小于课程数目，则剩下的按正常排序即可（节点之间没有前后的约束关系），这里可以使用 Topological sorting 具体深度优先的算法如下 L = Empty list that will contain the sorted nodes while there are unmarked nodes do select an unmarked node n visit ( n ) function visit ( node n ) if n has a temporary mark then stop ( not a DAG ) if n is not marked ( i . e . has not been visited yet ) then mark n temporarily for each node m with an edge from n to m do visit ( m ) mark n permanently unmark n temporarily add n to head of L 具体实现 def findOrder ( self , numCourses , prerequisites ): self . lst = [] self . visited = [ - 1 ] * numCourses self . hascyle = False for edge in prerequisites : if self . visited [ edge [ 0 ]] == - 1 : self . visit ( edge [ 0 ], prerequisites ) if self . hascyle : return [] for i in range ( numCourses ): if i not in self . lst : self . lst . append ( i ) return self . lst def visit ( self , node , prerequisites ): if self . visited [ node ] == 0 : self . hascyle = True return if self . visited [ node ] == - 1 : self . visited [ node ] = 0 for edge in prerequisites : if edge [ 0 ] == node : self . visit ( edge [ 1 ], prerequisites ) #self.visited[node] =-1 self . visited [ node ] = 1 self . lst . append ( node ) 发现岛的数目 Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110 11010 11000 00000 Answer: 1 Example 2: 11000 11000 00100 00011 Answer: 3 分析 这道题其实是求连通分支的个数。可以采取DFS, 或者BFS。下面采用的是DFS，在每次的 DFS调用中，就会找到一个连通分支，直到遍历图中的所有节点找到所有的连通分支。 def numIslands ( self , grid ): m = len ( grid ) if m < 1 : return 0 n = len ( grid [ 0 ]) visited = [[ 0 for i in range ( n )] for j in range ( m )] def dfs ( row , col ): visited [ row ][ col ] = 1 if row > 0 and grid [ row - 1 ][ col ] == '1' and not visited [ row - 1 ][ col ]: dfs ( row - 1 , col ) if row < m - 1 and grid [ row + 1 ][ col ] == '1' and not visited [ row + 1 ][ col ]: dfs ( row + 1 , col ) if col > 0 and grid [ row ][ col - 1 ] == '1' and not visited [ row ][ col - 1 ]: dfs ( row , col - 1 ) if col < n - 1 and grid [ row ][ col + 1 ] == '1' and not visited [ row ][ col + 1 ]: dfs ( row , col + 1 ) count = 0 for i in range ( m ): for j in range ( n ): if grid [ i ][ j ] == '1' and not visited [ i ][ j ]: dfs ( i , j ) count += 1 return count","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/13/graph/","title":"图论"},{"text":"内存管理 ，对于Python这样的动态语言是必不可少的。通常的内存管理包括操作系统提供的虚拟内存，以及 垃圾回收机制。本文着重于Python中的垃圾回收机制。 首先我们介绍一下的垃圾回收中通用的基本概念 垃圾回收 如果一个程序可能直接或间接地引用一个对象，那么这个对象就是\"存活的\"，已经引用不到的对象就是\"死亡\" 的。垃圾回收就是要自动的收集并释放这些死亡的对象。 垃圾回收中常见的算法 1. 标记清除(Mark and Sweep) 原理 首先从根开始将可能引用的对象用递归的方式进行标记，然后将没有标记到的对象作为垃圾进行回收。 根 所谓根就是判断对象是否可被引用的起始点。虽然不同的语言编译器对根的规定不同，但基本上是讲变量和运行栈 作为根。 标记清除算法的时间是和存活对象数与对象总数的综合相关的。 还有一种变形 缺点 在分配了大量的对象，并且其中只有一部分存活的情况下，所消耗的时间会大大超过必要的值，这时因为 在清除阶段还需要对大量死亡对象进行扫描。 标记压缩(Mark and Compact) 它不是将标记的对象清除，而是在清理无用对象完成后让所有存活的对象都向一端移动， 并更新引用其对象的指针，节约了内存空间 缺点 压缩过程较慢，效率较低。 复制收集(Copy and Collection) 将从根节点开始被引用的对象复制到另外的空间中，然后将复制的对象能够引用的对象用递归的方式不断复制 下去。 优点 有很好的局部性。在复制过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的 内存空间中的可能性会提高。 缺点 内存减少一半，可用空间减少 2. 引用计数 原理 在每个对象中保存该对象的引用计数，当引用发生增减时对计数进行更新。 引用计数的增减，一般发生在变量赋值、对象内容更新、函数结束等时间点。当一个对象的引用计数变为0时， 则说明它将来不会被引用，因此可以释放相应的内存空间。 缺点 无法回收循环引用 维护引用计数的次数和引用赋值成正比，而不像mark and sweep等基本与回收的内存数量有关。 3. 分代回收 由于GC和程序处理的本质是无关的，因此它消耗的时间越短越好。分代回收的目的就是为了在程序运行期间，将GC所 消耗的时间尽量缩短，是一种空间换时间的策略。 思路 利用一般性程序所具备的性质，即大部分对象在短时间内都会成为垃圾，而经过一定时间依然存活的对象往往 拥有较长的寿命。 增量回收 不等GC全部完成，而是将GC操作细分成多个部分逐一执行。这种方式被成为增量回收。 GC大一统理论 像标记清除和复制收集这样，从根开始进行扫描以判断对象生死的算法，被称为追踪回收（Tracing）。引用 计数算法则是当对象之间的引用关系发生变化时，通过对引用技术进行更新来判断对象生死的。 任何一种GC算法，都是追踪回收和引用计数回收两种思路的组合。 下面就结合Python源码具体说下Python中垃圾回收的实现，更多源码见 Python 源码剖析 Python垃圾回收中的引用计数 每个Python对象都有一个Pyobject_HEAD // object.h struct _object { Py_ssize_t ob_refcnt ; // 应用计数值 struct PyTypeObject * ob_type ; } PyObject ; 其中 ob_refcnt就是利用引用技术来进行垃圾回收的数据结构。 在容器中有循环引用出现的情况下，Python就辅助使用标记清除和分代回收来解决这样的问题。 Python垃圾回收中的标记清除 Python中的垃圾回收机制完全是为了处理循环引用而设计的。 所有容器对象在PyObject_HEAD之前加入PyGC_HEAD来实现标记清除机制。 // objimpl.h typedef union _gc_head { struct { union _gc_head * gc_next ; union _gc_head * gc_prev ; Py_ssize_t gc_refs ; } gc ; long double dummy ; /* force worst-case alignment */ } PyGC_Head ; 垃圾标记时，先将集合中对象的引用计数复制一份副本(以免在操作过程中破坏真实的引用计数值)： // gcmodule.c static void update_refs ( PyGC_Head * containers ) { PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { assert ( gc -> gc . gc_refs == GC_REACHABLE ); gc -> gc . gc_refs = FROM_GC ( gc ) -> ob_refcnt ; assert ( gc -> gc . gc_refs != 0 ); } } 然后操作这个副本，遍历对象集合，将被引用对象的引用计数副本值减1： // gcmodule.c static void subtract_refs ( PyGC_Head * containers ) { traverseproc traverse ; PyGC_Head * gc = containers -> gc . gc_next ; for (; gc != containers ; gc = gc -> gc . gc_next ) { traverse = FROM_GC ( gc ) -> ob_type -> tp_traverse ; ( void ) traverse ( FROM_GC ( gc ), ( visitproc ) visit_decref , NULL ); } } 然后根据引用计数副本值是否为0将集合内的对象分成两类，reachable和unreachable，其中unreachable是可以被回收的对象。 // gcmodule.c static void move_unreachable ( PyGC_Head * young , PyGC_Head * unreachable ) { PyGC_Head * gc = young -> gc . gc_next ; while ( gc != young ) { PyGC_Head * next ; // 对于root object，把gc_refs设置为GC_REACHABLE if ( gc -> gc . gc_refs ) { PyObject * op = FROM_GC ( gc ); traverseproc traverse = op -> ob_type -> tp_traverse ; assert ( gc -> gc . gc_refs > 0 ); gc -> gc . gc_refs = GC_REACHABLE ; ( void ) traverse ( op , ( visitproc ) visit_reachable , ( void * ) young ); next = gc -> gc . gc_next ; } // 对于非root对象移到unreachable链表中，并标记为 // GC_TENTATIVELY_UNREACHABLE else { next = gc -> gc . gc_next ; gc_list_move ( gc , unreachable ); gc -> gc . gc_refs = GC_TENTATIVELY_UNREACHABLE ; } gc = next ; } } 在处理完finalizer等细节之后，就可以对unreasonable链表中的节点进行回收 Python垃圾回收中的分代回收 用来表示\"代\"的结构体是gc_generation， 包括了当前代链表表头、对象数量上限、当前对象数量： // gcmodule.c struct gc_generation { PyGC_Head head ; int threshold ; /* collection threshold */ int count ; /* count of allocations or collections of younger generations */ }; Python默认定义了三代对象集合，代数越大，对象存活时间越长。 #define NUM_GENERATIONS 3 #define GEN_HEAD(n) (&generations[n].head) /* linked lists of container objects */ static struct gc_generation generations [ NUM_GENERATIONS ] = { /* PyGC_Head, threshold, count */ {{{ GEN_HEAD ( 0 ), GEN_HEAD ( 0 ), 0 }}, 700 , 0 }, {{{ GEN_HEAD ( 1 ), GEN_HEAD ( 1 ), 0 }}, 10 , 0 }, {{{ GEN_HEAD ( 2 ), GEN_HEAD ( 2 ), 0 }}, 10 , 0 }, }; 最后在进行垃圾回收的时候，Python从最老的一代（第二代）开始，然后回收这个代 和比它年轻的代。 //gcmodule.c //NUM_GENERATIONS = 3 static Py_ssize_t collect_generations ( void ) { int i ; py_ssize_t n = 0 ; for ( i = NUM_GENERATIONS ; i >= 0 ; i -- ){ if ( generations [ i ]. count > generations [ i ]. threshold ){ n = collect ( i ); break ; } } return n ; } 总结： Python采用了最常用的引用计数来跟踪和回收垃圾。在引用计数的基础上， 通过\"标记-清除\"解决容器对象可能产生的循环引用问题， 通过\"分代回收\"以空间换时间的方法提高垃圾回收效率。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/10/garbage-collection-in-python/","title":"Python中的垃圾回收机制"},{"text":"无论使用什么编程语言，生产一条基本语句所需要的工数几乎是一定的。 —弗雷德里克·布鲁克斯 特定领域语言(Domain Specific Language) 指利用为特定领域所专门设计的词汇和语法，简化程序设计过程，提高 生产效率的技术。 优点 可以直接使用其对象领域中的概念，集中描述\"what\"部分，而不必对\"how\" 进行描述。 外部DSL 像这些迷你语言为代表的，由专用的语言引擎来实现的DSL，称为外部DSL。 XML、SQL、正则表达式就是典型的外部DSL 内部DSL 内部DSL是在现在语言中实现DSL，而作为DSL基础的这种现有语言，称为数组语言。 外部DSL是从UNIX脱胎发展而来的，而内部DSL则是发源于Lisp和Smalltalk Programming is a process of designing DSL for your own application —— 大卫·托马斯 DSL设计的构成要素 上下文（Context） 语句 （Sentence） 单位 （Unit） 词汇 （Vocabulary） 层次结构 （Hierarchy） 元编程 所谓元编程就是用程序来编写程序。在Ruby和Python这样的语言中，由于程序本身的信息是可以被访问的， 因此在程序运行中也可以对程序本身进行操作，这就是元编程。 反射 在C++中，一个对象是知道自己的数据类型的， 通过这个信息，可以在调用虚拟成员函数时，选择与自己的类型相匹配的函数。 像这样获取和变更程序本身信息的功能，被称为反射（Reflection）。 闭包 在函数对象中，将局部变量这一环境封闭起来的结构被称为闭包。 对象：在数据中以方法的形式包含了过程 闭包：在过程中以环境的形式包含了数据 动态运行 就是在运行后总的程序能够识别自身，并对自身进行操作。而程序对自身操作的编程也被称为元编程。 鸭子类型(Duck Typing) 不考虑某个对象到底是哪个类的实例，而只关心它拥有哪些方法，这就是鸭子类型。 结构子类型(Structuaral Subtyping) 以类型的结构来确定可代换性的类型关系，被称为结构子类型。 名义子类型 (Nominal Subtyping) 像Java这样根据声明拥有继承关系的类型具有可代换性的类型关系，被称为名义子类型。 非强制静态类型 在Dart中，没有指定类型的变量和表达式会被当做Dynamic型，其类型检查在运行时完成。 提高动态语言速度的三种技术 JIT(Just In Time Compiler)，指的是在程序运行时将其编译为机器语言的技术。由于编译为机器语言的程序可以以CPU原本的 速度来运行，因此能够克服解释器所带来的劣势。 特殊化，指的是一种在将函数转换为内部表达时所需用的技术。通常假定参数为特殊类型， 事先准备一个特殊化的高速版本，在函数调用的开头先执行类型检查，当前提条件成立时直接运行 高速版本，从而避免了在运行时伴随的大量的类型检查。 分代回收，见 垃圾回收 。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/09/programming-language/","title":"编程语言中的基本概念"},{"text":"编程&技术 1. 系统架构&设计模式 大型网站技术架构 [0%] 设计模式可重用面向对象软件的基础 [10%] HeadFirst 设计模式 [0%] 构建高性能的web站点 [0%] 简约之美：软件设计之道 [0%] 重构:改善既有代码的设计 [10%] 关于系统架构和设计模式的东西了解的不多，至少一些基本原理和方法还是需要懂的 2. 计算机科学 网络 TCP/IP详解卷1 [Done] TCP/IP详解卷2 [10%] Unix网络编程 [10%] 数据结构与算法 算法导论 [Done] 算法概论 [Done] 编程珠玑 [Done] 编程之美 [Done] 剑指offer [Done] Cracking the Coding Interview [60%] 具体数学 [10%] 算法竞赛入门经典训练指南 [10%] 操作系统 深入理解计算机系统 [Done] 鸟哥的Linux私房菜 [Done] Unix 环境高级编程 [20%] 编程语言&程序设计 C C专家编程 [Done] C陷阱和缺陷 [Done] C和指针 [10%] K&R [10%] C++ C++ primer [60%] Effective C++ [10%] More Effective C++ [0%] Python Python基础教程 [Done] Python核心编程 [Done] Django Web开发指南 [Done] 改善Python代码的91个意见[Done] Python高级编程 [40%] Python 源码剖析 [20%] 机器学习 数学之美 [Done] 集体智慧编程 [Done] 统计学习方法 [Done] 机器学习实战 [10%] 程序设计 计算机程序的构造与解释 [10%] 编程实践 代码的未来 [Done] 可读代码的艺术 [10%] 7周7语言 [10%] 代码大全 [0%] 程序员的自我修养-链接装载与库 [10%] 其它 Shell Mysql 正则表达式 3.软件开发 UNIX编程艺术 [30%] 程序员的修炼之道-从小工到专家 [15%] 人件 [10%] 人月神话 [30%] 高效能程序员的45个习惯：敏捷开发之道 [10%] 程序员的思维修炼: 开发认知潜能的九堂课 [25%] 4. 科技人文 浪潮之巅 [Done] 淘宝技术这十年 [Done] 乔布斯转 [Done] 悟空转 [Done] 黄金时代 [Done] 三体1 [Done] 三体2 [40%] 三体3 [0%] 白银时代 [30%] 世界是平的 [Done] 淘宝技术这十年 [Done] mactalk 人生元编程 [Done] 松本行弘的程序世界 [0%] 菊与刀 [60%] 5.思维 禅与摩托车维修艺术 [Done] 自控力 [Done] 天才在左，疯子在右 [Done] 黑客与画家 [Done] 失控 [30%] 禅者的初心 [30%] 影响力 [Done] 思维的乐趣[Done] 暗时间 [Done] 要读书单 思考的快与慢 [0%] 自私的基因 [0%] 乌合之众 [0%] 批判性思维：带你走出思维的误区 [0%] 学习之道 [0%] 黑天鹅：如何应对不可预知的未来 [0%] 从0到1开启商业与未来的秘密 [0%] 6.美剧&英剧 Black Books [Done] Downton Abbey [Done] The IT Crowd [Done] Sherlock [Done] Black Mirror [Done] The Big Bong Thoery [Done] Game of Thrones [Done] Prison Break [Done] Breaking Bad [Done] House of Cards [Done] Hannibal [Done] True Detective [Done]","tags":"编程","loc":"www.houcj.net/blog/2015/05/08/my-booklist/","title":"我的书单"},{"text":"解压缩文件： $ cd /path/to/works $ tar cvzf game.tar.gz works // 压缩 $ tar zxvf game.tar.gz // 解压缩 SCP命令 scp hostfilename remotename@remoteIP:/path/to/remote $ scp ./works.zip root@192.168.56.101:/home/game 修改可执行权限 chmod +x //or chmod 755 Linux下TCP Socket编程 Socket端口重用: setsockopt()改善程序的健壮性 如果在已经处于 ESTABLISHED状态下的socket调用close socket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket,可以使用 SO_REUSEADDR 套接字选项，这个选项通知内核，如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口。如果端口忙，而TCP状态位于 其他状态，重用端口时依旧得到一个错误信息，指明\"地址已经使用中\"。 ： int opt = 1 ; setsockopt ( listenfd , SOL_SOCKET , SO_REUSEADDR , & opt , sizeof ( opt )); 如果要已经处于连接状态的soket在调用close socket后强制关闭，不经历 TIME_WAIT 的过程： bool bDontLinger = FALSE ; setsockopt ( s , SOL_SOCKET , SO_DONTLINGER , ( const char * ) & amp ; bDontLinger , sizeof ( bool ---------- )); 在send()，recv()过程中有时由于网络状况等原因，发收不能预期进行，而设置收发时限： int nNetTimeout = 1000 ; //1秒 //发送时限 setsockopt ( socket , SOL_S0CKET , SO_SNDTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); //接收时限 setsockopt ( socket , SOL_S0CKET , SO_RCVTIMEO , ( char * ) & amp ; nNetTimeout , sizeof ( int )); 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节 (异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据 和接收数据量比较大，可以设置socket缓冲区，而避免了send()，recv()不断的循环收发： // 接收缓冲区 int nRecvBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_RCVBUF , ( const char * ) & amp ; nRecvBuf , sizeof ( int )); //发送缓冲区 int nSendBuf = 32 * 1024 ; //设置为32K setsockopt ( s , SOL_SOCKET , SO_SNDBUF , ( const char * ) & amp ; nSendBuf , sizeof ( int )); 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响 程序的性能： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_SNDBUF , ( char * ) & amp ; nZero , sizeof ( nZero )); 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)： int nZero = 0 ; setsockopt ( socket , SOL_S0CKET , SO_RCVBUF , ( char * ) & amp ; nZero , sizeof ( int )); 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性： BOOL bBroadcast = TRUE ; setsockopt ( s , SOL_SOCKET , SO_BROADCAST , ( const char * ) & amp ; bBroadcast , sizeof ( bool )); 在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可 以设置connect()延时，直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的 作用，在阻塞的函数调用中作用不大) bool bConditionalAccept = TRUE ; setsockopt ( s , SOL_SOCKET , SO_CONDITIONAL_ACCEPT , ( const char * ) & amp ; bConditionalAccept , sizeof ( BOOL )); 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket()，以前我们 一般采取的措施是\"从容关闭\"shutdown(s，SD_BOTH)，但是数据是肯定丢失了，如何设置让程序满足具体 应用的要求(即让没发完的数据发送出去后在关闭socket)？ struct linger { u_short l_onoff ; u_short l_linger ; }; linger m_sLinger ; m_sLinger . l_onoff = 1 ; //(在closesocket()调用，但是还有数据没发送完毕的时候容许逗留) // 如果m_sLinger.l_onoff=0;则功能和2.)作用相同; m_sLinger . l_linger = 5 ; //(容许逗留的时间为5秒) setsockopt ( s , SOL_SOCKET , SO_LINGER , ( const char * ) & amp ; m_sLinger , sizeof ( linger )); PS: 1. 在设置了逗留延时，用于一个非阻塞的socket是作用不大的，最好不用 2. 如果想要程序不经历SO_LINGER需要设置SO_DONTLINGER，或者设置l_onoff=0； 还一个用的比较少的是在SDI或者是Dialog的程序中，可以记录socket的调试信息： (前不久做过这个函数的测试，调式信息可以保存，包括socket建立时候的参数，采用的 具体协议，以及出错的代码都可以记录下来） bool bDebug = TRUE ; setsockopt ( s , SOL_SOCKET , SO_DEBUG , ( const char * ) & amp ; bDebug , sizeof ( BOOL )); 粘包 指TCP协议中，发送方发送的若干包数据到接收时粘成以包，从接收缓存看，后一数据的 头紧接着前以包数据的尾。 粘包出现的原因 发送端需要等缓冲区满才发送出去，造成粘包 接收方不及时接受缓冲区的包，造成多个包接收 粘包解决方法 使用TCP中的强制数据立即传送操作指令PUSH 接收方提高接收进程的优先级，或者将一个包中的数据按结构字段，人为控制接受方式。","tags":"编程","loc":"www.houcj.net/blog/2015/05/07/huawei-related/","title":"德州扑克AI"},{"text":"首先介绍最简单的反转链表 题目描述: Reverse a singly linked list. 分析： 题目比较简单，可以使用迭代或者递归分别实现。 迭代实现 原链表中的元素依次插入到新的链表中，作为新链表的第一个元素，这里需要注意的是，防止断链。 def reverseList ( self , head ): dummy = ListNode ( - 1 ) cur = None dummy . next = cur while head : q = head . next # 防止断链 dummy . next = head head . next = cur cur = head head = q return dummy . next 或者 原地迭代，每次都把当前的节点链接到到前一个节点。 def reverseList2 ( self , head ): pre = None cur = head while cur : p = cur . next # 保存下一个元素 cur . next = pre # 把当前的指针链接到前一个元素 pre = cur cur = p return pre 递归实现 每次都把下一个节点链接到当前节点。 def reverseList1 ( self , head ): if ( not head ) or ( not head . next ): return head q = self . reverseList1 ( head . next ) head . next . next = head head . next = None return q 进阶1 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, return 1->4->3->2->5->NULL 分析 关键是找到反转位置的节点， def reverseBetween ( self , head , m , n ): pre = dummy = ListNode ( - 1 ) dummy . next = head count = 1 while count < m : pre = pre . next # 找到反转节点的前一个节点 head = head . next #当前的反转节点 count += 1 while count < n : p = head . next # 把当前反转节点的下一个节点依次插入到链表中 head . next = p . next # 保证head节点指向n以后的节点 p . next = pre . next pre . next = p count += 1 return dummy . next 进阶2 题目描述 Reverse a linked list from position m to n. Do it in-place and in one-pass. For example: Given 1->2->3->4->5->NULL, m = 2 and n = 4, Given a linked list, reverse the nodes of a linked list k at a time and return its modified list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is. You may not alter the values in the nodes, only nodes itself may be changed. Only constant memory is allowed. For example, Given this linked list: 1->2->3->4->5 For k = 2, you should return: 2->1->4->3->5 For k = 3, you should return: 3->2->1->4->5 return 1->4->3->2->5->NULL 分析 找到反转字符串的起点和终点，然后再把它们连接起来。只需要扫描一遍链表即可，时间复杂度O(N)。 def reverseKGroup ( self , head , k ): pre = tail = dummy = ListNode ( - 1 ) dummy . next = head while 1 : count = k while tail and count : count -= 1 tail = tail . next if not tail : break head = pre . next # for the next cycle while pre . next != tail : p = pre . next # assign pre . next = p . next # delete p . next = tail . next #tail the beging of the reverse list tail . next = p # insert tail = head pre = head return dummy . next 完整代码见 Github","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/reverse-linked-list/","title":"反转链表"},{"text":"题目描述 : Count the number of prime numbers less than a non-negative number, n 分析 ： 这里需要注意的是n是很大的整数，因此不能在循环内使用函数的调用来判断一个数是否为素数，否则会超时。可以使用bool数组来确定这个数是否为素数。下面介绍一种素数筛选法来解决这个问题。 素数筛选法就是的理论基础就是每个合数都是可以分解为两个或者多个素数相乘的形式。首先除2以外的偶数都不是素数，另外，对于素数3，它的倍数3*5，3*7，...，3*n，都不是素数。 剩下都是素数。 具体见下面的代码。 class Solution { public : int countPrimes ( int n ) { if ( 2 >= n ) return 0 ; bool * a = new bool [ n ]; for ( int i = 0 ; i < n ; i ++ ){ if ( i % 2 == 0 ) { a [ i ] = false ; } // 除2以外的偶数都不是素数 else { a [ i ] = true ; } } a [ 1 ] = false ; // 1 不是素数 a [ 2 ] = true ; // 2 是素数 int sn = int ( sqrt ( n )); for ( int i = 3 ; i < sn + 1 ; i += 2 ){ if ( a [ i ]) { for ( int j = i * i ; j < n ; j += i << 1 ) // i的奇数倍都不是素数 { a [ j ] = false ; } } } int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ]) { sum += 1 ; } } delete [] a ; return sum ; } }; Python代码实现见 Github ，需要注意的是Python中的bool数组必须声明为[True]*n.","tags":"编程","loc":"www.houcj.net/blog/2015/05/05/sifting-prime/","title":"素数筛选法"},{"text":"间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 读未初始化的存储器 虽然bss存储器位置总是被加载器初始化为零，但对于堆存储器不是这样的。在堆中初始化的元素的值是不确定的 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )); } } 引用指针而不是它所指向的对象 int * binheapDelete ( int ** binheap , int * szie ) { int * packet = binheap [ 0 ]; binheap [ 0 ] = binheap [ * szie - 1 ]; * size -- ; //should be (*size)-- heapify ( binheap , * size , 0 ); return ( packet ); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } /*C程序中常见的与存储器有关的错误 */ 间接引用坏指针 scanf ( \"%d\" , & val ); //right scanf ( \"%d\" , val ); //wrong，会把val的内容当成地址读进去 允许栈缓冲区溢出 如果一个程序不检查输入串的大小就写如栈中的目标缓冲区，那么这个程序就会有缓冲区溢出错误。 void bufoverflow () { char buf [ 64 ]; gets ( buf ); //stack buffer flow return ; // should use fgest to limit the input size } 假设指针和他们指向的对象是相同大小 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i < n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 造成错位（off-by-one）错误 int ** makeArray ( int n , int m ) { int i ; int ** A = ( int ** ) malloc ( n * sizeof ( int )); //wrong int ** A = ( int ** ) malloc ( n * sizeof ( int * )); //right for ( i = 0 ; i <= n ; i ++ ) { A [ i ] = ( int * ) malloc ( n * sizeof ( int )) } } 引用指针而不是它所指向的对象 int *binheapDelete(int **binheap, int *szie) { int *packet = binheap[0]; binheap[0] = binheap[*szie -1]; *size--;//should be (*size)-- heapify(binheap, *size, 0); return(packet); } 误解指针运算 int ** search ( int * p , int val ) { while ( * p && * p != val ) p += sizeof ( int ); //should be p++ return p } 引用不存在的变量 int * stackref () { int val ; // illegal variable return & val ; } 引用空闲堆块中的数据 int ** heapref ( int n , int m ) { int i ; int * x , * y ; x = ( int * ) malloc ( n * sizeof ( int )); free ( x ); y = ( int * ) malloc ( n * sizeof ( int )); for ( i = 0 ; i <= n ; i ++ ) { y [ i ] = x [ i ] ++ ; //x[i] is a word in free block } } 引起存储器泄露 int leaf ( int n ) { int * x = ( int * ) malloc ( n * sizeof ( int )); return ; // x is garbatge at this point } strcpy（）函数 #include<stdio.h> int main ( int argc , char * argv []) { int flag = 0 ; char passwd [ 10 ]; memset ( passwd , 0 , sizeof ( passwd )); strcpy ( passwd , argv [ 1 ]); /*argv[1] = \"aaaaaaaaaaaaa\"是，下面的flag也为1*/ if ( 0 == strcmp ( \"LinuxGeek\" , passwd )) { flag = 1 ; } if ( flag ) { printf ( \" \\n Password cracked \\n \" ); } else { printf ( \" \\n Incorrect passwd \\n \" ); } return 0 ; } 破解上述加密的关键在于利用攻破strcpy()函数的漏洞。 所以用户在向\"passwd\"缓存输入随机密码的时候并没有提前检查\"passwd\"的容量是否足够。 所以，如果用户输入一个足够造成缓存溢出并且重写\"flag\"变量默认值所存在位置的内存的长\"密码\"， 即使这个密码无法通过验证，flag验证位也变成了非零，也就可以获得被保护的数据了。 要避免这样的问题， 建议使用 strncpy()函数 。 - 修改代码片段（只读代码） #include<stdio.h> int main ( void ) { char * ptr = \"China\" ; * ptr = 'A' ; printf ( \" \\n [%s] \\n \" , ptr ); return 0 ; } 通过*ptr = ‘T'，会改变内存中代码段（只读代码）\"China\"的第一个字母。 这个操作是无效的，因此会造成seg-fault或者崩溃。","tags":"编程","loc":"www.houcj.net/blog/2015/05/04/usual-error-in-c/","title":"C程序中常见的与存储器有关的错误"},{"text":"We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. ~Donald Knuth 程序员必须再实现和维护程序的简单性与它的运行速度之间做出权衡。 优化编译器的能力和局限性 编译器必须很小心地对程序只使用安全的优化。程序中有两个妨碍优化的因素。 - 存储器别名使用 void add1 ( int * xp , int * yp ) { * xp += * yp ; * xp += * yp ; } void add2 ( int * xp , int * yp ) { * xp += 2 * * yp ; } 编译器并不会把第一个函数优化成第二个函数，因为如果考虑到 xp 等于 yp 的情况。twiddle1 中的 xp 会增加 4 倍，而 twiddle2 中的 xp 仅会增加 2 倍。 函数调用 作为一个示例，考虑下面这两个过程： int f (); int func1 () { return f () + f () + f () + f (); } int func2 () { return 4 * f (); } 编译器也不会吧第一个函数优化为第二个，考虑下面 f 的代码： int counter = 0 ; int f () { return counter ++ ; } 这个函数有个副作用：它修改了全局程序状态的一部分。改变调用它的次数会改变程序的行为。 考虑下面所示的简单向量数据结构： typedef int data_t ; typedef struct { long int len ; data_t * data ; } vec_rec , * vec_ptr ; 一段合并运算的代码： void combine1 ( vec_ptr v , data_t * dest ) { long int i ; * dest = IDENT ; for ( i = 0 ; i < vec_length ( v ); i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 其中 vec_length 获取 v 的长度，get_vec_elemnet 获取内容。 特别的，使用声明： #define IDENT 0 #define OP + 它对向量的元素求和。 #define IDENT 1 #define OP * 它计算的是向量元素的乘积。 - 消除循环的低效率 void combine2 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { data_t val ; get_vec_element ( v , i , & val ); * dest = * dest OP val ; } } 这种优化我们称之为代码移动。 减少过程调用 在 combine2 中，每次循环都要调用 get_vec_element ，为了减少过程调用，代码如下: data_t * get_vec_start ( vec_ptr v ) { return v -> data ; } void combine3 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); * dest = IDENT ; for ( i = 0 ; i < length ; i ++ ) { * dest = * dest OP data [ i ]; } } 但是这段代码得到的性能提高出乎意料的普通，只提高了整数求和的性能。 - 消除不必要的存储器引用 在我们将 combine3 生成汇编代码后，可以看出，在每次迭代中，程序都要读取出指针 dest 处的值，乘以 data[i]，再将结果存回到 dest。这样的读写显得很是浪费。 考虑如下代码： void combine4 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_length ( v ); data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 我们引入一个临时变量 acc， 它在循环中用来累计计算来的值。只有再循环完成之后结果才存放到 dest 中。在汇编代码中可以看到，编译器会使用一个寄存器来保存累积值。与 combine3 中的循环相比，我们将每次迭代的存储器操作从两次读和一次写减少到只需要一次读。 循环展开 循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。（如果展开后不能很好的提高程序的并行性还是不要展开） void combine5 ( vec_ptr v , data_t * dest ) { long int i ; long int length = vec_lenght ( v ); long int limit = length - 1 ; data_t * data = get_vec_start ( v ); data_t acc = IDENT ; for ( i = 0 ; i < limit ; i += 2 ) { acc = ( acc OP data [ i ]) OP data [ i + 1 ]; } for (; i < length ; i ++ ) { acc = acc OP data [ i ]; } * dest = acc ; } 提高性能的技术 高级设计: 为遇到的问题选择适当的算法和数据结构。 基本编码原则: 消除连续的函数调用 消除不必要的存储器引用：引入临时变量来保持中间结果。只有在最后的值计算出来时，才将结果存放到数组或全局变量中。 低级优化 展开循环，降低开销，并且使得进一步优化成为可能。 通过使用例如多个累积变量和重新结合技术，找到方法提高指令级并行。 用功能得风格重写条件操作，使得编译采用条件数据传送。 关于程序的优化，最常见的是优化是选择合适的算法和数据结构，这个是起决定性作用的，基本编码原则还是要遵守的，至于低级优化还要考虑程序的局部性等问题。Amdahl定律为我们描述了一个改进任何过程的通用原则，当我们加快系统一个部分的速度时，对系统整体性能的影响依赖于这个部分有多重要和速度提高了多少。 $$\\frac{1}{(1-\\alpha)+\\alpha/k}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2015/05/01/optimizing-program-performance/","title":"程序性能优化"},{"text":"24点游戏 是一种使用扑克牌来进行的益智类游戏，游戏内容是：从一副扑克牌中抽去大小王剩下52张，任意抽取4张牌，把牌面上的数（A代表1）运用加、减、乘、除和括号进行运算得出24。每张牌都必须使用一次，但不能重复使用。在不同版本中，对J、Q、和K的处理有些差异。一个常见的版本是把J、Q、和K去除，或当成10；还有一个版本是把J表示11，Q表示12，K代表13。 虽然大多数24点存在很多解法，有相当一部分数字组合只存在唯一的解法。这种组合往往较有难度，也较为有趣。这里总结一些常见的组合。 分数运算 虽然给出4个数字都是整数，中间步骤中有时会出现分数。这种4个数字的组合往往较有难度。一个经典的例子是1，5，5，5，其解答为5 × (5 − 1 ÷ 5) = 24；另外 一个例子是3，3，8，8，其解答为8 ÷ (3 - 8 ÷ 3) = 24。 大数／奇数运算 有些组合中会涉及到一些较大数字，这些组合通常较有难度。比如4、4、10、10的解法为(10 × 10 − 4) ÷ 4 = 24，5、6、6、9的解法为6 × 9 − 5 × 6 = 24。 下面的代码可以解决上面出现的情况。 Show the code def PointGame ( n ): i = 0 if ( n == 1 ): if matrix [ 0 ][ 0 ] == matrix [ 0 ][ 1 ] * 24 : return True else : return False for i in range ( 0 , n ): for j in range ( i + 1 , n ): # use two dimention array a = matrix [ i ][ 0 ] b = matrix [ i ][ 1 ] c = matrix [ j ][ 0 ] d = matrix [ j ][ 1 ] # python needs the deepcopy to copy the value to the destination matrix [ j ] = copy . deepcopy ( matrix [ n - 1 ]) expa = result [ i ] expb = result [ j ] result [ j ] = result [ n - 1 ] result [ i ] = '(' + expa + '+' + expb + ')' matrix [ i ][ 0 ] = a * d + b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '-' + expb + ')' matrix [ i ][ 0 ] = a * d - b * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expb + '-' + expa + ')' matrix [ i ][ 0 ] = b * c - a * d matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True result [ i ] = '(' + expa + '*' + expb + ')' matrix [ i ][ 0 ] = a * c matrix [ i ][ 1 ] = b * d if ( PointGame ( n - 1 )): return True if c != 0 : result [ i ] = '(' + expa + '/' + expb + ')' matrix [ i ][ 0 ] = a * d matrix [ i ][ 1 ] = b * c if ( PointGame ( n - 1 )): return True if a != 0 : result [ i ] = '(' + expb + '/' + expa + ')' matrix [ i ][ 0 ] = b * c matrix [ i ][ 1 ] = a * d if ( PointGame ( n - 1 )): return True # restore the value matrix [ i ][ 0 ] = a matrix [ i ][ 1 ] = b matrix [ j ][ 0 ] = c matrix [ j ][ 1 ] = d result [ i ] = expa result [ j ] = expb i += 1 return False 完整的代码见 Github 代码持续更新，该算法的核心就是穷举每种出现的可能，为了更好的实现，上面的代码对数字出现的顺序有一定的要求。不同的顺序得到的结果可能不一样。","tags":"编程","loc":"www.houcj.net/blog/2015/04/25/cal24/","title":"24点游戏编程"},{"text":"操作系统内核是应用程序和硬件之间的媒介。它提供三个基本抽象： 文件是对I/O设备的抽象 虚拟存储器是对主存和磁盘的抽象 进程是对处理器、主存和I/O设备的抽象 系统中所有的信息，都是一串位表示的。区分不同数据对象的唯一方法就是我们读到这些数据对象时的上下文。 预处理->编译->汇编->链接 程序的机器级表达 数据传递、局部变量的分配和释放通过操作程序栈来实现。机器用栈来传递过程参数、存储返回信息、保存寄存器用于恢复，以及本地存储。为单个过程分配的那部分栈称为栈桢。最顶端的栈桢以两个指针界定，寄存器%ebp为帧指针，寄存器%esp为栈指针。 存储器层级结构 计算机系统中的一个基本而持久的思想：如果你理解了系统是如何将数据在存储器层次结构中上上下下移动的，那么你可以编写你的应用程序，使得它们的数据项存储在层次结构中较高的地方，在那里CPU能更快地访问到它们。这个思想围绕着计算机程序的一个成为局部性（locality）的基本属性。 局部性通常有两种形式：时间局部性（temporal locality）和空间局部性（spatial locality）。在一个具有良好时间局部性的程序中，被引用过一次的存储器位置很可能在不远的将来再被多次引用。在一个具有良好空间局部性的程序中，如果一个存储器位置被引用了一次，那么程序很可能在不远的将来引用附近的一个存储器位置。 理解存储器层次结构的本质的程序员能够利用这些知识，编写出更有效的程序，无论具体的存储系统结构是怎样的，应使用以下技术： 将你的注意力一种在内部循环上，大部分计算机和存储器访问都发生在这里 通过按照数据对象存储在存储器中的顺序、以步长为1来读数据，从而使得你程序中的空间局部性最大 一旦从存储器中读入了一个数据对象，就尽可能多地使用它，从而使得你程序中的时间局部性最大 高速缓存行、组和块的区别： 块是一个固定大小的信息包，是高速缓存和主存来回传送信息的基本单位 行是高速缓存中存储块以及其他信息（有效位和标记位）的容器 组是一个或多个行的集合 直接映射高速缓存中，组和行是等价的。因为一行总是存储一个块，所以行和块通常可以互换使用。 cache friendly code 最常见的情况运行得最快 每个缓存内部缓存不明中数量最小。 对局部变量的反复引用是好的，因为编辑器能够将它们缓存在寄存器文件中（时间局部性） 步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储在连续的块。（空间局部性） 异常控制流 进程会因为三种原因终止： 收到一个信号，该信号的默认行为是终止进程。 从主程序返回 调用exit函数。 父进程通过fork函数创建一个新的运行子进程。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括text，data，bss，heap以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝。 父进程与新创建的子进程之间最大的区别在与它们有不同的PID。 fork函数调用一次却会返回两次，一次在是在调用父进程中，一次在新创建的子进程中。 父进程中，fork返回子进程的PID 子进程中，fork返回0。 父进程和子进程是并发运行的独立进程。 当fork在新进程中返回时，新进程现在的寻你存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中任一个后来进行写操作时，写时拷贝机制就会创建新页面。 回收子进程 当一个进程由于某种原因终止时，内核并不是立即把它从系统中清除，相反，进程被保持在一种已终止的状态中，知道被它的父进程回收。当父进程回收已终止的子进程时，内核讲子进程的退出状态传递给父进程，然后抛弃已终止的进程。一个被终止了但是还未回收的进程称为僵尸进程。 发送信号 Unix系统提供了大量向进程发送信号的机制。所有这些机制都是基于进程组（process group）这个概念的。 每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。默认地，一个子进程和它的父进程同属于一个进程组。 unix> /bin/kill -9 -12345 一个负的PID会导致信号被发送到进程组PID中的每个进程。 因为信号处理程序的逻辑控制流与主函数的逻辑控制流重叠，信号处理程序和住函数并发低运行 非本地跳转 在应用层，C程序可以使用非本地跳转来规避正常的调用/返回栈规则，并且直接从一个函数分治到另一个函数。 setjmp 函数在env缓冲区中保存当前调用环境，以供后面longjmp使用，并返回0.调用环境包括PC，stack pointer 和通用目的寄存器。 longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。然后setjmp返回，并带有非零的返回值retval。 setjmp函数只被调用一次，但返回多次：一次是当第一次调用setjmp，而调用环境保存在缓冲区env中时；一次是为每个相应的longjmp调用。另一方面longjmp调用一次，但从不返回。 可以把try语句中的catch自居看作类似与setjmp函数。throw语句类似与longjmp函数。 虚拟存储器 虚拟存储是对主存的一个抽象。支持虚拟存储器的处理器通过使用一种叫做虚拟寻址的间接形式来引用主存。 现代系统通过将虚拟存储器骗和磁盘上的文件片关联起来，以初始化虚拟存储器骗，这个过程叫做存储器映射。 SRAM缓存表示位于CPU和主存之间的L1、L2、L3高速缓存，DRAM缓存表示虚拟存储器系统的缓存，它在主存中缓存虚拟页。 由于大的不命中处罚，DRAM缓存是全相连的。因为对磁盘的访问时间很长，DRAM缓存总是使用写回，而不是直写。 按需也买年调度和独立的虚拟地址空间的结合，简化了连接和加载、代码和数据共享，以及应用程序的存储器分配。 一个给定的linux系统上每个进程都使用类似的存储器格式。文本节总是从虚拟地址0x08048000处开始（对于32位地址空间），或者从0x400000处开始（64位地址空间）。数据和bss节紧跟在text segement后面。栈占据进程地址空间最高的部分，并向下生长。 结合告诉缓存和虚拟存储器的主要思路是地址翻译发生在高速缓存查找之前。 在MMU中包含了一个关于PTE（page table entry）的小缓存，称为TLB。TLB是一个小的、虚拟寻址的缓存，其中每一行都保存着一个由单个PTE组成的块。 用来压缩页表的常用方法是使用层级结构的页表 匿名文件 匿名文件是由内核创建的，包含的全是二进制零。CPU第一次引用这样一个区域内的虚拟页面时，内核就在物理存储器中找到一个合适的牺牲页面，如果页面被修改过就将这个页面换出，用二进制0覆盖牺牲页面并更新页表。 动态分配器 动态分配器维护着一个进程的虚拟存储器区域，称为堆。堆是一个请求二进制零的区域，它紧接在未初始化的bss区域后开始，并向上生长。 对于每个进程，内核维护着一个变量brk，它指向堆的顶部。 动态分配器有两种基本风格。 显式分配器，要求应用显示地释放任何已经分配的块（block） 隐式分配器，要求分配器检测一个已分配块何时不再被程序所使用，就释放这个快，也叫垃圾收集器。 calloc是一个基于malloc的wrapper函数，它将分配的存储器初始化为零。想要改变一个以前已分配块的大小，可以使用realloc函数。 程序使用动态分配器分配的最重要原因是 经常知道程序实际运行时，它们才知道某些数据结构的大小 分配器的要求和目标 显示分配器必须在以下严格的约束条件下工作： 处理任意请求序列，即不可以假设分配和释放请求的顺序 立即响应请求，不允许分配器为了提供高性能重新排列或者缓冲请求 只使用堆，任何非标量数据结构都必须保存在堆里。 对齐块，分配器必须对齐块，使得它们可以保存任何类型的数据对象。 不修改已分配的快，压缩已分配的块这样的技术是不允许的。 碎片 内部碎片，是在一个已分配块比有效载荷大时发生的。 外部碎片，是当空闲存储器合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以来处理这个请求时发生的。 分配器长采用启发式策略来师徒维持少量的大空闲块，而不是维持大量的小空闲块。 如果分配器不能为请求块找到合适的空闲块，那么分配器就会通过调用sbrk函数，向内核申请额外的堆存储器。分配器讲额外的存储器转化为一个大的空闲块，将这个块插入到空闲链表中， 然后将被请求的块放置在这个新的空闲块中。 分离存储 就是维护多个空闲链表，其中每个链表中的块的大小大致相等。 简单分离存储，使用简单分离存储，每个大小类（size class）的空闲链表包含大小相等的块，每个块的大小就是这个大小类中的最大元素的大小。要释放一个块，分配器只要简单的讲这个块插入到相应的空闲链表的前部。 优点，分配和释放都是很快的常数时间 缺点，简单分离存储很容易造成内部和外部碎片 分离适配，使用分离适配，分配器维护着一个空闲链表的数组，每个空闲链表是和一个大小类相关联的，并且被组织成某种类型的显式或隐式链表。 优点，对分离空闲链表的简单的首次适配搜索，其存储器利用率接近于对整个堆的最佳适配搜索的存储器利用率。 伙伴系统 伙伴系统是分离适配的特例，其中每个大小类都是2的幂。为了分配一个大小为2&#94;k的块，我们找到第一个可用的大小为2&#94;j的块，其中 k<=j<=m(堆的大小为2&#94;m)。如果j = k,搜索完成，否则递归二分割这个块，直到j = k。当我们进行这样的分割时，每个剩下的半块（也叫做伙伴）被放置在相应的空闲链表中。要释放一个大小为2&#94;k的块，我们继续合并空闲的伙伴。当我们遇到一个已分配的伙伴时，就停止合并。 垃圾收集 在一个支持垃圾收集的系统中，应用显示分配堆块，但是从不显式释放它们。垃圾收集器定期识别垃圾块，并相应地调用free，将这些块放回到空闲链表中。 C程序中的 Marki&Sweep收集器必须是保守的，因为C语言不会用类型信息来标记存储器位置。想int或者float这样的标量可以伪装成指针。 并发编程 I/O多路服用技术 优点 它比基于进程的程序设计给了程序员更多的对程序行为的控制。 一个基于I/O多路服用的事件驱动服务器是运行在单一进程上下文中的，因此每个逻辑流都能访问该进程的全部地址空间。这使得在流之间共享数据变得很容易。 缺点 编码复杂 不能充分利用多核处理器 线程 运行在进程上下文中的逻辑流。线程由内核自动调度。每个线程都有它自己的线程上下文，包裹一个唯一的整数线程ID、栈，栈指针，程序计数器、通用目的寄存器和条件吗。 和一个线程相关的线程组成一个线程池，独立于其他线程创建的线程。主线程和其他线程的区别仅在于它总是进程第一个运行的线程。线程池主要的影响是，一个线程可以杀死它的任何对等线程，或者等待它的任何对等线程终止。 在任何一个时间点上，线程是可结合（joinable）或者是可分离的（detached）。 - 可结合的，一个可结合的线程能够被其他线程回收其至于那和杀死。在回收之前，它的存储器资源是没有释放的 - 可分离的，一个可分离的线程是不能别其他线程回收或杀死的。它的存储器资源在它终止时由系统自动释放。","tags":"计算机科学","loc":"www.houcj.net/blog/2015/04/15/csapp/","title":"深入理解计算机系统"},{"text":"Programs must be written for people to read, and only incidentally for machines to execute. — Abelson & Sussman, Structure and Interpretation of Computer Programs 1. 交换变量 一般交换变量有以下三种方法： 最常用的，就是设置一个临时变量 temp = x ; x = y ; y = x ; 这种方法在python中可以更优雅的表示，而且效率更高。 x , y = y , x 不增加临时变量使用加法 b = a + b a = b - a # a = a + b - a = b 即 a = b b = b - a # b = a + b - b = a 使用位操作 b = a &#94; b a = a &#94; b b = a &#94; b 使用\"+\"和\"-\"的一行操作: a = ( a + b ) - ( b = a ) 2. Python字典中判断键值是否存在 一般情况会是用一个判断语句 dic = { 'key' : 'value' } if 'key' in dic : print dic [ 'key' ] else : print 'not found' 在python中可以内置的get函数即可 print dic . get ( 'key' , 'not found' ) 3. 读取文件 python中有三个方法来处理文件内容的输入： read（） 一次读取全部的文件内容。 f = open ( 'path/to/file.txt' , 'r' ) ff = f . read () f . close () readline() 每次读取文件的一行。 f = open ( 'path/to/file.txt' , 'r' ) line = f . readline () while 1 : if line : print line else : break f . close () readlines() 读取文件的所有行，返回一个字符串列表 f = open ( 'path/to/file.txt' , 'r' ) ff = f . readlines () f . close () 由于文件操作需要注意文件的打开和关闭操作，因此更优雅的做法是 with open ( 'path/to/file.txt' , 'r' ): for line in f : do_somenthing ( line ) 4. while 1 还是 while True？r 在python 2中，由于 True 不是关键字，因此可以对True进行赋值。下面的语句是可以的 True = 'Hello' 因此在无限循环中，我们应该使用while 1，因为while True在每次 while循环时都会有对True的判断操作。 下面使用dis，Disassembler for Python bytecode,即把python代码反汇编为字节码指令， 模块观察生成的字节码。 In [ 10 ]: import dis In [ 11 ]: def while_one (): .... : while 1 : .... : pass .... : In [ 12 ]: def while_true (): .... : while True : .... : pass .... : In [ 13 ]: if __name__ == '__main__' : .... : Print 'while 1' .... : dis . dis ( while_one ) .... : Print 'while True' .... : dis . dis ( while_true ) ##########output while 1 2 0 SETUP_LOOP 3 ( to 6 ) 3 >> 3 JUMP_ABSOLUTE 3 >> 6 LOAD_CONST 0 ( None ) 9 RETURN_VALUE while True 2 0 SETUP_LOOP 10 ( to 13 ) >> 3 LOAD_GLOBAL 0 ( True ) 6 POP_JUMP_IF_FALSE 12 3 9 JUMP_ABSOLUTE 3 >> 12 POP_BLOCK >> 13 LOAD_CONST 0 ( None ) 16 RETURN_VALUE 5. string的连接 对一个可迭代对象，经常需要对其中的字符串元素进行连接操作，这时候一般有下面两种方法 '+' 和 'join' 。 使用'+'进行操作时，每次都需要创建新的对象，然后再对新的对象进行操作。 计数出要join的所有字符串的长度，然后进行一一拷贝，这样只有一次对象生成 #This is good to glue a large number of strings for chunk in input (): my_string . join ( chunk ) 因此处于内存的考虑，应尽量使用join操作。 6. string的反转 string的反转可以使用for循环从右向做输出。代码如下 def reverse_str ( string ): return '' . join ( string [ i ] for i in range ( len ( string ) - 1 , - 1 , - 1 )) 或者使用递归 def reverse_str1 ( string ): if len ( string ) <= 1 : return string return reverse_str ( string [ 1 :]) + string [ 0 ] 当然最简单和效率最高的是使用切片。 def reverse_str1 ( string ): return string [:: - 1 ] 7. 字典中的setdefault函数 我们经常需要使用字典来初始化数据，每个字典的值是一个列表。通常使用以下的方法 dics = {} for ( val , dic ) in data : if val in dics : dics [ val ] . append ( dic ) else : dics [ val ] = [ dic ] 通过setdefault可以优化为 dics = {} for ( val , dic ) in data : dics . setdefault ( val , []) . append ( dic ) 8. 列举 在python中遍历list获得index和item。可以通过下面的代码： index = 0 for item in lst : print index , item index += 1 # or for index in range ( len ( lst )): print index , lst [ index ] 而使用enumerate可以使代码更清晰， 更易读。 for ( index , item ) in lst : print index , item 9. 列表展开（list comprehension） 列表展开比一般的循环操作的效率更高，而且更简单。 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] for i in range ( len ( a )): a [ i ] = i ** 2 // ** 比 pow （）的效率更高，因此它在 python 中是一个运算符 或者更高的实现 a = [ 1 , 1 , 2 , 3 , 5 , 8 ] a = [ val ** 2 for val in a ] # or : a = map ( lambda i : i ** 2 , a ) 10. 很长的序列使用xrange() 相对于 range() 一次性载入整个序列， xrange() 可以帮你省下许多内存，因为它一次只载入一个元素。 11.字典和列表 在Python中，字典是基于hash table实现的。因此查找操作的复杂度是O(1),而list实际是个数组，查找操作的复杂度是O(n)。 def test (): t = time . time () lst = [ 'the' , 'zen' , 'of' , 'python' , 'Beautiful' , 'is' , 'better' , 'than' , 'ugly' ] found = [ 'Explicit' , 'is' , 'better' , 'than' , 'implicit' ] #lst = dict.fromkeys(lst,1) for i in xrange ( 10 ** 7 ): for token in found : if token not in lst : pass print time . time () - t 当直接在list中进行查找时上述代码执行了7.14800000191s，当去掉注释，使用字典使，上述代码执行了2.4960000515s，效率提高了大约1.9倍。因此当需要对数据进行频繁访问和查找的时候，dict比list具有更大的优势。 12. 生成器 要理解生成器，首先需要理解Python迭代的内部机制：Python中的迭代就是对可迭代对象实现了__iter__()方法和迭代器(iterator)实现了__next__()方法的一个操作过程。就是说，可迭代对象的__iter__()方法可以返回迭代器，迭代器通过调用next()方法获取其中的每一个值。 任何你可用 \"for... in...\" 处理的都是可迭代对象：列表，字符串，文件.... 这些迭代对象非常便捷，但是当有大量数据要使用内存的时候，必须要使用生成器了。 生成器是用来生成迭代器的函数，它的返回值是yield而不是return。因为生成器并没有将所有值放入内存中，而是实时地临时的生成这些值。 下面用打印出全排列来说明声明生成器的具体实现 def perm ( self , arr , pos = 0 ): if pos == len ( arr ): yield arr for i in range ( pos , len ( arr )): arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] #swap the elements sequential for x in self . perm ( arr , pos + 1 ): yield x arr [ pos ], arr [ i ] = arr [ i ], arr [ pos ] 当生成器要一个数时，生成器会执行，直至出现yield语句，生成器返回yield参数，之后生成器停止继续执行。 当需要下一个数时，生成器从上次的状态开始执行，直至出现yield语句，返回参数，停止。如此反复。 13. Python中有用的数据结构 Counter() Counter 用于统计可hash对象出现的次数。并以降序排序输出。 import collection string = \"the zen of python\" print collections . Counter ( string ) #output Counter ({ ' ' : 3 , 'e' : 2 , 'h' : 2 , ' \\n ' : 2 , 'o' : 2 , 'n' : 2 , 't' : 2 , 'f' : 1 , 'p' : 1 , 'y' : 1 , 'z' : 1 }) Deque Deque支持线程安全，内存优化的append和pop操作，在队列两端的插入和删除操作都近乎O(1)的时间复杂度。而list在处理即改变列表长度又改变元素位置的操作，如insert(0,v),pop(0)的时间复杂度就基本为O(n)。 Heapq heapq使用一个堆实现的优先队列。堆是一个二叉树，它的孩子节点的值都小于或者等于父亲节点（最小堆)。常见的有以下几种操作。 heapq.heappush(heap, item) 把item的值push到heap中，同时保持heap的性质。 heapq.heappop(heap) 弹出堆顶的元素 heapq.heapify(x) 在线性时间内把list x 转化为一个堆。","tags":"编程","loc":"www.houcj.net/blog/2015/04/01/life-is-short-use-python/","title":"人生苦短我用Python"},{"text":"链接 C++中允许重载方法，这些方法在源代码中有相同的名字，却有不同的函数列表。编译器讲每个唯一的方法和参数列表组合编码成一个对链接器来说唯一的名字。这个编码过程叫做mangling。 链接器如何解析多重定义的全局符号 函数和已初始化的全局变量是强符号，未初始化的全局变量是弱符号。 Unix链接器使用下面的规则来处理多重定义的符号： 不允许有多个强符号。 如果有一个强符号和一个弱符号，那么选择强符号 如果有多个弱符号，那么从这些弱符号中任意选择一个 在命令行中，如果定义一个符号的库出现在引用这个符号的目标文件之前，那么引用就不能被解析，连接会失败 加载器（loader）将可执行目标文件的代码和数据从磁盘拷到内存中，然后跳转到程序的第一条指令或入口点来运行程序。这个将程序拷贝到内存并运行的过程叫做加载。 无论我们在存储器中的何处加载一个目标模块，数据段总是分配成紧随代码段后面。因此，代码段中任何指令和数据段中任何一个变量之间的距离都是一个运行时常量，和代码段和数据段的绝对的存储位置无关 链接器的两个主要任务是符号解析和重定位 符号解析 讲姆讲目标文件中的每个全局符号都绑定到一个唯一的定义 重定位 确定每个符号的最终在内存中的位置，并修改对那些目标的引用。 链接器 分别编译：即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候将它们整合到一起。但是，链接器一般是与C编译器分离的。 链接器通常把由编译器或汇编器生成的若干个目标模块整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。 链接器通常把目标模块看成是由一组外部对象组成。每个外部对象代表机器内存中的某个部分，并通过一个外部名称来识别。 exit函数和return函数的主要区别是： exit用于在程序运行的过程中随时结束程序，exit的参数返回给操作系统。exit函数运行时会先执行由atexit（）函数等级的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile（）创建的临时文件。exit是结束一个进程，它将删除进程的内存空间，同时讲错误信息返回给父进程。exit是系统调用级别的，表示整个进程的结束。 return表示终止当前函数的运行，并将操作权返回给调用者。如果在main函数中，表示将操作权返回给操作系统，隐式调用exit。​如果return没有值就返回空，表示中断函数的执行，返回调用函数处。return是语言级别的，它表示了调用堆栈的返回； 理解复杂声明可用的\"右左法则\"：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。 分析下面的例子，答案见最后。 char * const * ( * next )(); char * ( * c [ 10 ]) int ( ** p ); 每个外部对象只在一个地方声明。这个声明的地方一般就在一个头文件中，需要用到该外部对象的所有模块都应该包括在这个头文件。特别注意：定义该外部对应的那个模块也应该包括这个头文件。 编译：生成目标平台的指令 -解释：在运行过程中才生成目标平台的指令。需要虚拟机来将编译后生成的中间代码翻译成目标平台的指令。 Interposition指用户定义的函数取代函数库中声明 完全相同的函数 ，不是重载. void mktemp () {..} void getwd () { mktemp ();} int main () { mktemp (); getwd (); // 即使库函数有 void mktemp(){}，操作系统也会调用用户自己定义的函数 return 0 ; } 链接库的五个特殊秘密 动态链接库的扩展名为 \".so\"，静态的为\".a\" 通过-lthread选项，告诉编译器链接到libthread.so 编译器期望在确定的目录下找到这些库函数 观察头文件，确定所使用的函数库 与提取动态库中的符号相比，静态库中的符号提取的方法限制更严格 动态库的优点： 动态链接可执行文件比功能相同的静态链接可执行文件的体积小。 所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。 关于库函数的使用，最好的用法就是尽量使用系统头文件。 预处理 宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。 宏定义中的空格不能忽视 #define f (x) ((x)-1） 的意思是f代表(x) ((x)-1而不是f(x)代表((x)-1 宏定义中出现的括号的作用是预防引起与优先级有关的问题。例如 #define abs(x) (((x)>=0)?:(x):-(x)) // 正确 #define abs(x) x>0?x:-x // 错误 abs(a-b)在错误的表达式中会展开为 a-b>0?a-b:-a-b 即使是用括号括起来也可能出错。 #define max(a,b) ((a)>(b)?(a):(b)) 在上面的表达式中，如果a大于b，那么a将会被求两次值，此时max(a++,b)就会产生错误的结果。 正确的做法如下： #define max(x, y) ({ typeof ( x ) _max1 = ( x ); typeof ( y ) _max2 = ( y ); ( void ) ( & _max1 == & _max2 ); // 当两个比较两个类型不同的变量的地址时,编译器会给出一个警告.提示我们在进行类型不同的比较. _max1 > _max2 ? _max1 : _max2 ; }) 前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果,编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误。 再看一个经典的例子 #define toupper(c) (( c ) >= 'a' && ( c ) <= 'z' ? ( c ) + ( 'A' - 'a' ) : ( c )) 这样做的原因是因为touppper(函数在调用时造成的系统开销要大大多于函数体内的实际计算操作。 动态语言和静态语言 通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。 动态类型语言：动态类型语言是指在 运行期间 才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言 静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在 编译期间 检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表 一般情况静态类型的语言运行速度要高于动态语言。 强类型定义语言和弱类型定义语言 强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言，可以有效的避免许多错误 弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。 Python是动态的强类型语言，C是静态的弱类型语言","tags":"编程","loc":"www.houcj.net/blog/2015/03/27/link-and-preprocess/","title":"链接和预编译"},{"text":"C 语言中的运算规则 C语言中每个token应该尽可能多的包含更多的字符。如果编译器的输入流截止到某个字符之前已经被分解成一个个的token，那么从该字符之后应尽可能的组成一个最长的字符串的token。除了字符串与字符串常量，符号的中间不能嵌有空白（空格符、制表符，换行符）。 C语言中符号之间的空白将被忽略，这些符号包括空格符，制表符，换行符号： if ( a > b ) b = a ; if ( a > b ) b = a ; C语言变量的声明包括两部分：类型，以及声明符。 C语言运算符优先级 最高优先级包括：数组下标，函数调用操作符，各结构成员选择操作符。都是自左向右结合。 单目运算符的优先级仅次于最高级的运算符。单目运算符是自右向左结合。 双目运算符中，优先级为: 算术运算符 > 移位运算符 > 关系元算符 >逻辑运算符>赋值运算符>条件元算符 在所有的运算符中， 逗号 运算符的优先级最低。 C语言中，只有四种运算符存在规定的求值顺序（&&、||、?:、,）。运算符&&和||首先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符？：有三个操作数：在a？b:c中，操作数a首先别求值，根据a的值再求b后者c的值。而逗号操作符，首先对左侧操作数求值，然后该值被丢弃，再对右侧操作数求值。 C语言中常见的问题 如果一个整形常量的第一个字符是数字0，那么该常量将被视作八位数。譬如010会被当成十进制中的8。 在C语言中用单引号引起的字符所代表的是该字符ASCII码的整数值。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。 C语言中，每个case只有在遇到break时才会跳出switch语句。否则讲继续。 switch ( exp ) { case one : do something1 ; break ; case two : do something2 ; break ; default : do something3 : break ; } 如果strlen(s)的值是n，那么该字符串实际需要n+1个字符的空间，'\\0'作为结束标志。 char * p , * q ; p = \"xyz\" q = p ; p [ 0 ] = 'X' q [ 1 ] = 'Y' 复制指针并不同时复制指针所指向的数据，而是把指针所指向的地址复制给另一个指针。 int n = 4 ; int buffer [ n ] = { 1 , 2 , 3 , 4 }; int * bufptr = buffer ; int * p = buffer ; while ( n > - 1 ) { if ( bufptr == & buffer [ 4 ]) { printf ( \"Work well ! \\n \" ); break ; } * bufptr ++ = * p ++ ; n -= 1 ; } 所以上面的代码执行后，p，q共同指向字符串\"XYz\" - 当常量被转换为指针使用时，这个指针绝对不能解引用，即不能使用该指针所指向内存中的存储内容。ANSI规定：数组中实际不存在的溢界元素的地址位于数组所占用内存之后，这个地址可以用于进行赋值比较。但是不能引用该地址的元素。 类型提升：在表达式中，每个char类型都被转换为int，float都会转换为double。由于函数参数也是一个表达式，所以当参数传递给函数时也会发生类型转换。 整型提升：char、short int和位段类型（signed，unsigned）以及枚举类型将被提升为int，前提是int类型能够完整地容纳原先的数据，否则讲会被转换为 unsigned int。 X = Y Left Value（左值）: 表示存储结果的地方. X 代表存储的地址。 Right Value（右值）: Y中的内容 数组名是不可修改的左值 ，只有可修改的左值才能被赋值。 a +++++ b ; 由于编译器的中最长匹配的原则，上式会被翻译为 a ++++ + b ; //即 (( a ++ ) ++ ) + b ; 而 a++ 不能作为左值， 因为a++返回的是自身的值副本。因此上面的表达式是错误的。 C语言里函数的参数默认是从右往左处理的，输出时是从左往右。 #include<stdio.h> int main ( void ) { int a = 10 , b = 20 , c = 30 ; printf ( \" \\n %d..%d..%d \\n \" , a + b + c , ( b = b * 2 ), ( c = c * 2 )); return 0 ; } 答：输出结果是： 110..40 . .60 void*和C结构体 设计一个能接受任何类型的参数并返回interger（整数）结果的函数 答：如下： int func ( void * ptr ) 如果这个函数的参数超过一个，那么这个函数应该由一个结构体来调用， 这个结构体可以由需要传递参数来填充。 - 大端和小端 （数据在内存中的字节排列顺序） - 大端：最低位置存放高位字节，高位优先。 - 小端：最低位置存放低位字节，地位优先。 'NUL'和'NULL'的区别 一个'L'的'NUL'用于结束一个ASCII字符串。 两个'L'的'NULL'用于表示什么也不指向（空指针） C中的关键字： extern：用于变量，表示在其他地方（文件）定义。用于函数定义，表示全局可见，即可被任意文件内的函数访问。 const：相当于read only static：在函数内部，表示该变量的值在各个调用一直保持持续性。 联合（Union）和结构体（Struct） 一个联合的总的大小等于它的最大字段的大小 如果我们事先知道对一个数据结构中的两个不同字段的使用是互斥的，那么将这两个字段声明为联合的一部分，而不是结构的一部分，以减少分配空间的总量。","tags":"编程","loc":"www.houcj.net/blog/2015/03/03/the-basic-knowledge-in-c/","title":"The basic Knowledge in C"},{"text":"线程安全 一个函数被称为线程安全的，当且仅当被多个并发线程反复地调用时，它会产生一直产生正确的结果。 四个线程不安全函数类 不保护共享变量的函数 对一个未受保护的全局计数器变量加1. 改进：利用像P和V操作这样的同步操作来保护共享的变量。 优点，在调用程序中不需要做任何修改 缺点，同步操作讲减慢程序的执行时间 保护跨越多个调用的状态的函数 unsigned int next = 1 ; int rand ( void ) { next = next * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } void srand ( unsigned int seed ) { next = seed ; } 改进方法重写，使得它不再使用任何static数据，而是依靠调用者在参数中传递状态信息。 int rand_r ( unsigned int * nextp ) { * nextp = * nextp * 1102515245 + 12345 ; return ( unsigned int )( next / 65536 ) % 32768 ; } 缺点，被迫修改调用程序中的代码。 返回指向静态变量的指针的函数。 改进方法，加锁-拷贝（lock-copy）技术。基本思想是将线程不安全函数与互斥锁联系起来。在每一个调用位置，对互斥锁解锁，调用线程不安全函数，讲函数返回的结果拷贝到一个私有的存储器位置，然后对互斥锁解锁。 char * ctime_ts ( const time_t * timep , char * privatep ) { char * sharedp ; P ( & mutext ); sharedp = ctime ( timep ); strcpy ( privatep , sharedp ); V ( & mutex ); return privatep ; } 调用线程不安全函数 改进方法，lock-copy","tags":"编程","loc":"www.houcj.net/blog/2015/02/27/multi-thread/","title":"多线程"},{"text":"字符串匹配 Implement strStr() Implement strStr(). Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. 分析 暴力解法 在haystack中遍历，直到可以找到于needle相匹配的位置。O(nm)时间复杂度, O(1) 空间复杂度的暴力解法: 1 2 3 4 5 6 7 def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) for x in range ( n - m + 1 ): if haystack [ x : m + x ] == needle : return x return - 1 KMP解法 匹配过程的时间复杂度为O(n)，预处理时间时间复杂度为O(m). O(m)的空间用来存储预处理数组。 KMP的核心就在于扫描字符串haystack，并更新可以匹配到needle的位置。 当haystack中的字符和needle中匹配的时候继续。 不匹配的时候让haystack向右移动，这里使用了一个预处理数组来 确定haystack应该移动的位置：不匹配字符所在位置 - 不匹配字符对应的预处理数组中的值 预处理数组在下面介绍。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 def strStr ( self , haystack , needle ): n = len ( haystack ) m = len ( needle ) if m == 0 : return 0 prefix = self . compute_prefix ( needle ) j = - 1 for i in range ( n ): while j > - 1 and needle [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if needle [ j + 1 ] == haystack [ i ]: j = j + 1 if j == m - 1 : return i + 1 - m #j = prefix[j] find more possible position for the next match return - 1 计算某个字符对应的预处理的值，就是看这个字符之前的字符串中有多大长度的相同前缀后缀。 具体算法如下。 1 2 3 4 5 6 7 8 9 10 11 def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix 应用:Shortest Palindrome Given a string S, you are allowed to convert it to a palindrome by adding characters in front of it. Find and return the shortest palindrome you can find by performing this transformation. For example: Given \"aacecaaa\", return \"aaacecaaa\". Given \"abcd\", return \"dcbabcd\". 分析 我们知道回文的性质就是正反都相同。因此，我们以反转的字符串为母串，以原来的字符串为字串进行匹配。找到从源字符串 开始的最长的公共字串，然后把公共字串后面的字符串insert到源字符串。这道题的trick是容易超时，因此可以使用 kmp进行字符串的匹配。时间复杂度为O(n)的kmp字符串匹配长度，O(L)的字符串长度的空间复杂度。 具体见下面的代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : # @param {string} s # @return {string} def shortestPalindrome ( self , s ): haystack = s [:: - 1 ] m = len ( s ) j = - 1 prefix = self . compute_prefix ( s ) for i in range ( m ): while j > - 1 and s [ j + 1 ] != haystack [ i ]: j = prefix [ j ] if s [ j + 1 ] == haystack [ i ]: j = j + 1 return s [ m - 1 : j : - 1 ] + s def compute_prefix ( self , P ): m = len ( P ) prefix = [ - 1 for i in range ( m )] j = - 1 for i in range ( 1 , m ): while j > - 1 and P [ j + 1 ] != P [ i ]: j = prefix [ j ] if P [ j + 1 ] == P [ i ]: j += 1 prefix [ i ] = j return prefix","tags":"计算机科学","loc":"www.houcj.net/blog/2014/03/21/kmp/","title":"字符串匹配"},{"text":"一、斐波那契博弈 题目 有一堆个数为n(n>=2)的石子，游戏双方轮流取石子，规则如下： 先手不能在第一次把所有的石子取完，至少取1颗； 之后每次可以取的石子数至少为1，至多为对手刚取的石子数的2倍。 约定取走最后一个石子的人为赢家，求必败态。 结论：当n为Fibonacci数的时候，先手必败。 用第二数学归纳法证明： 为了方便，我们将n记为f[i]。 当i=2时，先手只能取1颗，显然必败，结论成立。 假设当i<=k时，结论成立。 则当i=k+1时，f[i] = f[k]+f[k-1]。 则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。（一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]， 则后手可以直接取完f[k]，因为f[k] < 2*f[k-1]） 对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。 如果先手第一次取的石子数y>=f[k-1]/3，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时x=f[k-1]-y， 则x<=2/3*f[k-1]。 我们来比较一下2/3*f[k-1]与1/2*f[k]的大小。即4*f[k-1]与3*f[k]的大小，对两值作差后不难得出，后者大。 所以我们得到，x<1/2*f[k]。即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗， 所以后手必胜。 即i=k+1时，结论依然成立。 那么，当n不是Fibonacci数的时候，情况又是怎样的呢？ 这里需要借助\"Zeckendorf定理\"（齐肯多夫定理）：任何正整数可以表示为若干个不连续的Fibonacci数之和。分解的时候， 要取尽量大的Fibonacci数。 比如分解85：85在55和89之间，于是可以写成85=55+30， 然后继续分解30,30在21和34之间，所以可以写成30=21+9， 依此类推，最后分解成85=55+21+8+1。 则我们可以把n写成 n = f[a1]+f[a2]+……+f[ap]。（a1>a2>……>ap） 我们令先手先取完f[ap]，即最小的这一堆。由于各个f之间不连续， 则a(p-1) > ap + 1，则有f[a(p-1)] > 2*f[ap]。 即后手只能取f[a(p-1)]这一堆，且不能一次取完。 此时后手相当于面临这个子游戏（只有f[a(p-1)]这一堆石子，且后手先取）的必败态， 即先手一定可以取到这一堆的最后一颗石子。 同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。 二、 小岛的故事 题目 一个岛上有100个人，其中有5个红眼睛，95个蓝眼睛。这个岛有三个奇怪的宗教规则。 他们不能照镜子，不能看自己眼睛的颜色。 他们不能告诉别人对方的眼睛是什么颜色。 一旦有人知道了自己是红眼睛，他就必须在当天夜里自杀。 某天，有个旅行者到了这个岛。 由于不知道这里的规矩，所以他在和全岛人一起的时候，不留神就说了一句话： 你们这里有红眼睛的人。 假设这个岛上的人足够聪明，每个人都可以做出缜密的逻辑推理。 问题一：请问这个岛上将会发生什么？ 分析一 假设岛上只有一个人是红眼睛，那么当天他看到有99个蓝眼睛就会自杀。 假设岛上有两个人是红眼睛，两个红眼睛的人都会假定自己不是红眼睛，结果发现第二天没有人会自杀， 因此他知道岛上有 两个红眼睛，而自己是其中的一个，于是两个人在第二天就都会自杀。 同理，当岛上有5个红眼睛时，它们就会在第五天一起自杀 问题二：那么旅行者存在的意义是什么呢？毕竟一开始岛上每个人都知道岛上存在红眼睛。 分析二： 假设岛上只有一个是红眼睛，他会看到99个都是蓝眼睛，但是他无法自己是红眼睛，因此他不会自杀。 假设岛上有两个人是红眼睛，虽然他会看到98个蓝眼睛，1个红眼睛，但他无法确定自己是红眼睛。 因此2个红眼睛是可以稳定存在。 同理，5个红眼睛是可以稳定存在的。 因此：旅行者出现的意义在于，他说了那句话，大家的推理方式就变了。 三、可怜的小白鼠 题目： 有8瓶酒，只有一瓶有毒。喝酒之后，1天会死，只有1天时间。请问至少需要多少只老鼠可以找到有毒的那只瓶子。 分析： 8瓶，1瓶有毒 即使某一个老鼠没有被毒死，也不会有时间重复利用了 老鼠开始喝酒，第一只要喝哪些，第二只要喝哪些呢？现在有什么依据么？显然酒瓶和老鼠都是一样的，不可区分的。 那么怎么来选择哪些老鼠喝哪瓶酒，进而进行判断呢？这是这个题目的关键点、核心点。8个酒瓶，我们对其编号0-7， 如下为二进制的表示， 编号 二进制 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 观察每一位的0和1的分布情况，从右向左，我们可以让第一只老鼠喝掉都是1的，即标号为1，3，5，7的瓶子 同样的，同时，另外两只老鼠测试第二位为1的瓶子以及第三位为1的瓶子。 假设结果为第一只死亡，第二只生存，第三只死亡，我们可以确定，那个有毒瓶子的编号为101，（有毒的瓶子出现，小白鼠必死，）即编号为5的瓶子为有毒的瓶子。 此类的题目分析的思路的关键就是找到突破口：表示为二进制的形式。 四、开灯关灯 题目： 有100盏灯，依次编号1-100，初始都是关着的。第1次遍历，打开全部的灯；第2次遍历，关掉第2盏、第4盏等被2整除的灯； 第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作 如果灯开着，就关掉 如果灯关着，就打开 如此交替进行，知道100次遍历完毕，请问，还有多少盏灯亮着。 分析： 例如编号为10的灯： 第1次能够操作，打开 第2次能够操作，关闭 第5次能够操作，打开 第10次能够操作，关闭 最终编号为10的灯是关闭的。 再来看编号为49这盏灯： 第1次能够操作，打开 第7次能够操作，关闭 第49次能够操作，打开 最终编号为49的灯打开着。 通过上面两个例子，编号为n的灯，有多少个因数，就有会被操作多少次。 很显然，如果是偶数次，则灯一定是关着的。那什么情况下，操作会是奇数次呢？一个数，每次分解，都是两个数相乘， 只有当这两个数相同的时候， 才会是偶数次。 所以，最终会亮着的灯，都能够开平方， 得到一个正整数：1,4,9,16,25,36,49,64,81,100. 【分析完毕】 五、天平称小球 题目 N个小球，其中有一个是坏球。有一架天平。需要你用最少的称次数来确定哪个小球是坏的并且它到底是轻还是重。 分析 由于每次天平都有3种状态，左倾，右倾，平衡。因此每次可以为我们提供3种信息。因此我们应该尽量让N个小球切分为3份。 特别地，当不妨假设有6个球，来考虑一下3、3称和2、2称的区别： 在未称之前， 一共有12种可能性：1轻、1重、2轻、2重、…、6轻、6重。 现在将1、2、3号放在左边，4、5、6放在右边3、3称了之后， 不失一般性假设天平左倾，那么小球的可能性就变成了原来的一半（6种）： 1重、2重、3重、4轻、5轻、6轻。 即这种称法能排除一半可能性。 现在再来看2、2称法，即1、2放左边，3、4放右边，剩下的5、6不称，放一边。 假设结果是天平平衡，那么可能性剩下——4种：5重、5轻、6重、6轻。 假设天平左倾，可能性也剩下4种：1重、2重、3轻、4轻。右倾和左倾的情况类似。 总之，这种称法，不管天平结果如何，情况都被我们缩小到了原来的三分之一！ 特别地，考虑N=3时，至少需要2次才能找到那个坏球。 因此这种方法最少的次数为 $$\\lfloor\\log3N\\rfloor+1$$ 六、称药丸 题目 有20瓶药丸，其中19瓶有1g/粒的药丸，余下一瓶装1.1g/粒的药丸。给你一台称重精准的天平，怎么找出比较 重的那瓶药丸？ 分析 由于天平只能用一次，因此必须利用预期重量和实际测量中间之间的差别，来得到那一瓶较重的药丸。就是放大他们的重量的差异。 假设有两瓶药丸，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，如果为3.1g，那么必然第一瓶为较重的。 否则，重量必然为3.2g。 同理，我们可以从第一瓶取1粒药丸，从第二瓶中取2粒药丸，从第十瓶中取10粒药丸。如果都为1g那么总重量为210g（1+2+3+...10=20*21/2=210） 那么药品的编号可用 （weight-210）/ 0.1 得出。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"编程","loc":"www.houcj.net/blog/2014/02/20/mind-trick/","title":"Mind trick"},{"text":"等概率：蓄水池问题 要求从N个元素中随机的抽取k个元素，其中N无法确定。 这种应用的场景一般是数据流的情况下，由于数据只能被读取一次，而且数据量很大，并不能全部保存，因此数据量N是无法在抽样开始时确定的；但又要保持随机性，于是有了这个问题。所以搜索网站有时候会问这样的问题。 这里的核心问题就是\"随机\"，怎么才能是随机的抽取元素呢？我们设想，买彩票的时候，由于所有彩票的中奖概率都是一样的，所以我们才是\"随机的\"买彩票。那么要使抽取数据也随机，必须使每一个数据被抽样出来的概率都一样。 分析： 由于N无法确定，数据只能读取一次，并且要求随机，就是每个元素抽出的概率一样，都是k/N。 解法一：最小k个指纹 找到一个哈希函数能产生随机数，同时用一个k个元素的堆用来保存最小的k个元素。那么过一遍所有的元素，计算每个的哈希值，通过堆来选择k个元素。 解法二：数学计算 先选中前k个， 从第k+1个元素到最后一个元素为止， 以1/i (i=k+1, k+2,...,N) 的概率选中第i个元素， 并且随机替换掉一个原先选中的元素， 这样遍历一次得到k个元素， 可以保证完全随机选取。 任意元素G在i轮留下来的概率： P(G留下) = P(G已经存在) * P(G没有被替换) = P(G已经存在) * (1 - P(G被替换)) = P(G已经存在) * (1 - P(第i个元素要替换某个元素) * P(某个元素是G)) = (k/i) * (1 - (k/(i+1)) * (1/k)) = (k/i) * (1 - (1/(i+1))) = (k/i) * (i/(i+1)) = (k/(i+1)) 证毕！ 拒绝采样 Given a function which generates a random integer in the range 1 to 7, write a function which generates a random integer in the range 1 to 10 uniformly. 分析： 下面是我们通过两次rand7()的位置，第一次代表行的位置，第二次代表列的位置，然后来唯一确定1-10的值， 其中\"*\"表示随机从下面的表中取出一个数字。 1 2 3 4 5 6 7 1 1 2 3 4 5 6 7 2 8 9 10 1 2 3 4 3 5 6 7 8 9 10 1 4 2 3 4 5 6 7 8 5 9 10 1 2 3 4 5 6 6 7 8 9 10 * * 7 * * * * * * * 具体算法如下 int rand10 () { int row , col , idx ; do { row = rand7 (); col = rand7 (); idx = col + ( row - 1 ) * 7 ; } while ( idx > 40 ); return 1 + ( idx - 1 ) % 10 ; } 洗牌算法 Given an array of distinct integers, give an algorithm to randomly reorder the integers so that each possible reordering is equally likely. In other words, given a deck of cards, how can you shuffle them such that any permutation of cards is equally likely? 分析 洗牌算法可以有效的解决这类问题，所谓的洗牌算法就是按顺序依次遍历所有的牌，然后从后面的元素中随机的取一个元素来与当前元素交换 import random def Shuffle ( li ): n = len ( li ) for x in xrange ( n - 1 , 0 , - 1 ): y = random . randint ( 0 , x ) # 从后面的数据中随机选取一个 li [ x ], li [ y ] = li [ y ], li [ x ] # 将随机选取的元素与当前位置元素互换 如果某个元素被放入第i（1≤i≤n ）个位置，就必须是在前i - 1次选取中都没有选到它，并且第i次选取是恰好选中它。 其概率为： \\begin{equation*} p_i=\\frac{n-1}{n}\\times\\frac{n-2}{n-1}\\times\\cdots\\times\\frac{n-i+1}{n-i+2}\\times\\frac{1}{n-i+1}=\\frac{1}{n} \\end{equation*} 条件概率 老王有两个孩子，已知至少有一个孩子是在星期二出生的男孩。问：两个孩子都是男孩的概率是多大？ [假设生男生女的概率相等] 分析 根据题目可以得出，两个事件，事件A:至少有一个周二出生的男孩，事件B:两个孩子都是男孩。题目所求即为P(B|A)，即在A事件满足的条件下，B事件发生的机率。 由贝叶斯公式可得： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 依次计算公式中的各个概率值： 在已知两个孩子都是男孩的条件下，至少有一个是周二出生的男孩： \\begin{equation*} P(A|B)=1-{(\\frac{6}{7})}&#94;2=\\frac{13}{49} \\end{equation*} 两个孩子都是男孩： \\begin{equation*} P(B|A)=\\frac{P(AB)}{P(A)}=\\frac{P(A|B)P(B)}{P(A)} \\end{equation*} 至少有一个孩子是周二出生的男孩： \\begin{equation*} P(A)=1-{(\\frac{1}{2}\\times\\frac{6}{7}+\\frac{1}{2})}&#94;2=\\frac{27}{196} \\end{equation*} 代入即可得： \\begin{equation*} P(B|A)=\\frac{P(A|B)P(B)}{P(A)}=\\frac{13}{49}\\times\\frac{1}{4}\\div\\frac{27}{196}=\\frac{13}{27} \\end{equation*} if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/18/equal-probability/","title":"概率问题"},{"text":"Trie (前缀树) Implement Trie (Prefix Tree) Implement a trie with insert, search, and startsWith methods. Note: You may assume that all inputs are consist of lowercase letters a-z. 分析 Trie ，又称前缀树或字典树，是一种有序树，用于保存关联数组， 其中的键通常是字符串，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的空字符串，而根节点对应空字符串。 由于Python是强类型语言，不支持隐式类型转换，因此使用字典来存储效果更好。 Python Code class TrieNode : def __init__ ( self ): self . word = None self . children = {} class Trie : def __init__ ( self ): self . root = TrieNode () def insert ( self , word ): node = self . root for char in word : if char not in node . children : node . children [ char ] = TrieNode () node = node . children [ char ] node . word = word def search ( self , word ): node = self . root for char in word : if char not in node . children : return False node = node . children [ char ] return node . word == word def startsWith ( self , prefix ): node = self . root for char in prefix : if char not in node . children : return False node = node . children [ char ] return True # Your Trie object will be instantiated and called as such: # trie = Trie() # trie.insert(\"somestring\") # trie.search(\"key\") LRU LRU Cache Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set. get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. set(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item. 分析 在常数时间内，可以使用一个双向链表来完成删除和插入到链表末尾的操作。而使用hash则可以在常数时间完成从key到value的映射。 因为这个算法的关键是用hash table + double link list来实现。 当使用get(key)时，这时双向链表中的key节点需要删除，然后插入到链表末尾。而 最近一直不使用的节点则放在链表的头部，等待被替换。Python中的collections.OrderedDict()就是用一个双向链表 来维护的一个字典（即map）见下面的代码。当然我们也可以自己实现一个双向链表，见 Github Python Code class LRUCache : def __init__ ( self , capacity ): self . capacity = capacity self . cache = collections . OrderedDict () def get ( self , key ): if key not in self . cache : return - 1 value = self . cache . pop ( key ) self . cache [ key ] = value # del the key item and insert to the last return value def set ( self , key , value ): if key in self . cache : self . cache . pop ( key ) if len ( self . cache ) == self . capacity : self . cache . popitem ( last = False ) # del from the front self . cache [ key ] = value","tags":"计算机科学","loc":"www.houcj.net/blog/2014/02/13/trie-lru/","title":"有用的数据结构"},{"text":"TCP为每个连接建立了七个定时器。下面讲按照这些定时器在一条连接生存期内出现的次序依次进行介绍。 Connection establishment Timer(​连接建立定时器) 为了防止client端一直等待服务器端的情况发生。 在Client发送SYN报文段建立新的链接时，该定时器启动，如果在75s内没有收到响应，连接建立将会终止。确定连接的有效建立。 Retransmission Timer(重传定时器) 重传定时器在TCP发送数据时设定。在该定时器超时，而没有收到另外一端的ACK的时候，将重传数据。重传定时器的值是动态计算的，取决于该连接RTT的值和被重传的次数。 Delayed ACK Timer(延迟ACK定时器)定时器在200ms 延迟ACK定时器负责在该终端（end）收到一个数据包时，无需马上发出ACK进行确认，而是等待200ms内，有数据要在该连接上发送，延迟的ACK响应就可随着数据一起发送回另一个终端。这种方式也被成为捎带确认。 Persist Timer（持续定时器） 持续定时器在收到连接另一端的发送通告窗口为零时，阻止该端继续发送数据时设定。因此当该端有数据要发送时， 但连接的另一端的通告窗口为零时，持续定时器就会启动，超时后向连接另一端发送1字节的数据，来判断另一方的接收窗口是否打开。被称为零窗口探测。持续定时器的值是动态计算的，取决于往返时间，时间在5s到60s之间取值。 Keep alive Timer（保活定时器） 如果连接的持续时间超过2hour，保活定时器就会超时，向对端发送连接探测报文，强迫对端发出响应。如果连续若干次保活测试收不到相应的相应，就认为对端发生了故障。 FIN_WAIT_2 Timer 当某个连接从FIN_WAIT_1状态变迁到FIN_WAIT_2状态，并且不能再收到任何新的数据时，该定时器就会启动设为10分钟。定时器超时重设为75s，第二次超时后连接被关闭。该定时器的目的是为了避免对方一直不发送FIN，某个连接一直处于FIN_WAIT_2状态。 TIME_WAIT_Timer (也成为2MSL定时器) 当连接转移到TIME_WAIT状态，定时器启动。2MSL等待时间的原因就是为了确保最后一个ACK在一个MSL丢包后重传 TCP包括连个定时器函数，快速定时器（200ms调用一次），慢速定时器（500ms）调用一次。延迟ACK定时器时，每个200ms超时后，延迟的ACK必须被发送。其他的定时器是每500ms递减一次，计数器减为0时，就触发相应的动作。","tags":"计算机科学","loc":"www.houcj.net/blog/2014/01/02/timer/","title":"TCP中的七种定时器"},{"text":"二叉查找树 由于红黑树本质上就是一棵 二叉查找树 ，所以在了解红黑树之前先来看下二叉查找树。 二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树： 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值 任意结点的左、右子树也分别为二叉查找树 没有键值相等的结点（no duplicate nodes） 因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，所以顺理成章，一般操作的执行时间为O（lgn） 红黑树 红黑树是一棵二叉搜索树，并且满足以下性质： 1. 每个节点或者是红色的，或者是黑色的 2. 根节点为黑色 3. 每个叶子节点(NIL)是黑色 4. 如果一个节点是红色的，则它的两个子节点必须是黑色的。 5. 对每个节点，从该节点到其所有后代叶节点的简单路径上，都包含相同数目的黑色节点 PS： - 特性3中的叶子节点，是为空的节点 - 特性5确保没有一条路径比其他路径长两倍。 红黑树的应用 红黑树主要用来存储有序的数据，它的时间复杂度是O(lgn)，空间复杂度也是 O(lgn)。C++ STL中的set、map，linux虚拟内存管理都是通过红黑树去实现。 红黑树的操作 红黑树中有两种基本操作，插入和删除。需要注意的是，每次进行这样的操作的时候都会 有可能改变红黑树的性质，因此必须通过相应的INSERT-FIXUP和DELETE-FIXUP来保证红黑树的性质。 具体情况见 算法导论 ，而它们都会用到旋转的方法。 下面就具体介绍旋转和相应的插入删除操作。 旋转 这里主要介绍左旋，右旋的操作基本类似。 左旋的伪码如下： LEFT_ROTATE ( T , x ) 1 y = x . right # set y 2 x . right = y . left # turn y's left subtree into x's right subtree 3 if y . left != T . nil 4 y . left . parent = x 5 y . parent = x . parent # link x's parent to y 6 if x . parent == T . nil 7 T . root = y 8 elif x == x . parent . left 9 x . parent . left = y 10 else 11 x . parent . right = y 12 y . left = x # put x on y's left 13 x . parent = y 插入 红黑树本身就是一种二叉查找树，插入的时候也需要首先不能改变二叉查找树的性质，然后将该节点着色为 红色(插入红色节点是为了保证满足性质5)。最后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的插入操作 RB_INSERT ( T , z ) 1 y = T . NIL 2 x = T . root 3 while x != T . NIL 4 y = x 5 if z . key < x . key 6 x = x . left 7 else 8 x = x . right 9 z . parent = y 10 if y == T . nil 11 T . root = z 12 elif z . key < y . key 13 y . left = z 14 else 15 y . right = z 17 z . left = T . nil 18 z . right = T . nil 19 z . color = RED 20 RB_INSERT_FIXUP ( T , z ) 插入之后可能破坏红黑树的性质2和4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 z的叔节点y是红色的 1)将父节点设为黑色 2)将叔节点设为黑色 3)将祖父节点设为红色 4)将祖父节点设为当前节点，继续处理 case2 z的叔节点y是黑色的且z是一个右孩子 1)将父节点设为当前节点 2)对当前节点进行左旋操作 case3 z的叔节点y是黑色的且z是一个左孩子 1)将父节点设为黑色 2)将祖父节点设为红色 3)对祖父节点进行右 旋操作 其中z表示当前节点，y表示z的叔节点，z的父节点是红色的。 修复插入操作 RB_INSERT_FIXUP ( T , z ) 1 while z . parent . color == RED 2 if z . parent == z . parent . parent . left 3 y = z . parent . parent . right 4 if y . color == RED # CASE 1 5 z . parent . color = BLACK 6 y . color = BLACK 7 z . parent . parent . color = RED 8 z = z . parent . parent 9 elif z == z . parent . right # CASE 2 10 z = z . parent 11 LEFT_ROTATE ( T , z ) 12 z . parent . color = BLACK # CASE 3 13 z . parent . parent . color = RED 14 RIGHT_ROTATE ( T , z . parent . parent ) 15 else ( same as the previous \"if\" clause # z's parent is a right child with \"right\" and \"left\" extranged ) 16 T . root . color = BLACK 删除 将红黑树内的某一个节点删除花费O(lgn)时间。红黑树本身就是一种二叉查找树，删除的时候也需要首先不能改变二叉查找树的性质， 然后通过修改着色和重新着色来重新成为一棵红黑树。 类似二叉查找树的删除操作 RB_DELETE ( T , z ) 1 y = z 2 y - original - color = y . color 3 if z . left == T . nil 4 x = z . left 5 RB - TRANSPLANT ( T , z , z . right ) 6 elif z . right == T . nil 7 x = z . right 8 RB - TRANSPLANT ( T , z , z . left ) 9 else 10 y = TREE - MINIMUM ( z . right ) 11 y - original - color = y . color 12 x = y . right 13 if y . parent == z 14 x . parent = y 15 else 16 RB - TRANSPLANT ( T , y , y . right ) 17 y . right = z . right 18 y . right . parent = y 19 RB - TRANSPLANT ( T , z , y ) 20 y . left = z . left 21 y . left . parent = y 22 y . color = z . color 23 if y - original - color == BLACK 24 RB_DELETE_FIXUP ( T , x ) RB - TRANSPLANT ( T , u , v ) 1 if u . parent == T . nil 2 T . root = v 3 elif u == u . parent . left 4 u . parent . left = v 5 else 6 u . parent . right = v 7 v . p = u . p 删除之后可能破坏红黑树性质的1，2，4，需要根据相应的情况做出相应的处理策略。 情况 现象说明 处理策略 case1 x的兄弟节点w是红色的 1)将x的兄弟节点设为黑色 2)将x的父节点设为红色 3)对x的父节点进行左旋 4)左旋后，重新设置x的兄弟节点 case2 x的兄弟节点w是黑色，w的两个子节点都是黑色的 1)将x的兄弟节点设为红色 2)设置x的父节点为新的x节点 case3 x的兄弟节点w是黑色；x的兄弟节点的左孩子是红色，右孩子是黑色的 1)将x兄弟节点的左孩子设为黑色 2)将x兄弟节点设为红色 3)对x的兄弟节点进行右旋 4)右旋后，重新设置x的兄弟节点 case4 x的兄弟节点w是黑色；w的右孩子是红色的 1)将x父节点颜色赋值给x的兄弟节点 2)将x父节点设为黑色 3)将x兄弟节点的右子节设为黑色 4)对x的父节点进行左旋 5)设置x为根节点 其中x为当前节点，w是x的兄弟节点。 修复删除操作 RB_DELETE_FIXUP ( T , x ) 1 while x != root and x . color == BLACK 2 if x == x . parent . left 3 w = x . parent . right # CASE 1 4 if w . color == RED 5 w . color = BLACK 6 x . parent . color = RED 7 LEFT_ROTATE ( T , p [ x ]) 8 w = x . parent . right 9 if w . left . color == BLACK and w . right . right == BLACK #CASE 2 10 w . color = RED 11 x = x . parent 12 elif w . right . color == BLACK #CASE 3 13 w . left . color = BLACK 14 w . color = RED 15 RIGHT_ROTATE ( T , w ) 16 w = x . parent . right 17 w . color = x . parent . color #CASE 4 18 x . parent . color = BLACK 19 w . right . color = BLACK 20 LEFT_ROTATE ( T , x . parent ) 21 x = T . root 22 else 23 same as the previous \"if\" clause with \"right\" and \"left\" exchanged ; 24 x . color = BLACK ; 下面是一个简单的 Python 实现.","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/red-black-tree/","title":"Black Red Tree"},{"text":"子字符串 最长不重复子串 Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for \"abcabcbb\" is \"abc\", which the length is 3. For \"bbbbb\" the longest substring is \"b\", with the length of 1. 分析 O(n)时间复杂度， O(1)空间复杂度 可以考虑使用字典，记录字符下标出现的位置。遍历整个字符串，如果发现其中的一个字符存在字典中，说明它出现过，即为重复的字符，那么从该字符后重新计算，并记录出现的不重复子串的最大长度。 class Solution : def lengthOfLongestSubstring ( self , s ): dic = { chr ( i ) : - 1 for i in range ( 256 ) } length , res , j = len ( s ), 0 , 0 for i in range ( length ): if dic [ s [ i ]] >= j : j = dic [ s [ i ]] + 1 dic [ s [ i ]] = i if i - j + 1 > res : res = i - j + 1 return res 最长回文子串 Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.** 分析 O(n&#94;2)时间复杂度， O(1)空间复杂度 从头开始遍历整个字符串。然后以每个字符串为中点向两边扩展，直到最长的Palindromic，记录中间出现的Palindromic的最大长度。需要注意的是Palindromic的长度可能为奇数也可能为偶数。 class Solution : # @return a string def longestPalindrome ( self , s ): length = len ( s ) def expand ( left , right ): while left >= 0 and right < length and s [ left ] == s [ right ]: left -= 1 right += 1 return right - left - 1 start , end = 0 , 0 for i in range ( length ): len1 = expand ( i , i ) len2 = expand ( i , i + 1 ) Len = max ( len1 , len2 ) if end - start < Len : start = i - ( Len - 1 ) / 2 end = i + Len / 2 return s [ start : end + 1 ]","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/22/string-related/","title":"字符串相关"},{"text":"流量控制（Flow control） End-to-End,防止发送方速率过大，接收方来不及处理发送方的数据。- - 拥塞控制（Congestion control） 到达子网中某一部分的分组数量过多，中间路由缓存分组，queueing，造成RTT增加。反应网络整体状况 滑动窗口（Sliding Window） 位于发送方，由接收方的通告窗口（Advertised-Window）决定。接收方通过通告窗口告诉发送方自己还有多少buffer可以接收数据。 通告窗口（Advertised-Window） 接收方使用流量控制的方式 拥塞窗口（Congestion Window） 拥塞窗口的大小指能够发出，但还没有收ACK的最大数据报文段。Linux 3.0 把CWND初始化10个MSS。发送方使用流量控制的方式。发送方取拥塞窗口与通告窗口中的最小值作为发送上限 慢启动（Slow Start） 每个ACK，CWND增加一个报文段（CWND以字节为单位，一报文段为单位进行线性增加） 报文段（Segment） 传输层分组称为报文段，是TCP MSS（Maximum Segment Size ） vs MTU(Maximum Transmission Unit) 在以太网中，MSS最大值为1460（20字节的IP header和20字节的TCP header），MTU的值为1500字节。MSS用于控制发送数据的长度，避免以较小MTU连接到网络上的主机产生分组 往返时延(Round-Trip Time ) 表示从发送端发送数据开始，到发送端收到来自接收端的ACK，总共经历的时延，由传播时延，传输时延，排队时延（Queuing Delay），节点处理时延决定（Node processing Dela y）。可以反应网络的拥塞状况 传输时延（Transmission Delay），传播时延（Transmission Delay） 传输时延=L/R，L，表示分组长度，R，表示链路传输速率(带宽)。传播时延=d/s，d，表示两段的实际物力距离，s一般等于小于光速","tags":"计算机科学","loc":"www.houcj.net/blog/2013/12/15/the-parameters-in-tcp-congestion-control/","title":"TCP Congestion Control 中的相关参数"},{"text":"虚拟内存通过 Page 的形式组织。Pages就是操作系统用于内存和磁盘之间移动或者进行保护的单位。Page in，Page out。磁盘上有个特殊的交换区来与内存进行交换。 进程只能操作位于屋里内存中的页面。 i = 0 ; while ( malloc ( 1 << 20 )) ++ i ; // to see the memory available in this process. printf ( \"Allocated %d MB total \\n \" , i ); cache cache 的类型 write-through cache : 每次写入cache时同时写入到内存，保持内存与cache的一致性。 write-back cache ： 当第一次写入时，只写入cache。如果已经写入过的cache行再次需要写入时，此时第一次写入的结果尚未保存，所以要先把它写入到内存中。当内存切换进程时，cache中所有的数据都要先写入到内存中。 line： 内存读取以行（32 bytes）为单位，整行的数据也会被装入到cache中。每行由两部分组成：一个数据部分以及一个标签，用于指定它所代表的地址。 block： 一个行内的数据块被称作块。块保存来回移动于Cache行和内存之间的字节数据。 -堆 堆区域用于动态 用于内存管理的调用是： malloc 和 free ------------从堆中获得内存以及把内存返回给堆 brk 和 sbrk --------------调整数据端的大小至一个绝对值。 堆中经常出现的两类问题： 释放或改写仍在使用的内存；（内存损坏） 未释放不再使用的内存；（内存泄露） 内存泄露的的检测： swap 观察交换区 netstat、vmstat等工具 对齐（alignment）：数据项只能存储在地址是数据项大小整数倍的内存位置上。数据项不能跨越页面或者cache边界 段（segment）错误原因： dereference Null pointer. int * p ; p = NULL ; * p ; 或者解引用一个包含非法值的指针。 p = malloc ( 256 ); p [ - 1 ] = 0 ; p [ 256 ] = 1 ; 在未得到正确的权限时进行访问。 const int i = 0 ; f (){ i = 1 ; // 表达式必须是可以修改的左值。 } 消耗完了堆栈或者堆空间。","tags":"编程","loc":"www.houcj.net/blog/2013/12/03/thanks-for-the-memory/","title":"Thanks for the memory"}]}