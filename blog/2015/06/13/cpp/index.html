<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="google-site-verification" content="fdZTDVFyX3hKovPIzn1tgPixk_wysBXaPN8YQw1P8Jw" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="ChaoJun Hou" />
        <meta name="copyright" content="ChaoJun Hou" />

<meta name="keywords" content="CPP, 编程, " />

<meta property="og:title" content="CPP Primer "/>
<meta property="og:url" content="../../../../../blog/2015/06/13/cpp/" />
<meta property="og:description" content="进程、线程、协程 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。基本上相当与用户空间下进行线程调度。 静态内存、栈内存、堆内存 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动 创建和销毁。对于栈对象仅在其定义的程序块运行时才存在，static对象在使用之前分配，在程序 结束时销毁。 程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制。 Const 顶层const表示指针本身是个常量 底层const表示指针所指的对象是个常量 尽量使用常量引用，使用引用可以避免拷贝，使用const则避免修改实参的值。 string::size_type &amp; size_t size_t size_t是sizeof操作符的结果返回类型，它在头文件中的typedef为 unsigned int 类型。该类型保证实现所建立的最大对象的字节大小。 string::size_type string::size_type是一个无符号类型的值 ..." />
<meta property="og:site_name" content="Write the Code" />
<meta property="og:article:author" content="ChaoJun Hou" />
<meta property="og:article:published_time" content="2015-06-13T16:55:00+08:00" />
<meta name="twitter:title" content="CPP Primer ">
<meta name="twitter:description" content="进程、线程、协程 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。基本上相当与用户空间下进行线程调度。 静态内存、栈内存、堆内存 静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量 栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动 创建和销毁。对于栈对象仅在其定义的程序块运行时才存在，static对象在使用之前分配，在程序 结束时销毁。 程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制。 Const 顶层const表示指针本身是个常量 底层const表示指针所指的对象是个常量 尽量使用常量引用，使用引用可以避免拷贝，使用const则避免修改实参的值。 string::size_type &amp; size_t size_t size_t是sizeof操作符的结果返回类型，它在头文件中的typedef为 unsigned int 类型。该类型保证实现所建立的最大对象的字节大小。 string::size_type string::size_type是一个无符号类型的值 ...">

        <title>CPP Primer  · Change the World | Write the Code
</title>
       
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../../../../../theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../../../../../theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="../../../../../theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="../../../../../theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="../../../../../theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="../../../../../theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="../../../../../theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="../../../../../theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="../../../../../theme/images/apple-touch-icon-144x144.png" />
        <link href="www.houcj.net/feed.xml" type="application/rss+xml" rel="alternate" title="Write the Code - Full RSS Feed" />
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '61957498', 'auto');
    ga('send', 'pageview');
</script>

    </head>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61957498-1', 'auto');
  ga('send', 'pageview');

	</script>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="../../../../../"><span class=site-name>Write the Code</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="../../../../..">Home</a></li>
                            <li ><a href="../../../../../pages/About.html">About</a></li>
                            <li ><a href="../../../../../random.html">Pick One!</a></li>
                            <li ><a href="../../../../../categories.html">分类</a></li>
                            <li ><a href="../../../../../tags.html">标签</a></li>
                            <li ><a href="../../../../../archives.html">归档</a></li>
                            <li><form class="navbar-search" action="../../../../../search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="../../../../../blog/2015/06/13/cpp/"> CPP Primer  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <html><body><div id="toc"><ul><li><a class="toc-href" href="#" title="CPP Primer">CPP Primer</a><ul><li><a class="toc-href" href="#_1" title="进程、线程、协程">进程、线程、协程</a></li><li><a class="toc-href" href="#_2" title="静态内存、栈内存、堆内存">静态内存、栈内存、堆内存</a></li><li><a class="toc-href" href="#const" title="Const">Const</a></li><li><a class="toc-href" href="#stringsize_type-size_t" title="string::size_type &amp; size_t">string::size_type &amp; size_t</a></li><li><a class="toc-href" href="#_3" title="命名的强制类型转换">命名的强制类型转换</a></li><li><a class="toc-href" href="#_4" title="实参入栈顺序">实参入栈顺序</a></li><li><a class="toc-href" href="#_5" title="尾置迭代器">尾置迭代器</a></li><li><a class="toc-href" href="#_6" title="使用尾置返回类型">使用尾置返回类型</a></li><li><a class="toc-href" href="#_7" title="列表初始化">列表初始化</a></li><li><a class="toc-href" href="#const-constexpr" title="const 和 constexpr">const 和 constexpr</a></li><li><a class="toc-href" href="#_8" title="类型别名">类型别名</a></li><li><a class="toc-href" href="#_9" title="类模版">类模版</a></li><li><a class="toc-href" href="#constexpr" title="内联函数和constexpr函数">内联函数和constexpr函数</a></li><li><a class="toc-href" href="#class-struct" title="class 和struct关键字">class 和struct关键字</a></li><li><a class="toc-href" href="#_10" title="函数指针">函数指针</a></li><li><a class="toc-href" href="#const_1" title="const">const</a></li><li><a class="toc-href" href="#_12" title="类">类</a><ul><li><a class="toc-href" href="#_13" title="构造函数">构造函数</a><ul><li><a class="toc-href" href="#_14" title="默认构造函数">默认构造函数</a></li></ul></li><li><a class="toc-href" href="#_16" title="类类型">类类型</a></li><li><a class="toc-href" href="#_17" title="友元">友元</a></li><li><a class="toc-href" href="#_18" title="成员初始化顺序">成员初始化顺序</a></li><li><a class="toc-href" href="#_19" title="静态成员">静态成员</a></li><li><a class="toc-href" href="#_20" title="谓词">谓词</a></li><li><a class="toc-href" href="#emplace" title="使用emplace操作">使用emplace操作</a></li><li><a class="toc-href" href="#adaptor" title="适配器（adaptor）">适配器（adaptor）</a></li><li><a class="toc-href" href="#_21" title="动态内存">动态内存</a></li><li><a class="toc-href" href="#new-delete" title="new &amp; delete">new &amp; delete</a></li><li><a class="toc-href" href="#shared_ptr" title="shared_ptr">shared_ptr</a></li><li><a class="toc-href" href="#unique_ptr-weak_ptr" title="unique_ptr &amp; weak_ptr">unique_ptr &amp; weak_ptr</a></li><li><a class="toc-href" href="#_22" title="释放动态数组">释放动态数组</a></li><li><a class="toc-href" href="#_23" title="析构函数">析构函数</a></li><li><a class="toc-href" href="#_24" title="删除的函数">删除的函数</a></li><li><a class="toc-href" href="#_25" title="引用计数">引用计数</a></li><li><a class="toc-href" href="#_26" title="拷贝和交换 ###">拷贝和交换 ###</a></li><li><a class="toc-href" href="#_27" title="右值引用">右值引用</a></li><li><a class="toc-href" href="#_28" title="移动&amp;拷贝">移动&amp;拷贝</a></li><li><a class="toc-href" href="#_29" title="三/五原则">三/五原则</a></li><li><a class="toc-href" href="#_30" title="引用限定符">引用限定符</a></li><li><a class="toc-href" href="#_31" title="面向对象程序设计">面向对象程序设计</a></li><li><a class="toc-href" href="#_32" title="防止继承的发生">防止继承的发生</a></li><li><a class="toc-href" href="#_33" title="纯虚函数">纯虚函数</a></li><li><a class="toc-href" href="#_34" title="尾置返回类型与类型转换">尾置返回类型与类型转换</a></li><li><a class="toc-href" href="#_35" title="转发">转发</a></li><li><a class="toc-href" href="#_36" title="命名空间">命名空间</a></li><li><a class="toc-href" href="#_37" title="虚继承">虚继承</a></li><li><a class="toc-href" href="#_38" title="运行时类型识别">运行时类型识别</a></li></ul></li></ul></li></ul></div></body></html>
        </nav>
    </div>
    <div class="span8 article-content">

            <hr/>
<h3 id="_1">进程、线程、协程</h3>
<ol>
<li>
<p>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。</p>
</li>
<li>
<p>线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。</p>
</li>
<li>
<p>协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。基本上相当与用户空间下进行线程调度。</p>
</li>
</ol>
<h3 id="_2">静态内存、栈内存、堆内存</h3>
<ol>
<li>静态内存用来保存局部static对象、类static数据成员以及定义在任何函数之外的变量</li>
<li>栈内存用来保存定义在函数内的非static对象。分配在静态内存或者栈内存中的对象由编译器自动
创建和销毁。对于栈对象仅在其定义的程序块运行时才存在，static对象在使用之前分配，在程序
结束时销毁。</li>
<li>程序用堆来存储动态分配的对象，动态对象的生存周期由程序来控制。</li>
</ol>
<h3 id="const">Const</h3>
<ul>
<li>顶层const表示指针本身是个常量</li>
<li>底层const表示指针所指的对象是个常量</li>
</ul>
<p><strong>尽量使用常量引用</strong>，使用引用可以避免拷贝，使用const则避免修改实参的值。</p>
<h3 id="stringsize_type-size_t">string::size_type &amp; size_t</h3>
<ol>
<li><strong>size_t</strong></li>
</ol>
<p>size_t是sizeof操作符的结果返回类型，它在头文件中的typedef为
unsigned int 类型。该类型保证实现所建立的最大对象的字节大小。</p>
<ol>
<li><strong>string::size_type</strong></li>
</ol>
<p>string::size_type是一个无符号类型的值，而且能够存放下任何string对象的大小。所有
用于存放string类的size函数返回值的变量，都应该是string::size_type
类型的。</p>
<h3 id="_3">命名的强制类型转换</h3>
<p>一个命名的强制类型转换具有如下形式：</p>
<blockquote>
<p>cast-name<stype>(expression);</stype></p>
</blockquote>
<p>其中，type是转换的目标类型，而expression是要转换的值。如果type是引用类型，则结果是左值。
cast-name 是static_cast、dynamic_cast、const_cast和reinterpret_cast的一种。</p>
<div class="highlight"><pre><span class="code-line"><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pc</span><span class="p">;</span></span>
<span class="code-line"><span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">const_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span> <span class="p">(</span><span class="n">pc</span><span class="p">);</span>   <span class="c1">//正确但是通过p写值是未定义的行为</span></span>
</pre></div>
<h3 id="_4">实参入栈顺序</h3>
<div class="highlight"><pre><span class="code-line"><span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line"><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出10，b++先使用b然后再加加</span></span>
<span class="code-line"><span class="n">cout</span><span class="o">&lt;&lt;</span> <span class="o">++</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">b</span><span class="o">++&lt;&lt;++</span><span class="n">b</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// 输出5351</span></span>
</pre></div>
<p>在处理printf或者cout时，压栈顺序为从右向左，对于a++的结果，是有ebp寻址函数栈
空间来记录中间结果的，在最后给printf压栈的时候，再从栈中把中间结果取出来；而对于
++a的结果，则直接压寄存器变量，寄存器经过了所有的自增操作。</p>
<h3 id="_5">尾置迭代器</h3>
<p>迭代器的end成员负责返回指向容器尾元素的下一位置的迭代器，该迭代器表示容器的不存在的尾后
元素，作为处理完容器所有元素的标记。</p>
<div class="highlight"><pre><span class="code-line"><span class="kt">int</span> <span class="n">arr</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">};</span></span>
<span class="code-line"><span class="kt">int</span> <span class="o">*</span><span class="n">e</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span><span class="c1">// 指向arr尾元素的下一个位置的指针，相当于哨兵的作用。</span></span>
</pre></div>
<h3 id="_6">使用尾置返回类型</h3>
<p>任何函数的定义都可以使用尾置（trailing return type）返回，尾置返回类型跟在
形参列表后面并以一个-&gt;符号开头，同时为了表示函数真正的返回类型跟在形参列表之后，
可以在返回类型出现的地方放置一个auto：</p>
<div class="highlight"><pre><span class="code-line"><span class="k">auto</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)[</span><span class="mi">10</span><span class="p">];</span></span>
</pre></div>
<p>func返回一个函数指针，该指针指向一个含有10个整数的数组。</p>
<div class="highlight"><pre><span class="code-line"><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">size_type</span> <span class="n">pos</span><span class="p">;</span> <span class="c1">// why string::size_type</span></span>
</pre></div>
<blockquote>
<p>The std::string type defines size_type to be the name of the appropriate type for holding the number of characters in a string. Whenever we need a local variable to contain the size of a string, we should use std::string::size_type as the type of that variable.</p>
<p>The reason that we have given cols a type of std::string::size_type is to ensure that cols is capable of containing the number of characters in greeting, no matter how large that number might be. We could simply have said that cols has type int, and indeed, doing so would probably work. However, the value of cols depends on the size of the input to our program, and we have no control over how long that input might be. It is conceivable that someone might give our program a string so long that an int is insufficient to contain its length.</p>
</blockquote>
<h3 id="_7">列表初始化</h3>
<p>下面四条语句都可以：</p>
<div class="highlight"><pre><span class="code-line"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span></span>
<span class="code-line"><span class="kt">int</span> <span class="nf">i</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span></span>
<span class="code-line"><span class="kt">int</span> <span class="n">i</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span></span>
</pre></div>
<ul>
<li>void * 是一种特殊的指针类型，可以用于存放任意对象的地址。</li>
</ul>
<h3 id="const-constexpr">const 和 constexpr</h3>
<ul>
<li>如果想在多个文件之间共享const对象，必须在变量的定义之前加extern关键字</li>
<li>常量表达式是指值不会在改变并且在编译过程就能得到计算结果的表达式。</li>
</ul>
<div class="highlight"><pre><span class="code-line"><span class="k">const</span> <span class="kt">int</span> <span class="n">max_files</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">//是常量表达式</span></span>
<span class="code-line"><span class="k">const</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_size</span><span class="p">();</span> <span class="c1">//不是常量表达式，具体值在运行时才能得到</span></span>
</pre></div>
<blockquote>
<p>C++11 规定允许将变量声明为constexpr类型，以便由编译器来验证变量的值是否是一个常量
表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化</p>
</blockquote>
<div class="highlight"><pre><span class="code-line"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>       <span class="c1">// p是一个指向整型常量的指针</span></span>
<span class="code-line"><span class="k">constexpr</span> <span class="kt">int</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>   <span class="c1">// q是一个指向整数的常量指针。</span></span>
</pre></div>
<h3 id="_8">类型别名</h3>
<p>两种实现方式</p>
<ul>
<li>typedef    </li>
<li>using</li>
</ul>
<div class="highlight"><pre><span class="code-line">    <span class="k">using</span> <span class="n">SI</span> <span class="o">=</span> <span class="n">Sales_item</span><span class="p">;</span> <span class="c1">// SI是Sales_item的别名 </span></span>
</pre></div>
<blockquote>
<p>C++11引入auto类型说明符，用它就能让编译器替我们去分析表达式所属的类型
C++11引入decltype类型说明符，它的作用是选择并返回操作数的数据类型。</p>
</blockquote>
<p>字面值类型：
常量表达式的值需要在编译使就得到计算，因此对声明constexpr时用到的类型必须有所限制。因为这些类型一般都比较
简单，值也容易得到。就把它们称为"字面值类型(literal type)"</p>
<p>一个constexpr指针的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</p>
<h3 id="_9">类模版</h3>
<p>编译器根据模版创建类或函数的过程称为实例化，当使用模版时，需要指出编译器应把类或函数实例化成何种
类型。</p>
<h3 id="constexpr">内联函数和constexpr函数</h3>
<p>将函数指定为内联函数，通常就是将它在每个调用节点上内联地展开。</p>
<p>constexpr函数是指用于常量表达式的函数，同时要求函数的返回类型及所有形参的类型
都是字面值类型，而且函数体中必须有且只有一条return语句。</p>
<div class="highlight"><pre><span class="code-line"><span class="k">constexpr</span> <span class="kt">int</span> <span class="nf">new_sz</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="mi">42</span><span class="p">;}</span></span>
<span class="code-line"><span class="k">constexpr</span> <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="n">new_sz</span><span class="p">();</span><span class="c1">// foo是一个常量表达式</span></span>
</pre></div>
<p>对于某个给定的内联或者constexpr函数来说，它的多个定义必须完全一致，因此内联函数和
constexpr函数通常定义在头文件中。</p>
<h3 id="class-struct">class 和struct关键字</h3>
<p>使用class和struct定义类唯一的区别就是默认的访问权限。使用struct关键字，定义在第一个访问说明
符之前的成员是public的，如果我们使用class关键字，则这些成员是private的。</p>
<h3 id="_10">函数指针</h3>
<p>函数指针指向的是函数而非对象，函数的类型由它的返回类型和形参类型共同决定，与函数名无关。</p>
<h3 id="const_1">const</h3>
<p>在成员函数后面加const表示，这个函数是只读函数，不会改变类的数据成员。</p>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">Point</span><span class="p">{</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">xVal</span><span class="p">,</span> <span class="n">yVal</span><span class="p">;</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">GetY</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span></span>
<span class="code-line"><span class="p">};</span></span>
<span class="code-line"><span class="c1">//关键字const必须用同样的方式重复出现在函数实现里，否则编译会把它们看成不同的函数</span></span>
<span class="code-line"><span class="kt">int</span> <span class="n">Point</span><span class="o">::</span><span class="n">GetY</span><span class="p">()</span><span class="k">const</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">yVal</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<p>如果把const放在函数声明前就意味着函数的返回值是常量。同时在const成员函数中，用mutable修饰
成员变量名后，就可以修改类的成员变量。</p>
<p>在C中const是外部链接，它总是占用内存，而且它的名字是全局符，
C编译器不能把const看成一个编译器期间的常量，而在C++默认const是内部连接的，它
在编译期间就会确定值。</p>
<h2 id="_12">类</h2>
<p>类是C++语言中最基本的特性，它允许我们为自己的应用定义新类型，从而使得程序更加简洁。类有
两项基本功能：一是数据抽象，即定义数据成员和函数成员的能力。二是封装，即保护类的成员不被随意
访问的能力。</p>
<h3 id="_13">构造函数</h3>
<p>构造函数的任务是初始化对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数。</p>
<p>构造函数不能被声明成const的，当我们创建类的const对象时，直到构造函数完成初始化过程，对象才能
真正取得其常量属性，因此，构造函数在const对象的构造过程中可以向其写值。需要注意的是初始化const
对象或者引用类型的对象时后，必须在执行构造函数体之前完成初始化工作，所以可以使用初始化列表进行初始化工作。
因为初始化表的执行先于函数体。</p>
<h4 id="_14">默认构造函数</h4>
<p>如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数，
默认构造函数无需任何实参。</p>
<p>如果类包含有内置类型或者复合类型的成员，则只有当这些成员都被赋予了类内的初始值时，
这个类才适合于使用合成的构造函数</p>
<h3 id="_16">类类型</h3>
<div class="highlight"><pre><span class="code-line"><span class="k">struct</span> <span class="n">First</span><span class="p">{</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">memi</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="nf">geMem</span><span class="p">();</span></span>
<span class="code-line"><span class="p">};</span></span>
<span class="code-line"><span class="k">struct</span> <span class="n">Second</span><span class="p">{</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">memi</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="nf">getMem</span><span class="p">();</span></span>
<span class="code-line"><span class="p">};</span></span>
<span class="code-line"><span class="n">First</span> <span class="n">obj</span><span class="p">;</span></span>
<span class="code-line"><span class="n">Second</span> <span class="n">obj2</span> <span class="o">=</span> <span class="n">obj1</span><span class="p">;</span> <span class="c1">//错误，obj1和obj2类型不同</span></span>
</pre></div>
<p>即使两个类的成员列表完全一致，它们也是不同的类型，对于一个类来说，它的成员
和其他任何类的成员都不是一回事。</p>
<h3 id="_17">友元</h3>
<p>友元关系不存在传递性，每个类独立的负责自己的友元类或者友元函数。当第一个名字第一次
出现在一个友元声明中，我们隐式地假定该名字当前作用域是可见的，即使我们仅仅是用友元的类
的成员调用友元函数，它也必须是被显式的声明过。</p>
<h3 id="_18">成员初始化顺序</h3>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">test</span> <span class="p">{</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="n">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="o">:</span><span class="n">j</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="n">i</span><span class="p">(</span><span class="n">j</span><span class="p">){}</span> <span class="c1">// i先初始化</span></span>
<span class="code-line"><span class="k">private</span><span class="o">:</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span></span>
<span class="code-line"><span class="p">};</span></span>
</pre></div>
<p>构造函数的初始化值的顺序和成员声明的顺序保持一致，同时尽量避免使用某些成员初始化其他成员。</p>
<h3 id="_19">静态成员</h3>
<p>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名，static关键字则只
出现在类内部的声明语句中。</p>
<p>静态数据成员可以是不完全类型，非静态数据成员必须是完全类型才能使用。静态数据成员的类型可以是
它所属的类类型，而非静态数据成员则只能声明成它所属类的指针。</p>
<h3 id="_20">谓词</h3>
<p>谓词是一个可调用的表达式，其返回结果是一个能用做条件的值。标准库使用两种谓词：一元
谓词（只接受单一参数）和二元谓词（它们有两个参数）。（相当于if中的条件表达式）</p>
<h3 id="emplace">使用emplace操作</h3>
<p>当调用push或insert成员函数时，我们将元素类型的对象传递给它们，
这些对象被拷贝到容器中。而当我们调用一个emplace成员函数时，则是将参数
传递给元素类型的构造函数。emplace成员使用这些参数在容器管理的内存空间中直接
构造元素。</p>
<h3 id="adaptor">适配器（adaptor）</h3>
<p>容器、迭代器、和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为
看起来想另外一种事物一样。一个容器适配器接受一种已有的容器类型，使其看起来像一种
不同的类型。</p>
<h3 id="_21">动态内存</h3>
<p>程序使用动态内存出于以下三种原因：
1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要多个对象间共享数据。</p>
<h3 id="new-delete">new &amp; delete</h3>
<p>在自由空间分配的内存是无名的，因此<strong>new</strong>无法为其分配的对象命名，而是返回一个指向该对象
的指针：</p>
<div class="highlight"><pre><span class="code-line"><span class="kt">int</span> <span class="o">*</span><span class="n">pi</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="err">（</span><span class="mi">1024</span><span class="err">）</span><span class="p">;</span>  <span class="c1">//pi 指向的对象的值为1024</span></span>
<span class="code-line"><span class="n">vector</span> <span class="o">*</span><span class="n">pv</span> <span class="o">=</span> <span class="k">new</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">}</span><span class="c1">// 列表初始化</span></span>
</pre></div>
<p>我们传递给delete的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非new分配的内存，或者
将相同的指针值释放多次，其行为都是未定义的。</p>
<div class="highlight"><pre><span class="code-line"><span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pci</span> <span class="o">=</span> <span class="k">new</span> <span class="k">const</span> <span class="kt">int</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span></span>
<span class="code-line"><span class="k">delete</span> <span class="n">pci</span><span class="p">;</span></span>
</pre></div>
<p>当我们delete一个指针后，指针值就变为无效了，但在很多机器上指针仍保存着已经释放的动态内存的地址，这时候
指针就会变成悬空指针，即，指向一块曾经保存数据对象但现在已经无效（delete）的的内存的指针。解放方法是：在指针
即将离开其作用域之前释放掉它所<strong>关联</strong>的内存。如果需要保存指针可以在delete之后将nullptr赋予指针。</p>
<h3 id="shared_ptr">shared_ptr</h3>
<p>智能指针也是模块，我们创建一个智能指针时，必须提供指针可以指向的类型。</p>
<div class="highlight"><pre><span class="code-line"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">factory</span> <span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="c1">// shared_ptr 负责释放内存</span></span>
<span class="code-line">    <span class="k">return</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">arg</span><span class="p">);</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="kt">void</span> <span class="n">use_factory</span><span class="p">(</span><span class="n">T</span> <span class="n">arg</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">factory</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span></span>
<span class="code-line">    <span class="c1">// 使用p，p离开作用域，它指向的内存会被自动释放掉</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<p><strong>智能指针与动态数组</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="c1">// 为了使用shared_ptr必须提供一个删除器</span></span>
<span class="code-line"><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sp</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">],[](</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span><span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;});</span></span>
<span class="code-line"><span class="c1">// shared_ptr未定义下标运算符，并且不支持指针的算术运算</span></span>
<span class="code-line"><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="o">*</span><span class="p">(</span><span class="n">sp</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 使用get获取一个内置指针</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"><span class="n">sp</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span><span class="c1">//使用lambda释放数组，它使用delete[]</span></span>
</pre></div>
<h3 id="unique_ptr-weak_ptr">unique_ptr &amp; weak_ptr</h3>
<ol>
<li>unique_ptr拥有它所指指向的对象。与shared_ptr不同，某个时刻只能有一个unique_ptr指向
一个给定的对象。当unique_ptr对象被销毁时，它所指向的对象也被销毁。</li>
<li>weak_ptr是一种不控制所指向对象生存期的智能指针，它指向一个shared_ptr管理的对象。</li>
</ol>
<p>通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时的开销。通过
在运行时绑定删除器，shared_ptr使用户重载删除器更为方便。</p>
<h3 id="_22">释放动态数组</h3>
<div class="highlight"><pre><span class="code-line"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">arrT</span><span class="p">[</span><span class="mi">42</span><span class="p">];</span><span class="c1">// arrT 是一个42个int的数组的类型别名</span></span>
<span class="code-line"><span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">arrT</span><span class="p">;</span> <span class="c1">// 分配一个42个int的数组，p指向第一个元素</span></span>
<span class="code-line"><span class="k">delete</span> <span class="p">[]</span> <span class="n">p</span><span class="p">;</span>    <span class="c1">// 方括号是必须的，因为被分配的是一个数组</span></span>
</pre></div>
<h3 id="_23">析构函数</h3>
<p>在一个析构函数中，首先执行函数体（析构函数体被不直接销毁成员），然后销毁成员，成员按初始化顺序的逆序销毁。通常析构函数释放
对象在生存期分配的所有资源。隐式销毁一个内置指针类型的成员不会delete它所指向的对象。与普通指针不同
，智能指针是类类型，所以有析构函数，智能指针成员在析构阶段会被自动销毁。</p>
<p><strong>自动调用析构函数的情况</strong>
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器被销毁时，其元素被销毁
- 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 对于临时对象，当创建它的完整表达式结束时被销毁</p>
<h3 id="_24">删除的函数</h3>
<p>我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted
 function）来阻止拷贝。</p>
<div class="highlight"><pre><span class="code-line"><span class="k">struct</span> <span class="n">NoCopy</span><span class="p">{</span></span>
<span class="code-line">    <span class="n">NoCopy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// 使用合成的默认构造函数</span></span>
<span class="code-line">    <span class="n">NoCopy</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// 阻止拷贝</span></span>
<span class="code-line">    <span class="n">NoCopy</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NoCopy</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span><span class="c1">// 阻止拷贝</span></span>
<span class="code-line">    <span class="o">~</span><span class="n">NoCopy</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">//使用合成析构函数</span></span>
<span class="code-line"><span class="err">｝</span></span>
</pre></div>
<p>如果有一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应
的成员函数将被定义为删除的。</p>
<h3 id="_25">引用计数</h3>
<p>引用计数的工作方式如下：
- 除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少
对象与正在创建的对象共享状态。当创建一个对象时，计数器初始化为1
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享
的计数器，指出给定对象的状态又被一个新用户所共享。
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构
函数释放状态。
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器
变为0，拷贝赋值运算符就必须销毁状态。</p>
<h3 id="_26">拷贝和交换 ###</h3>
<div class="highlight"><pre><span class="code-line"><span class="n">HasPtr</span><span class="o">&amp;</span> <span class="n">HasPtr</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">HasPtr</span> <span class="n">rhs</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="c1">// rhs 是按值传递的，</span></span>
<span class="code-line">    <span class="c1">// 交换左侧运算对象和局部变量rhs的内容</span></span>
<span class="code-line">    <span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span> <span class="c1">// rhs指向本对象曾经使用的内存</span></span>
<span class="code-line">    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>  <span class="c1">// rhs被销毁，从而delete了rhs中的指针</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<h3 id="_27">右值引用</h3>
<p>右值引用就是必须绑定到右值的引用，右值引用有一个重要的性质--只能
绑定到一个将要销毁的对象。</p>
<p>一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是
对象的值。</p>
<div class="highlight"><pre><span class="code-line"><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span></span>
<span class="code-line"><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// 错误：不能将一个右值引用绑定到一个左值上</span></span>
<span class="code-line"><span class="kt">int</span> <span class="o">&amp;</span><span class="n">r2</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">42</span><span class="p">;</span>   <span class="c1">// 错误：i*42是个右值</span></span>
<span class="code-line"><span class="kt">int</span> <span class="o">&amp;&amp;</span><span class="n">rr2</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="mi">42</span><span class="p">;</span>  <span class="c1">// 正确：将rr2绑定到结果上</span></span>
</pre></div>
<h3 id="_28">移动&amp;拷贝</h3>
<p>如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过
拷贝构造函数来移动的，拷贝赋值运算符和移动赋值运算符的情况类似。</p>
<h3 id="_29">三/五原则</h3>
<p>三个基本的控制类的拷贝操作：拷贝构造函数，拷贝赋值函数，析构函数；
还有两个不新标准下的：移动构造函数，移动赋值函数。这所有五个拷贝控制成员应该看作一个整体；
一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。</p>
<h3 id="_30">引用限定符</h3>
<p>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指一个左值或者右值。类似const限定符，引用限定符
只能用于（非static）成员函数，且必须同时出现在函数的声明和定义中。</p>
<h3 id="_31">面向对象程序设计</h3>
<p><strong>面向对象程序设计</strong>的核心思想是数据抽象、继承和动态绑定。通过使用数据抽象，我们可以将类的
接口与实现分离；使用继承，可以定义相似的类型并对其相似关系建模；使用动态绑定，可以在一定
程度上忽略相似类型的区别，而以同意的方式使用它们的对象。</p>
<h3 id="_32">防止继承的发生</h3>
<p>如果一个类不想被其他类继承，或者不想考虑它是否适合作为一个基类，C++11新标准提供了一种
防止继承发生的方法，即在类名后跟一个关键字final：</p>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">NoDerived</span> <span class="k">final</span> <span class="p">{};</span> <span class="c1">// NoDerived 不能作为基类被继承</span></span>
</pre></div>
<h3 id="_33">纯虚函数</h3>
<p>一个纯虚函数无需定义，我们通过在函数体的位置书写=0就可以将一个虚函数
说明为纯虚函数。其中=0只能出现在类内部的虚函数声明语句处：</p>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">base</span><span class="o">:</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="kt">double</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//纯虚函数 </span></span>
<span class="code-line"><span class="p">};</span></span>
</pre></div>
<h3 id="_34">尾置返回类型与类型转换</h3>
<div class="highlight"><pre><span class="code-line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">It</span><span class="o">&gt;</span></span>
<span class="code-line"><span class="k">auto</span> <span class="n">fcn</span><span class="p">(</span><span class="n">It</span> <span class="n">beg</span><span class="p">,</span> <span class="n">It</span> <span class="n">end</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="k">return</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<h3 id="_35">转发</h3>
<p><strong>模版转发</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">F</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">flip</span><span class="p">(</span><span class="n">F</span> <span class="n">f</span><span class="p">,</span> <span class="n">T1</span> <span class="o">&amp;&amp;</span><span class="n">t1</span><span class="p">,</span> <span class="n">T2</span> <span class="o">&amp;&amp;</span><span class="n">t2</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="n">f</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t1</span><span class="p">));</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<p><strong>可变参数模版转发</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span></span>
<span class="code-line"><span class="kt">void</span> <span class="n">fun</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">..</span> <span class="n">args</span><span class="p">)</span></span>
<span class="code-line"><span class="p">{</span></span>
<span class="code-line">    <span class="n">work</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<h3 id="_36">命名空间</h3>
<p>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现
文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义
类及函数的方式：</p>
<ul>
<li>命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，
则这写成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间的成员的定义部分则置于另外的源文件中。</li>
</ul>
<h3 id="_37">虚继承</h3>
<p>虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的
基类子对象称为虚基类（virtual base class）。在这种机制下，不论虚基类
在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类
子对象。</p>
<h3 id="_38">运行时类型识别</h3>
<p>运行时类型识别（run-time type identification）的功能由两个运算符实现：
- typeid运算符，用于返回表达式的类型
- dynamic_cast 运算符，用于将基类的指针或引用安全地转换成派生类的指针或引用</p>
<p>在可能的情况下，最好定义虚函数而非直接接管类型管理的重任。</p>
<section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="../../../../../blog/2015/06/13/cpp/#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'houcj';


    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>
            

            <hr/>
<section>
    <h2>Related Posts</h2>
<ul class="related-posts-list">
<li><a href="../../../../../blog/2015/07/19/inside-cpp/" title="Inside the CPP Object Model">Inside the CPP Object Model</a></li>
</ul>
<hr />
</section>

            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-06-13T16:55:00+08:00">Jun 13, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#编程-ref">编程</a> 
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#CPP-ref">CPP
                    <span>2</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="https://twitter.com/chaojunhou" title="My Twitter Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-twitter sidebar-social-links"></i></a>
    <a href="https://www.tumblr.com/blog/houcj" title="My Tumblr Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-tumblr sidebar-social-links"></i></a>
    <a href="https://github.com/chaojunhou" title="My Github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
            <h4>Blogroll</h4>
			<ul ><a class="category-link" href="http://www.rudy-yuan.net">Rudy-yuan</a></ul>
            <ul ><a class="category-link" href="http://www.wengweitao.com">WWT</a></ul>
            <ul ><a class="category-link" href="http://hult.tiddlyspot.com">HULT</a></ul>
       
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
        
            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

<script type="text/javascript">
    var disqus_shortname = 'houcj';

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
        <script  language="javascript" type="text/javascript">
            function uncollapse() {
                var hash_str = window.location.hash;
                if (window.location.hash.match(/^#comment-\d+$/))
                {
                    var hash_str = '#disqus_thread';
                }
                $(hash_str).collapse({
                    toggle: true
                    })
            }
        </script>

        <script type="text/javascript" language="JavaScript">
            uncollapse(); 
        </script>
    </body>
      <!-- Baidu Button BEGIN 
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"250"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
 <!-- Baidu Button END -->
  </body>

  <!-- hitwebcounter Code START -->

<img src="http://hitwebcounter.com/counter/counter.php?page=6046616&style=0005&nbdigits=5&type=ip&initCount=0" title="" Alt=""   border="0" style="float:left">  

</html>