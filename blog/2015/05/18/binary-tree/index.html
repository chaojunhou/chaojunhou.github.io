<!DOCTYPE html>
<html lang="en-US">
    <head>
        <meta charset="utf-8"> 
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="google-site-verification" content="fdZTDVFyX3hKovPIzn1tgPixk_wysBXaPN8YQw1P8Jw" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="ChaoJun Hou" />
        <meta name="copyright" content="ChaoJun Hou" />

<meta name="keywords" content="算法, 计算机科学, " />

<meta property="og:title" content="二叉树 "/>
<meta property="og:url" content="../../../../../blog/2015/05/18/binary-tree/" />
<meta property="og:description" content="把二叉查找树保存到文件中 Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. You must be able to restore to the exact original BST using the saved format. 由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历 或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过 中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来 构造一棵二叉树。 构造二叉树的代码如下： void readBSTHelper ..." />
<meta property="og:site_name" content="Write the Code" />
<meta property="og:article:author" content="ChaoJun Hou" />
<meta property="og:article:published_time" content="2015-05-18T14:53:00+08:00" />
<meta name="twitter:title" content="二叉树 ">
<meta name="twitter:description" content="把二叉查找树保存到文件中 Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. You must be able to restore to the exact original BST using the saved format. 由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历 或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过 中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来 构造一棵二叉树。 构造二叉树的代码如下： void readBSTHelper ...">

        <title>二叉树  · Change the World | Write the Code
</title>
       
        <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css" rel="stylesheet">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.1/css/font-awesome.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../../../../../theme/css/style.css" media="screen">
        <link rel="stylesheet" type="text/css" href="../../../../../theme/css/solarizedlight.css" media="screen">
        <link rel="shortcut icon" href="../../../../../theme/images/favicon.ico" type="image/x-icon" />
        <link rel="apple-touch-icon" href="../../../../../theme/images/apple-touch-icon.png" />
        <link rel="apple-touch-icon" sizes="57x57" href="../../../../../theme/images/apple-touch-icon-57x57.png" />
        <link rel="apple-touch-icon" sizes="72x72" href="../../../../../theme/images/apple-touch-icon-72x72.png" />
        <link rel="apple-touch-icon" sizes="114x114" href="../../../../../theme/images/apple-touch-icon-114x114.png" />
        <link rel="apple-touch-icon" sizes="144x144" href="../../../../../theme/images/apple-touch-icon-144x144.png" />
        <link rel="icon" href="../../../../../theme/images/apple-touch-icon-144x144.png" />
        <link href="www.houcj.net/feed.xml" type="application/rss+xml" rel="alternate" title="Write the Code - Full RSS Feed" />
<script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
     (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
     m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
     })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '61957498', 'auto');
    ga('send', 'pageview');
</script>

    </head>
    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-61957498-1', 'auto');
  ga('send', 'pageview');

	</script>
    <body>
        <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container-fluid">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="../../../../../"><span class=site-name>Write the Code</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="../../../../..">Home</a></li>
                            <li ><a href="../../../../../pages/About.html">About</a></li>
                            <li ><a href="../../../../../random.html">Pick One!</a></li>
                            <li ><a href="../../../../../categories.html">分类</a></li>
                            <li ><a href="../../../../../tags.html">标签</a></li>
                            <li ><a href="../../../../../archives.html">归档</a></li>
                            <li><form class="navbar-search" action="../../../../../search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
<div class="row-fluid">
    <header class="page_header span10 offset2">
    <h1><a href="../../../../../blog/2015/05/18/binary-tree/"> 二叉树  </a></h1>
    </header>
</div>

<div class="row-fluid">
    <div class="span2 table-of-content">
        <nav>
        <h4>Contents</h4>
        <html><body><div id="toc"><ul><li><a class="toc-href" href="#" title="二叉树">二叉树</a><ul><li><a class="toc-href" href="#_1" title="把二叉查找树保存到文件中">把二叉查找树保存到文件中</a></li><li><a class="toc-href" href="#serializationdeserialization-of-a-binary-tree" title="Serialization|Deserialization of a Binary Tree">Serialization|Deserialization of a Binary Tree</a></li><li><a class="toc-href" href="#printing-a-binary-tree-in-level-order" title="Printing a Binary Tree in Level Order">Printing a Binary Tree in Level Order</a><ul><li><a class="toc-href" href="#bfs" title="BFS">BFS</a></li><li><a class="toc-href" href="#dfs" title="DFS">DFS</a></li></ul></li><li><a class="toc-href" href="#morris_1" title="Morris二叉树遍历算法">Morris二叉树遍历算法</a><ul><li><a class="toc-href" href="#_2" title="原理">原理</a></li><li><a class="toc-href" href="#_3" title="中序遍历">中序遍历</a></li><li><a class="toc-href" href="#python-code" title="Python Code">Python Code</a></li><li><a class="toc-href" href="#_4" title="后序遍历">后序遍历</a></li></ul></li><li><a class="toc-href" href="#count-complete-tree-nodes_1" title="Count Complete Tree Nodes">Count Complete Tree Nodes</a></li><li><a class="toc-href" href="#_5" title="分析">分析</a><ul><li><a class="toc-href" href="#cpp-code" title="CPP Code">CPP Code</a></li></ul></li><li><a class="toc-href" href="#convert-sorted-list-to-balanced-binary-search-tree-bst_1" title="Convert Sorted List to Balanced Binary Search Tree (BST)">Convert Sorted List to Balanced Binary Search Tree (BST)</a></li><li><a class="toc-href" href="#convert-binary-search-tree-bst-to-sorted-doubly-linked-list" title="Convert Binary Search Tree (BST) to Sorted Doubly-Linked List">Convert Binary Search Tree (BST) to Sorted Doubly-Linked List</a></li></ul></li></ul></div></body></html>
        </nav>
    </div>
    <div class="span8 article-content">

            <hr/>
<h3 id="_1">把二叉查找树保存到文件中</h3>
<blockquote>
<p>Describe an algorithm to save a Binary Search Tree (BST) to a file in terms of run-time and disk space complexity. 
You must be able to restore to the exact original BST using the saved format.</p>
</blockquote>
<p><strong>由于二叉排序树在中序遍历中为一个升序的序列，因此考虑使用前序遍历
或者后序遍历来保存二叉树的信息。使用后序遍历时，每个parent节点都在children节点之后，无法有效的通过
中序遍历文件中的数据来重新构造一棵二叉树。因此使用二叉树前序遍历来保存这些节点的信息，同时使用中序遍历来
构造一棵二叉树。</strong>
<strong>构造二叉树的代码如下：</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="kt">void</span> <span class="nf">readBSTHelper</span><span class="p">(</span><span class="kt">int</span> <span class="n">min</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">insertVal</span><span class="p">,</span></span>
<span class="code-line">                   <span class="n">BinaryTree</span> <span class="o">*&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="n">insertVal</span> <span class="o">&gt;</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">insertVal</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">insertVal</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">val</span><span class="p">);</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">insertVal</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">      <span class="n">readBSTHelper</span><span class="p">(</span><span class="n">min</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span></span>
<span class="code-line">      <span class="n">readBSTHelper</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">max</span><span class="p">,</span> <span class="n">insertVal</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">  <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="kt">void</span> <span class="nf">readBST</span><span class="p">(</span><span class="n">BinaryTree</span> <span class="o">*&amp;</span><span class="n">root</span><span class="p">,</span> <span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">fin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">readBSTHelper</span><span class="p">(</span><span class="n">INT_MIN</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<hr/>
<h3 id="serializationdeserialization-of-a-binary-tree">Serialization|Deserialization of a Binary Tree</h3>
<blockquote>
<p>Design an algorithm and write code to serialize and deserialize a binary tree.
Writing the tree to a file is called &lsquo;serialization&rsquo; and reading back from the file to reconstruct the exact same binary tree is &lsquo;deserialization&rsquo;.</p>
</blockquote>
<p><strong>在二叉排序树中，中序遍历是有序的，而普通的二叉树就没有这样的性质。因此需要使用哨兵来输出那些空的节点，来最终确定每个
节点的位置。这里使用前序遍历。</strong></p>
<p><strong>Cpp Code</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="kt">void</span> <span class="nf">writeBinaryTree</span><span class="p">(</span><span class="n">BinaryTree</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">ostream</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="s">"# "</span><span class="p">;</span></span>
<span class="code-line">  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span></span>
<span class="code-line">    <span class="n">writeBinaryTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">writeBinaryTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">out</span><span class="p">);</span></span>
<span class="code-line">  <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<p><strong>从文件中读取这个二叉树的操作也是类似的。我们同样使用先序遍历，如果遍历到的节点是一个哨兵，说明是
空节点，我们忽视这个节点就好。如果是一个具体的数值，我们就把它插入到当前的节点，然后遍历它的左孩子，
然后遍历它的右孩子。</strong></p>
<p><strong>Cpp Code</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="kt">void</span> <span class="nf">readBinaryTree</span><span class="p">(</span><span class="n">BinaryTree</span> <span class="o">*&amp;</span><span class="n">p</span><span class="p">,</span> <span class="n">ifstream</span> <span class="o">&amp;</span><span class="n">fin</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="kt">int</span> <span class="n">token</span><span class="p">;</span></span>
<span class="code-line">  <span class="kt">bool</span> <span class="n">isNumber</span><span class="p">;</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">readNextToken</span><span class="p">(</span><span class="n">token</span><span class="p">,</span> <span class="n">fin</span><span class="p">,</span> <span class="n">isNumber</span><span class="p">))</span> </span>
<span class="code-line">    <span class="k">return</span><span class="p">;</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="n">isNumber</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">token</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">readBinaryTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span></span>
<span class="code-line">    <span class="n">readBinaryTree</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">fin</span><span class="p">);</span></span>
<span class="code-line">  <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<p><strong>当然我们也可以使用层次遍历。</strong></p>
<hr/>
<h3 id="printing-a-binary-tree-in-level-order">Printing a Binary Tree in Level Order</h3>
<blockquote>
<p>Given a binary tree, print out the tree in level order (ie, from left to right, level by level). Output a newline after the end of each level.</p>
</blockquote>
<div class="highlight"><pre><span class="code-line">     3</span>
<span class="code-line">   /  \</span>
<span class="code-line">  9   20    </span>
<span class="code-line">     /  \</span>
<span class="code-line">    15    7</span>
</pre></div>
<p>For example, the level order output of the tree above is:</p>
<div class="highlight"><pre><span class="code-line">3 </span>
<span class="code-line">9 20 </span>
<span class="code-line">15 7</span>
</pre></div>
<p><strong>可以使用BFS或者DFS</strong></p>
<h4 id="bfs">BFS</h4>
<p><strong>使用BFS时，需要记录一层的节点数目，以及下层的节点数目。当这层的
节点数目为0的时候，说明这层的节点已经完全被输出。然后接着输出下一层。</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="kt">void</span> <span class="nf">printLevelOrder</span><span class="p">(</span><span class="n">BinaryTree</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">queue</span><span class="o">&lt;</span><span class="n">BinaryTree</span><span class="o">*&gt;</span> <span class="n">nodesQueue</span><span class="p">;</span></span>
<span class="code-line">  <span class="kt">int</span> <span class="n">nodesInCurrentLevel</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></span>
<span class="code-line">  <span class="kt">int</span> <span class="n">nodesInNextLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">nodesQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">root</span><span class="p">);</span></span>
<span class="code-line">  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">nodesQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span></span>
<span class="code-line">    <span class="n">BinaryTree</span> <span class="o">*</span><span class="n">currNode</span> <span class="o">=</span> <span class="n">nodesQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span></span>
<span class="code-line">    <span class="n">nodesQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span></span>
<span class="code-line">    <span class="n">nodesInCurrentLevel</span><span class="o">--</span><span class="p">;</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">currNode</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">currNode</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span></span>
<span class="code-line">      <span class="n">nodesQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">currNode</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span></span>
<span class="code-line">      <span class="n">nodesQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">currNode</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span></span>
<span class="code-line">      <span class="n">nodesInNextLevel</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span></span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line">    <span class="k">if</span> <span class="p">(</span><span class="n">nodesInCurrentLevel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">      <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span></span>
<span class="code-line">      <span class="n">nodesInCurrentLevel</span> <span class="o">=</span> <span class="n">nodesInNextLevel</span><span class="p">;</span></span>
<span class="code-line">      <span class="n">nodesInNextLevel</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">     <span class="p">}</span></span>
<span class="code-line">  <span class="p">}</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<h4 id="dfs">DFS</h4>
<p><strong>使用DFS时需要记录递归的深度，根据递归的深度来确定层数</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">Solution</span><span class="p">:</span></span>
<span class="code-line">    <span class="c"># @param root, a tree node</span></span>
<span class="code-line">    <span class="c"># @return a list of lists of integers</span></span>
<span class="code-line">    <span class="k">def</span> <span class="nf">levelOrder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span></span>
<span class="code-line">        <span class="n">res</span><span class="o">=</span> <span class="p">[]</span> </span>
<span class="code-line">        <span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">depth</span><span class="p">):</span></span>
<span class="code-line">            <span class="k">if</span> <span class="n">root</span><span class="p">:</span></span>
<span class="code-line">                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur</span> <span class="o">==</span> <span class="n">depth</span><span class="p">:</span></span>
<span class="code-line">                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">])</span></span>
<span class="code-line">                    <span class="bp">self</span><span class="o">.</span><span class="n">cur</span> <span class="o">+=</span> <span class="mi">1</span></span>
<span class="code-line">                <span class="k">else</span><span class="p">:</span></span>
<span class="code-line">                    <span class="n">res</span><span class="p">[</span><span class="n">depth</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">val</span><span class="p">)</span></span>
<span class="code-line">                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">left</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></span>
<span class="code-line">                <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">right</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span></span>
<span class="code-line">        <span class="k">if</span> <span class="n">root</span><span class="p">:</span></span>
<span class="code-line">            <span class="bp">self</span><span class="o">.</span><span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span></span>
<span class="code-line">            <span class="n">dfs</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span></span>
<span class="code-line">        <span class="k">return</span> <span class="n">res</span></span>
</pre></div>
<hr/>
<h3 id="morris_1">Morris二叉树遍历算法</h3>
<p>对于二叉树的遍历，可以使用递归或者堆栈，但morris遍历，使用
无堆栈，O（1）空间进行二叉树遍历。</p>
<h4 id="_2">原理</h4>
<p>利用所有叶子节点的右指针，指向其后继节点，形成一个环，在第二次遍历到这个节点时，
由于左子树已经遍历完了，则访问该节点。</p>
<h4 id="_3">中序遍历</h4>
<div class="highlight"><pre><span class="code-line">算法伪码：</span>
<span class="code-line">1. Initialize current as root </span>
<span class="code-line">2. While current is not NULL</span>
<span class="code-line">   If current does not have left child</span>
<span class="code-line">      a) Print current&rsquo;s data</span>
<span class="code-line">      b) Go to the right, i.e., current = current-&gt;right</span>
<span class="code-line">   Else</span>
<span class="code-line">      a) Make current as right child of the rightmost node in current's left subtree</span>
<span class="code-line">      b) Go to this left child, i.e., current = current-&gt;left</span>
</pre></div>
<h4 id="python-code">Python Code</h4>
<div class="highlight"><pre><span class="code-line">    <span class="k">def</span> <span class="nf">morris_inorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span></span>
<span class="code-line">        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span></span>
<span class="code-line">        <span class="n">p</span> <span class="o">=</span> <span class="n">root</span></span>
<span class="code-line">        <span class="k">while</span> <span class="n">p</span><span class="p">:</span></span>
<span class="code-line">            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span></span>
<span class="code-line">                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="p">)</span></span>
<span class="code-line">                <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">right</span></span>
<span class="code-line">            <span class="k">else</span><span class="p">:</span></span>
<span class="code-line">                <span class="n">tmp</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">left</span></span>
<span class="code-line">                <span class="k">while</span> <span class="n">tmp</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">tmp</span><span class="o">.</span><span class="n">right</span> <span class="o">!=</span> <span class="n">p</span><span class="p">:</span></span>
<span class="code-line">                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">right</span></span>
<span class="code-line">                <span class="k">if</span>  <span class="n">tmp</span><span class="o">.</span><span class="n">right</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span></span>
<span class="code-line">                    <span class="n">tmp</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">p</span></span>
<span class="code-line">                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">left</span></span>
<span class="code-line">                <span class="k">else</span><span class="p">:</span></span>
<span class="code-line">                    <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">val</span><span class="p">)</span></span>
<span class="code-line">                    <span class="n">tmp</span><span class="o">.</span><span class="n">right</span> <span class="o">=</span> <span class="bp">None</span></span>
<span class="code-line">                    <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">right</span></span>
<span class="code-line">        <span class="k">return</span> <span class="n">res</span></span>
</pre></div>
<p><strong>Morris的前序遍历和中序遍历比较类似，只不过在前驱节点为空的时候，直接输出当前的节点</strong></p>
<h4 id="_4">后序遍历</h4>
<p>后序遍历比较复杂，需要建立一个临时节点dump，令其左孩子为root，并且需要一个倒序输出某两个节点
之间路径的各个节点的自过程。</p>
<p><strong>具体实现和测试代码见<a href="https://github.com/chaojunhou/Morris">Github</a></strong></p>
<hr/>
<h3 id="count-complete-tree-nodes_1">Count Complete Tree Nodes</h3>
<blockquote>
<p>Given a complete binary tree, count the number of nodes.</p>
<p>In a complete binary tree every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.</p>
</blockquote>
<h3 id="_5">分析</h3>
<p>根据左右子树的高度判断下次从左子树还是右子树进行查找，类似二分查找，时间复杂度为O（lgn）*O(lgn)树高
因此总的时间复杂度为O（lgn^2），具体实现有很多方式，需要注意的是，当判断这棵树为完全树的时候
应该马上返回它的节点数目，以此加快递归的返回速度。</p>
<h4 id="cpp-code">CPP Code</h4>
<div class="highlight"><pre><span class="code-line"><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span></span>
<span class="code-line"><span class="k">public</span><span class="o">:</span></span>
<span class="code-line">    <span class="kt">int</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">L</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line">        <span class="n">TreeNode</span> <span class="o">*</span><span class="n">R</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span></span>
<span class="code-line">        <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span>
<span class="code-line">        <span class="k">while</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span></span>
<span class="code-line">        <span class="p">{</span>   </span>
<span class="code-line">            <span class="n">height</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">;</span></span>
<span class="code-line">            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="k">if</span> <span class="p">(</span><span class="n">L</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span></span>
<span class="code-line">        <span class="p">{</span></span>
<span class="code-line">            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">height</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="p">;</span></span>
<span class="code-line">        <span class="p">}</span></span>
<span class="code-line">        <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span><span class="o">+</span><span class="n">countNodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>        </span>
<span class="code-line">    <span class="p">}</span></span>
<span class="code-line"><span class="p">};</span></span>
</pre></div>
<hr/>
<h3 id="convert-sorted-list-to-balanced-binary-search-tree-bst_1">Convert Sorted List to Balanced Binary Search Tree (BST)</h3>
<blockquote>
<p>Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.</p>
</blockquote>
<p><strong>由于链表只能顺序遍历，因此最优的解法应该是在遍历链表的同时，构造这个二叉查找树。
因此我们采取bottom-up(而非通常的top-down)的方法，从底到上创建二叉查找树节点，然后把他们分配到它们的父亲节点中
这样就可以一边遍历，一遍构造二叉查找树。</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="n">BinaryTree</span><span class="o">*</span> <span class="nf">sortedListToBST</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*&amp;</span> <span class="n">list</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span></span>
<span class="code-line">  <span class="c1">// same as (start+end)/2, avoids overflow</span></span>
<span class="code-line">  <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">BinaryTree</span> <span class="o">*</span><span class="n">leftChild</span> <span class="o">=</span> <span class="n">sortedListToBST</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></span>
<span class="code-line">  <span class="n">BinaryTree</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BinaryTree</span><span class="p">(</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span></span>
<span class="code-line">  <span class="n">parent</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">leftChild</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">parent</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">sortedListToBST</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span></span>
<span class="code-line">  <span class="k">return</span> <span class="n">parent</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="n">BinaryTree</span><span class="o">*</span> <span class="nf">sortedListToBST</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">return</span> <span class="n">sortedListToBST</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<hr/>
<h3 id="convert-binary-search-tree-bst-to-sorted-doubly-linked-list">Convert Binary Search Tree (BST) to Sorted Doubly-Linked List</h3>
<p><strong>同上面的方法类似，我们可以采用中序遍历的方法，把每个遍历到的节点依次插入到
双向链表中，同时保持双向链表的有序性</strong></p>
<div class="highlight"><pre><span class="code-line"><span class="kt">void</span> <span class="nf">treeToDoublyList</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*&amp;</span> <span class="n">prev</span><span class="p">,</span> <span class="n">Node</span> <span class="o">*&amp;</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">treeToDoublyList</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span></span>
<span class="code-line">  <span class="c1">// current node's left points to previous node</span></span>
<span class="code-line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span></span>
<span class="code-line">  <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span></span>
<span class="code-line">    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// previous node's right points to current node</span></span>
<span class="code-line">  <span class="k">else</span></span>
<span class="code-line">    <span class="n">head</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// current node (smallest element) is head of</span></span>
<span class="code-line">              <span class="c1">// the list if previous node is not available</span></span>
<span class="code-line">  <span class="c1">// as soon as the recursion ends, the head's left pointer </span></span>
<span class="code-line">  <span class="c1">// points to the last node, and the last node's right pointer</span></span>
<span class="code-line">  <span class="c1">// points to the head pointer.</span></span>
<span class="code-line">  <span class="n">Node</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">head</span><span class="o">-&gt;</span><span class="n">previous</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span> <span class="n">head</span><span class="p">;</span></span>
<span class="code-line">  <span class="c1">// updates previous node</span></span>
<span class="code-line">  <span class="n">prev</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">treeToDoublyList</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span></span>
<span class="code-line"><span class="p">}</span></span>
<span class="code-line"></span>
<span class="code-line"><span class="c1">// Given an ordered binary tree, returns a sorted circular</span></span>
<span class="code-line"><span class="c1">// doubly-linked list. The conversion is done in-place.</span></span>
<span class="code-line"><span class="n">Node</span><span class="o">*</span> <span class="nf">treeToDoublyList</span><span class="p">(</span><span class="n">Node</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span></span>
<span class="code-line">  <span class="n">Node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">Node</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span></span>
<span class="code-line">  <span class="n">treeToDoublyList</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span></span>
<span class="code-line">  <span class="k">return</span> <span class="n">head</span><span class="p">;</span></span>
<span class="code-line"><span class="p">}</span></span>
</pre></div>
<section>
<div class="accordion" id="accordion2">
    <div class="accordion-group">
        <div class="accordion-heading">
            <a class="accordion-toggle disqus-comment-count" data-toggle="collapse" data-parent="#accordion2"
                href="../../../../../blog/2015/05/18/binary-tree/#disqus_thread">
                Comments
            </a>
        </div>
        <div id="disqus_thread" class="accordion-body collapse">
            <div class="accordion-inner">
                <div class="comments">
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'houcj';


    (function() {
         var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
         dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
         (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>                </div>
            </div>
        </div>
    </div>
</div>
</section>
            

            <hr/>
<section>
    <h2>Related Posts</h2>
<ul class="related-posts-list">
<li><a href="../../../../../blog/2013/12/22/string-related/" title="字符串相关">字符串相关</a></li>
<li><a href="../../../../../blog/2014/02/18/equal-probability/" title="概率问题">概率问题</a></li>
<li><a href="../../../../../blog/2014/03/21/kmp/" title="字符串匹配">字符串匹配</a></li>
<li><a href="../../../../../blog/2015/04/25/cal24/" title="24点游戏编程">24点游戏编程</a></li>
<li><a href="../../../../../blog/2015/05/05/sifting-prime/" title="素数筛选法">素数筛选法</a></li>
<li><a href="../../../../../blog/2015/05/05/reverse-linked-list/" title="反转链表">反转链表</a></li>
<li><a href="../../../../../blog/2015/05/24/select/" title="选择算法">选择算法</a></li>
<li><a href="../../../../../blog/2015/05/28/search/" title="查找算法">查找算法</a></li>
<li><a href="../../../../../blog/2015/05/28/find-a-solution/" title="How to find a solution">How to find a solution</a></li>
<li><a href="../../../../../blog/2015/05/31/sort1/" title="排序算法">排序算法</a></li>
</ul>
<hr />
</section>

            </aside>
        </div>
        <section>
        <div class="span2" style="float:right;font-size:0.9em;">
 
            <h4>Published</h4>
            <time pubdate="pubdate" datetime="2015-05-18T14:53:00+08:00">May 18, 2015</time>
            <h4>Category</h4>
            <a class="category-link" href="/categories.html#计算机科学-ref">计算机科学</a> 
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article"> 
                <li><a href="/tags.html#算法-ref">算法
                    <span>13</span>
</a></li>
            </ul>
<h4>Contact</h4>
    <a href="https://twitter.com/chaojunhou" title="My Twitter Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-twitter sidebar-social-links"></i></a>
    <a href="https://www.tumblr.com/blog/houcj" title="My Tumblr Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-tumblr sidebar-social-links"></i></a>
    <a href="https://github.com/chaojunhou" title="My Github Profile" class="sidebar-social-links" target="_blank">
    <i class="fa fa-github sidebar-social-links"></i></a>
            <h4>Blogroll</h4>
			<ul ><a class="category-link" href="http://www.rudy-yuan.net">Rudy-yuan</a></ul>
            <ul ><a class="category-link" href="http://www.wengweitao.com">WWT</a></ul>
            <ul ><a class="category-link" href="http://hult.tiddlyspot.com">HULT</a></ul>
       
        </div>
        </section>
</div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
        <div id="push"></div>
    </div>
        
            <script src="http://code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

<script type="text/javascript">
    var disqus_shortname = 'houcj';

    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
    </script>
        <script  language="javascript" type="text/javascript">
            function uncollapse() {
                var hash_str = window.location.hash;
                if (window.location.hash.match(/^#comment-\d+$/))
                {
                    var hash_str = '#disqus_thread';
                }
                $(hash_str).collapse({
                    toggle: true
                    })
            }
        </script>

        <script type="text/javascript" language="JavaScript">
            uncollapse(); 
        </script>
    </body>
      <!-- Baidu Button BEGIN 
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"16"},"slide":{"type":"slide","bdImg":"6","bdPos":"right","bdTop":"250"},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
 <!-- Baidu Button END -->
  </body>

  <!-- hitwebcounter Code START -->

<img src="http://hitwebcounter.com/counter/counter.php?page=6046616&style=0005&nbdigits=5&type=ip&initCount=0" title="" Alt=""   border="0" style="float:left">  

</html>