<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Write the Code</title><link>www.houcj.net/</link><description></description><atom:link href="www.houcj.net/feeds/ji-suan-ji-ke-xue.rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 06 Sep 2014 00:00:00 +0800</lastBuildDate><item><title>Skip List</title><link>www.houcj.net/blog/2014/09/06/skip-list/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sat, 06 Sep 2014 00:00:00 +0800</pubDate><guid>tag:,2014-09-06:www.houcj.net/blog/2014/09/06/skip-list/</guid><category>数据结构</category></item><item><title>The basic operation</title><link>www.houcj.net/blog/2014/06/02/the-basic-operation/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Mon, 02 Jun 2014 00:00:00 +0800</pubDate><guid>tag:,2014-06-02:www.houcj.net/blog/2014/06/02/the-basic-operation/</guid><category>算法</category></item><item><title>Permutation and combination</title><link>www.houcj.net/blog/2014/05/27/permutation-and-combination/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Tue, 27 May 2014 00:00:00 +0800</pubDate><guid>tag:,2014-05-27:www.houcj.net/blog/2014/05/27/permutation-and-combination/</guid><category>算法</category></item><item><title>catalan</title><link>www.houcj.net/blog/2014/04/01/catalan/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Tue, 01 Apr 2014 00:00:00 +0800</pubDate><guid>tag:,2014-04-01:www.houcj.net/blog/2014/04/01/catalan/</guid><category>算法</category></item><item><title>KMP</title><link>www.houcj.net/blog/2014/03/21/kmp/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Fri, 21 Mar 2014 00:00:00 +0800</pubDate><guid>tag:,2014-03-21:www.houcj.net/blog/2014/03/21/kmp/</guid><category>算法</category></item><item><title>dynamic programming</title><link>www.houcj.net/blog/2014/03/02/dynamic-programming/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 02 Mar 2014 00:00:00 +0800</pubDate><guid>tag:,2014-03-02:www.houcj.net/blog/2014/03/02/dynamic-programming/</guid><category>算法</category></item><item><title>equal probability</title><link>www.houcj.net/blog/2014/02/18/equal-probability/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Tue, 18 Feb 2014 00:00:00 +0800</pubDate><guid>tag:,2014-02-18:www.houcj.net/blog/2014/02/18/equal-probability/</guid><category>算法</category></item><item><title>Trie Tree</title><link>www.houcj.net/blog/2014/02/13/trie-tree/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Thu, 13 Feb 2014 00:00:00 +0800</pubDate><guid>tag:,2014-02-13:www.houcj.net/blog/2014/02/13/trie-tree/</guid><category>数据结构</category></item><item><title>TCP中的七种定时器</title><link>www.houcj.net/blog/2014/01/02/timer/</link><description>&lt;p&gt;TCP为每个连接建立了七个定时器。下面讲按照这些定时器在一条连接生存期内出现的次序依次进行介绍。
 &lt;img src="/images/fsm.png" width = "550" height = "=283" alt="FSM" align=center /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection establishment Timer(​连接建立定时器)&lt;ul&gt;
&lt;li&gt;为了防止client端一直等待服务器端的情况发生。 在Client发送SYN报文段建立新的链接时，该定时器启动，如果在75s内没有收到响应，连接建立将会终止。确定连接的有效建立。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Retransmission Timer(重传定时器)&lt;ul&gt;
&lt;li&gt;重传定时器在TCP发送数据时设定。在该定时器超时，而没有收到另外一端的ACK的时候，将重传数据。重传定时器的值是动态计算的，取决于该连接RTT的值和被重传的次数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Delayed ACK Timer(延迟ACK定时器)定时器在200ms&lt;ul&gt;
&lt;li&gt;延迟ACK定时器负责在该终端（end）收到一个数据包时，无需马上发出ACK进行确认，而是等待200ms内，有数据要在该连接上发送，延迟的ACK响应就可随着数据一起发送回另一个终端。这种方式也被成为捎带确认。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Persist Timer（持续定时器）&lt;ul&gt;
&lt;li&gt;持续定时器在收到连接另一端的发送通告窗口为零时，阻止该端继续发送数据时设定。因此当该端有数据要发送时， 但连接的另一端的通告窗口为零时，持续定时器就会启动，超时后向连接另一端发送1字节的数据，来判断另一方的接收窗口是否打开。被称为零窗口探测。持续定时器的值是动态计算的，取决于往返时间，时间在5s到60s之间取值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Keep alive Timer（保活定时器）&lt;ul&gt;
&lt;li&gt;如果连接的持续时间超过2hour，保活定时器就会超时，向对端发送连接探测报文，强迫对端发出响应。如果连续若干次保活测试收不到相应的相应，就认为对端发生了故障。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN_WAIT_2 Timer&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当某个连接从FIN_WAIT_1状态变迁到FIN_WAIT_2状态，并且不能再收到任何新的数据时，该定时器就会启动设为10分钟。定时器超时重设为75s，第二次超时后连接被关闭。该定时器的目的是为了避免对方一直不发送FIN，某个连接一直处于FIN_WAIT_2状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TIME_WAIT_Timer (也成为2MSL定时器)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当连接转移到TIME_WAIT状态，定时器启动。2MSL等待时间的原因就是为了确保最后一个ACK在一个MSL丢包后重传&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TCP包括连个定时器函数，快速定时器（200ms调用一次），慢速定时器（500ms）调用一次。延迟ACK定时器时，每个200ms超时后，延迟的ACK必须被发送。其他的定时器是每500ms递减一次，计数器减为0时，就触发相应的动作。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Thu, 02 Jan 2014 00:00:00 +0800</pubDate><guid>tag:,2014-01-02:www.houcj.net/blog/2014/01/02/timer/</guid><category>TCP</category></item><item><title>Black Red Tree</title><link>www.houcj.net/blog/2013/12/22/black-red-tree/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 22 Dec 2013 00:00:00 +0800</pubDate><guid>tag:,2013-12-22:www.houcj.net/blog/2013/12/22/black-red-tree/</guid><category>数据结构</category></item><item><title>Longest Palindromic Substring</title><link>www.houcj.net/blog/2013/12/22/longest-palindromic-substring/</link><description>&lt;p&gt;&lt;strong&gt;题目：Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：从头开始遍历整个字符串。然后以每个字符串为中点向两边扩展，直到最长的Palindromic，记录中间出现的Palindromic的最大长度。需要注意的是Palindromic的长度可能为奇数也可能为偶数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间复杂度：O(n^2)&lt;/strong&gt;
&lt;strong&gt;空间复杂度：O(1)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Show the code:&lt;/strong&gt;
Run Time: 1247 ms&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Solution&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="c"&gt;# @return a string&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;longestPalindrome&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;left&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;left&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;for&lt;/span&gt;  &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;len1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;len2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expand&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="n"&gt;Len&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;max&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;len1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;len2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Len&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Len&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;                &lt;span class="n"&gt;end&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Len&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;s&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;  &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 22 Dec 2013 00:00:00 +0800</pubDate><guid>tag:,2013-12-22:www.houcj.net/blog/2013/12/22/longest-palindromic-substring/</guid><category>算法</category></item><item><title>N Queen</title><link>www.houcj.net/blog/2013/12/22/n-queen/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 22 Dec 2013 00:00:00 +0800</pubDate><guid>tag:,2013-12-22:www.houcj.net/blog/2013/12/22/n-queen/</guid><category>算法</category></item><item><title>Suffix Array</title><link>www.houcj.net/blog/2013/12/22/suffix-array/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 22 Dec 2013 00:00:00 +0800</pubDate><guid>tag:,2013-12-22:www.houcj.net/blog/2013/12/22/suffix-array/</guid><category>算法</category></item><item><title>TCP Congestion Control 中的相关参数</title><link>www.houcj.net/blog/2013/12/15/the-parameters-in-tcp-congestion-control/</link><description>&lt;ul&gt;
&lt;li&gt;流量控制（Flow control） End-to-End,防止发送方速率过大，接收方来不及处理发送方的数据。- -&lt;/li&gt;
&lt;li&gt;拥塞控制（Congestion control） 到达子网中某一部分的分组数量过多，中间路由缓存分组，queueing，造成RTT增加。反应网络整体状况&lt;/li&gt;
&lt;li&gt;滑动窗口（Sliding Window） 位于发送方，由接收方的通告窗口（Advertised-Window）决定。接收方通过通告窗口告诉发送方自己还有多少buffer可以接收数据。&lt;/li&gt;
&lt;li&gt;通告窗口（Advertised-Window） 接收方使用流量控制的方式&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥塞窗口（Congestion Window） 拥塞窗口的大小指能够发出，但还没有收ACK的最大数据报文段。Linux 3.0 把CWND初始化10个MSS。发送方使用流量控制的方式。发送方取拥塞窗口与通告窗口中的最小值作为发送上限&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;慢启动（Slow Start） 每个ACK，CWND增加一个报文段（CWND以字节为单位，一报文段为单位进行线性增加）
报文段（Segment） 传输层分组称为报文段，是TCP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;MSS（Maximum Segment Size ） vs MTU(Maximum Transmission Unit) 在以太网中，MSS最大值为1460（20字节的IP header和20字节的TCP header），MTU的值为1500字节。MSS用于控制发送数据的长度，避免以较小MTU连接到网络上的主机产生分组&lt;/li&gt;
&lt;li&gt;往返时延(Round-Trip Time ) 表示从发送端发送数据开始，到发送端收到来自接收端的ACK，总共经历的时延，由传播时延，传输时延，排队时延（Queuing Delay），节点处理时延决定（Node processing Dela y）。可以反应网络的拥塞状况&lt;/li&gt;
&lt;li&gt;传输时延（Transmission Delay），传播时延（Transmission Delay） 传输时延=L/R，L，表示分组长度，R，表示链路传输速率(带宽)。传播时延=d/s，d，表示两段的实际物力距离，s一般等于小于光速&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 15 Dec 2013 00:00:00 +0800</pubDate><guid>tag:,2013-12-15:www.houcj.net/blog/2013/12/15/the-parameters-in-tcp-congestion-control/</guid><category>TCP</category><category>拥塞控制</category></item></channel></rss>