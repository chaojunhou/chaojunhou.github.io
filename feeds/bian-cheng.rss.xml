<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Write the Code</title><link>www.houcj.net/</link><description></description><atom:link href="www.houcj.net/feeds/bian-cheng.rss.xml" rel="self"></atom:link><lastBuildDate>Wed, 01 Apr 2015 16:09:00 +0800</lastBuildDate><item><title>人生苦短我用Python</title><link>www.houcj.net/blog/2015/04/01/life-is-short-use-python/</link><description>&lt;blockquote&gt;
&lt;p&gt;Programs must be written for people to read, and only incidentally for machines to execute.                                         &lt;br /&gt;
  —   Abelson &amp;amp; Sussman, Structure and Interpretation of Computer Programs &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1. 交换变量&lt;/h2&gt;
&lt;p&gt;一般交换变量有以下三种方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最常用的，就是设置一个临时变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;temp = x;&lt;/span&gt;
&lt;span class="code-line"&gt;x = y;&lt;/span&gt;
&lt;span class="code-line"&gt;y = x;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种方法在python中可以更优雅的表示，而且效率更高。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;x, y = y, x&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不增加临时变量使用加法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;b = a + b&lt;/span&gt;
&lt;span class="code-line"&gt;a = b - a # a = a + b - a = b 即 a = b &lt;/span&gt;
&lt;span class="code-line"&gt;b = b - a # b = a + b - b = a&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用位操作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;b = a^b&lt;/span&gt;
&lt;span class="code-line"&gt;a = a^b&lt;/span&gt;
&lt;span class="code-line"&gt;b = a^b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;2. Python字典中判断键值是否存在&lt;/h2&gt;
&lt;p&gt;一般情况会是用一个判断语句   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;dic = {&amp;#39;key&amp;#39; : &amp;#39;value&amp;#39;}&lt;/span&gt;
&lt;span class="code-line"&gt;if &amp;#39;key&amp;#39; in dic:&lt;/span&gt;
&lt;span class="code-line"&gt;    print dic[&amp;#39;key&amp;#39;]&lt;/span&gt;
&lt;span class="code-line"&gt;else:&lt;/span&gt;
&lt;span class="code-line"&gt;    print &amp;#39;not found&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在python中可以内置的get函数即可&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;print dic.get(&amp;#39;key&amp;#39;,&amp;#39;not found&amp;#39;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;3. 读取文件&lt;/h2&gt;
&lt;p&gt;python中有三个方法来处理文件内容的输入：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;read（） 一次读取全部的文件内容。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;f = open(&amp;#39;path/to/file.txt&amp;#39;, &amp;#39;r&amp;#39;)&lt;/span&gt;
&lt;span class="code-line"&gt;ff = f.read() &lt;/span&gt;
&lt;span class="code-line"&gt;f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;readline() 每次读取文件的一行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;f = open(&amp;#39;path/to/file.txt&amp;#39;, &amp;#39;r&amp;#39;)&lt;/span&gt;
&lt;span class="code-line"&gt;line = f.readline()&lt;/span&gt;
&lt;span class="code-line"&gt;while 1:&lt;/span&gt;
&lt;span class="code-line"&gt;    if line:&lt;/span&gt;
&lt;span class="code-line"&gt;            print line&lt;/span&gt;
&lt;span class="code-line"&gt;    else:&lt;/span&gt;
&lt;span class="code-line"&gt;        break&lt;/span&gt;
&lt;span class="code-line"&gt;f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;readlines() 读取文件的所有行，返回一个字符串列表&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;f = open(&amp;#39;path/to/file.txt&amp;#39;, &amp;#39;r&amp;#39;)&lt;/span&gt;
&lt;span class="code-line"&gt;ff = f.readlines() &lt;/span&gt;
&lt;span class="code-line"&gt;f.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于文件操作需要注意文件的打开和关闭操作，因此更优雅的做法是&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    with open(&amp;#39;path/to/file.txt&amp;#39;, &amp;#39;r&amp;#39;):&lt;/span&gt;
&lt;span class="code-line"&gt;        for line in f:&lt;/span&gt;
&lt;span class="code-line"&gt;                do_somenthing(line)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;4. while 1 还是 while True？r&lt;/h2&gt;
&lt;p&gt;在python 2中，由于&lt;strong&gt;True&lt;/strong&gt;不是关键字，因此可以对True进行赋值。下面的语句是可以的&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;True = &amp;#39;Hello&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此在无限循环中，我们应该使用while 1，因为while True在每次
while循环时都会有对True的判断操作。
下面使用dis，Disassembler for Python bytecode,即把python代码反汇编为字节码指令， 模块观察生成的字节码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;dis&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;while_one&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;while_true&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;pass&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;In&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;while 1&amp;#39;&lt;/span&gt;    &lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;while_one&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Print&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;while True&amp;#39;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;   &lt;span class="o"&gt;....&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dis&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;while_true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="c"&gt;##########output&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;       &lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;SETUP_LOOP&lt;/span&gt;               &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;     &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;JUMP_ABSOLUTE&lt;/span&gt;            &lt;span class="mi"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;              &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;        &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="mi"&gt;2&lt;/span&gt;           &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;SETUP_LOOP&lt;/span&gt;              &lt;span class="mi"&gt;10&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;    &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="n"&gt;LOAD_GLOBAL&lt;/span&gt;              &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;              &lt;span class="mi"&gt;6&lt;/span&gt; &lt;span class="n"&gt;POP_JUMP_IF_FALSE&lt;/span&gt;       &lt;span class="mi"&gt;12&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;  &lt;span class="mi"&gt;3&lt;/span&gt;           &lt;span class="mi"&gt;9&lt;/span&gt; &lt;span class="n"&gt;JUMP_ABSOLUTE&lt;/span&gt;            &lt;span class="mi"&gt;3&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;   &lt;span class="mi"&gt;12&lt;/span&gt; &lt;span class="n"&gt;POP_BLOCK&lt;/span&gt;           &lt;/span&gt;
&lt;span class="code-line"&gt;        &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt;   &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="n"&gt;LOAD_CONST&lt;/span&gt;               &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;             &lt;span class="mi"&gt;16&lt;/span&gt; &lt;span class="n"&gt;RETURN_VALUE&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;5. string的连接&lt;/h2&gt;
&lt;p&gt;在python中操作字符串数据的时候经常要对字符串进行连接操作，连接的时候一般有下面两种方法 &lt;strong&gt;'+'&lt;/strong&gt;和&lt;strong&gt;'join'&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用'+'进行操作时，每次都需要创建新的对象，然后再对新的对象进行操作。&lt;/li&gt;
&lt;li&gt;计数出要join的所有字符串的长度，然后进行一一拷贝，这样只有一次对象生成
因此处于内存的考虑，应尽量使用join操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;6. 字典中的setdefault函数&lt;/h2&gt;
&lt;p&gt;我们经常需要使用字典来初始化数据，每个字典的值是一个列表。通常使用以下的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    dics = {}&lt;/span&gt;
&lt;span class="code-line"&gt;    for (val,dic) in data:&lt;/span&gt;
&lt;span class="code-line"&gt;        if val in dics:&lt;/span&gt;
&lt;span class="code-line"&gt;                dics[val].append(dic)&lt;/span&gt;
&lt;span class="code-line"&gt;        else:&lt;/span&gt;
&lt;span class="code-line"&gt;                dics[val] = [dic]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通过setdefault可以优化为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    dics = {}&lt;/span&gt;
&lt;span class="code-line"&gt;    for (val,dic) in data:&lt;/span&gt;
&lt;span class="code-line"&gt;        dics.setdefault(val, []).append(dic)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;7.  列举&lt;/h2&gt;
&lt;p&gt;在python中遍历list获得index和item。可以通过下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    index = 0&lt;/span&gt;
&lt;span class="code-line"&gt;    for item in lst:&lt;/span&gt;
&lt;span class="code-line"&gt;        print index,item&lt;/span&gt;
&lt;span class="code-line"&gt;        index += 1&lt;/span&gt;
&lt;span class="code-line"&gt;    or&lt;/span&gt;
&lt;span class="code-line"&gt;    for index in range(len(lst)):&lt;/span&gt;
&lt;span class="code-line"&gt;        print index, lst[index]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而使用enumerate可以使代码更清晰， 更易读。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    for (index, item) in lst:&lt;/span&gt;
&lt;span class="code-line"&gt;        print index, item&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;8. 列表展开（list comprehension）&lt;/h2&gt;
&lt;p&gt;列表展开比一般的循环操作的效率更高，而且更简单。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    a = [1, 1, 2, 3, 5, 8]&lt;/span&gt;
&lt;span class="code-line"&gt;    for i in range(len(a)):&lt;/span&gt;
&lt;span class="code-line"&gt;        a[i] = i**2 // **比pow（）的效率更高，因此它在python中是一个运算符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;或者更高的实现&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    a = [1, 1, 2, 3, 5, 8]&lt;/span&gt;
&lt;span class="code-line"&gt;    a = [val**2 for val in a]&lt;/span&gt;
&lt;span class="code-line"&gt;    # or :&lt;/span&gt;
&lt;span class="code-line"&gt;    a = map(lambda i: i**2, a)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;9. itertools模块&lt;/h2&gt;
&lt;p&gt;迭代的内部机制： 迭代(iteration）就是对可迭代对象（iterables，实现了_&lt;em&gt;iter_&lt;/em&gt;()方法）和迭代器（iterators，实现了_&lt;em&gt;next_&lt;/em&gt;()方法）的一个操作过程。可迭代对象是任何可返回一个迭代器的对象，迭代器是应用在迭代对象中迭代的对象，换一种方式说的话就是：iterable对象的_&lt;em&gt;iter_&lt;/em&gt;()方法可以返回iterator对象，iterator通过调用next()方法获取其中的每一个值，读者可以结合Java API中的 Iterable接口和Iterator接口进行类比。&lt;/p&gt;
&lt;h2&gt;10. 生成器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任何你可用 "for... in..." 处理的都是可迭代对象：列表，字符串，文件.... 这些迭代对象非常便捷，因为你可以尽可能多地获取你想要的东西。但是当有大量数据要使用内存的时候，必须要使用生成器了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成器是迭代器，但你只能遍历它一次(iterate over them once) 因为生成器并没有将所有值放入内存中，而是实时地生成这些值&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Wed, 01 Apr 2015 16:09:00 +0800</pubDate><guid>tag:,2015-04-01:www.houcj.net/blog/2015/04/01/life-is-short-use-python/</guid><category>Python</category></item><item><title>链接和预编译</title><link>www.houcj.net/blog/2015/03/27/link-and-preprocess/</link><description>&lt;h2&gt;链接器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;分别编译：即若干个源程序可以在不同的时候单独进行编译，然后在恰当的时候将它们整合到一起。但是，链接器一般是与C编译器分离的。&lt;/li&gt;
&lt;li&gt;链接器通常把由编译器或汇编器生成的若干个目标模块整合成一个被称为载入模块或可执行文件的实体，该实体能够被操作系统直接执行。&lt;/li&gt;
&lt;li&gt;链接器通常把目标模块看成是由一组外部对象组成。每个外部对象代表机器内存中的某个部分，并通过一个外部名称来识别。&lt;/li&gt;
&lt;li&gt;exit函数和return函数的主要区别是：&lt;ul&gt;
&lt;li&gt;exit用于在程序运行的过程中随时结束程序，exit的参数返回给操作系统。exit函数运行时会先执行由atexit（）函数等级的函数，然后会做一些自身的清理工作，同时刷新所有输出流、关闭所有打开的流并且关闭通过标准I/O函数tmpfile（）创建的临时文件。exit是结束一个进程，它将删除进程的内存空间，同时讲错误信息返回给父进程。exit是系统调用级别的，表示整个进程的结束。&lt;/li&gt;
&lt;li&gt;return表示终止当前函数的运行，并将操作权返回给调用者。如果在main函数中，表示将操作权返回给操作系统，隐式调用exit。​如果return没有值就返回空，表示中断函数的执行，返回调用函数处。return是语言级别的，它表示了调用堆栈的返回；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解复杂声明可用的“右左法则”：从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。
分析下面的例子，答案见最后。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;char * const *(*next)();&lt;/span&gt;
&lt;span class="code-line"&gt;char * (* c[10])int (**p);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;每个外部对象只在一个地方声明。这个声明的地方一般就在一个头文件中，需要用到该外部对象的所有模块都应该包括在这个头文件。特别注意：定义该外部对应的那个模块也应该包括这个头文件。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译：生成目标平台的指令
-解释：在运行过程中才生成目标平台的指令。需要虚拟机来将编译后生成的中间代码翻译成目标平台的指令。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Interposition指用户定义的函数取代函数库中声明&lt;strong&gt;&lt;em&gt;完全相同的函数&lt;/em&gt;&lt;/strong&gt;，不是重载.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;void mktemp() {..}&lt;/span&gt;
&lt;span class="code-line"&gt;void getwd() { mktemp();}&lt;/span&gt;
&lt;span class="code-line"&gt;int main()&lt;/span&gt;
&lt;span class="code-line"&gt;{&lt;/span&gt;
&lt;span class="code-line"&gt;    mktemp();&lt;/span&gt;
&lt;span class="code-line"&gt;    getwd(); // 即使库函数有 void mktemp(){}，操作系统也会调用用户自己定义的函数&lt;/span&gt;
&lt;span class="code-line"&gt;    return 0&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;链接库的五个特殊秘密&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态链接库的扩展名为 ".so"，静态的为".a"&lt;/li&gt;
&lt;li&gt;通过-lthread选项，告诉编译器链接到libthread.so&lt;/li&gt;
&lt;li&gt;编译器期望在确定的目录下找到这些库函数&lt;/li&gt;
&lt;li&gt;观察头文件，确定所使用的函数库&lt;/li&gt;
&lt;li&gt;与提取动态库中的符号相比，静态库中的符号提取的方法限制更严格&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态库的优点：&lt;ul&gt;
&lt;li&gt;动态链接可执行文件比功能相同的静态链接可执行文件的体积小。&lt;/li&gt;
&lt;li&gt;所有动态链接到某个特定函数库的可执行文件在运行时共享该函数库的一个单独拷贝。  &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于库函数的使用，最好的用法就是尽量使用系统头文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;预处理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;宏定义使用预处理器实现，做一些简单的字符替换因此不能进行参数有效性的检测。&lt;/li&gt;
&lt;li&gt;宏定义中的空格不能忽视&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    #define f (x) ((x)-1）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;的意思是f代表(x) ((x)-1而不是f(x)代表((x)-1
- 宏定义中出现的括号的作用是预防引起与优先级有关的问题。例如
- 
        #define abs(x) (((x)&amp;gt;=0)?:(x):-(x))// 正确
        #define abs(x) x&amp;gt;0?x:-x // 错误
abs(a-b)在错误的表达式中会展开为 a-b&amp;gt;0?a-b:-a-b
即使是用括号括起来也可能出错。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;    #define max(a,b) ((a)&amp;gt;(b)?(a):(b))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上面的表达式中，如果a大于b，那么a将会被求两次值，此时max(a++,b)就会产生错误的结果。
正确的做法如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;     #define max(x, y) ({&lt;/span&gt;
&lt;span class="code-line"&gt;     typeof(x) _max1 = (x);  &lt;/span&gt;
&lt;span class="code-line"&gt;     typeof(y) _max2 = (y);  &lt;/span&gt;
&lt;span class="code-line"&gt;     (void) (&amp;amp;_max1 == &amp;amp;_max2);  // 当两个比较两个类型不同的变量的地址时,编译器会给出一个警告.提示我们在进行类型不同的比较.&lt;/span&gt;
&lt;span class="code-line"&gt;     _max1 &amp;gt; _max2 ? _max1 : _max2; })&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前面的(void)又是干什么用的呢?因为我们在比较两个地址之后并没有保存比较结果,编译器会认为这是一条无效语句,同样会给出一个警告.我们将它转换为(void)类型,编译器会认为我们对结果使用了,就不会提示这个错误。
再看一个经典的例子   &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;#define toupper(c)&lt;/span&gt;
&lt;span class="code-line"&gt;((c)&amp;gt;=&amp;#39;a&amp;#39; &amp;amp;&amp;amp; (c)&amp;lt;=&amp;#39;z&amp;#39;?(c)+(&amp;#39;A&amp;#39;-&amp;#39;a&amp;#39;):(c))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样做的原因是因为touppper(函数在调用时造成的系统开销要大大多于函数体内的实际计算操作。&lt;/p&gt;
&lt;h2&gt;动态语言和静态语言&lt;/h2&gt;
&lt;p&gt;通常我们所说的动态语言、静态语言是指动态类型语言和静态类型语言。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态类型语言：动态类型语言是指在&lt;strong&gt;运行期间&lt;/strong&gt;才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。Python和Ruby就是一种典型的动态类型语言&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态类型语言：静态类型语言与动态类型语言刚好相反，它的数据类型是在&lt;strong&gt;编译期间&lt;/strong&gt;检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况静态类型的语言运行速度要高于动态语言。&lt;/p&gt;
&lt;h2&gt;强类型定义语言和弱类型定义语言&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;强类型定义语言：强制数据类型定义的语言。也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。举个例子：如果你定义了一个整型变量a,那么程序根本不可能将a当作字符串类型处理。强类型定义语言是类型安全的语言，可以有效的避免许多错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;弱类型定义语言：数据类型可以被忽略的语言。它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Python是动态的强类型语言，C是静态的弱类型语言&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Fri, 27 Mar 2015 23:07:00 +0800</pubDate><guid>tag:,2015-03-27:www.houcj.net/blog/2015/03/27/link-and-preprocess/</guid><category>C</category></item><item><title>The basic Knowledge in C</title><link>www.houcj.net/blog/2015/03/03/the-basic-knowledge-in-c/</link><description>&lt;h2&gt;C 语言中的运算规则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C语言中每个token应该尽可能多的包含更多的字符。如果编译器的输入流截止到某个字符之前已经被分解成一个个的token，那么从该字符之后应尽可能的组成一个最长的字符串的token。除了字符串与字符串常量，符号的中间不能嵌有空白（空格符、制表符，换行符）。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C语言中符号之间的空白将被忽略，这些符号包括空格符，制表符，换行符号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;if (a &amp;gt; b)&lt;/span&gt;
&lt;span class="code-line"&gt;b = a;&lt;/span&gt;
&lt;span class="code-line"&gt;if (a &amp;gt;&lt;/span&gt;
&lt;span class="code-line"&gt;b&lt;/span&gt;
&lt;span class="code-line"&gt;)&lt;/span&gt;
&lt;span class="code-line"&gt;b = &lt;/span&gt;
&lt;span class="code-line"&gt;a;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C语言变量的声明包括两部分：类型，以及声明符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C语言运算符优先级&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最高优先级包括：数组下标，函数调用操作符，各结构成员选择操作符。都是自左向右结合。&lt;/li&gt;
&lt;li&gt;单目运算符的优先级仅次于最高级的运算符。单目运算符是自右向左结合。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双目运算符中，优先级为:&lt;strong&gt;算术运算符 &amp;gt; 移位运算符 &amp;gt; 关系元算符 &amp;gt;逻辑运算符&amp;gt;赋值运算符&amp;gt;条件元算符&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在所有的运算符中，&lt;strong&gt;逗号&lt;/strong&gt;运算符的优先级最低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;C语言中，只有四种运算符存在规定的求值顺序（&amp;amp;&amp;amp;、||、?:、,）。运算符&amp;amp;&amp;amp;和||首先对左侧操作数求值，只在需要的时候才对右侧操作数求值。运算符？：有三个操作数：在a？b:c中，操作数a首先别求值，根据a的值再求b后者c的值。而逗号操作符，首先对左侧操作数求值，然后该值被丢弃，再对右侧操作数求值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;C语言中常见的问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如果一个整形常量的第一个字符是数字0，那么该常量将被视作八位数。譬如010会被当成十进制中的8。&lt;/li&gt;
&lt;li&gt;在C语言中用单引号引起的字符所代表的是该字符ASCII码的整数值。而双引号引起的字符串，代表的是一个指向无名数组起始字符的指针。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C语言中，每个case只有在遇到break时才会跳出switch语句。否则讲继续。&lt;/p&gt;
&lt;p&gt;switch(exp)
{
case one:
    do something1;
    break;
case two:
    do something2;
    break;
default:
    do something3:
    break;
｝&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果strlen(s)的值是n，那么该字符串实际需要n+1个字符的空间，'\0'作为结束标志。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;char *p,*q;&lt;/span&gt;
&lt;span class="code-line"&gt;p = &amp;quot;xyz&amp;quot;&lt;/span&gt;
&lt;span class="code-line"&gt;q = p;&lt;/span&gt;
&lt;span class="code-line"&gt;p[0] = &amp;#39;X&amp;#39;&lt;/span&gt;
&lt;span class="code-line"&gt;q[1] = &amp;#39;Y&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;复制指针并不同时复制指针所指向的数据，而是把指针所指向的地址复制给另一个指针。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;int n = 4;&lt;/span&gt;
&lt;span class="code-line"&gt;int buffer[n] = { 1, 2, 3, 4 };&lt;/span&gt;
&lt;span class="code-line"&gt;int *bufptr = buffer;&lt;/span&gt;
&lt;span class="code-line"&gt;int *p = buffer;&lt;/span&gt;
&lt;span class="code-line"&gt;while (n &amp;gt; -1) {&lt;/span&gt;
&lt;span class="code-line"&gt;if (bufptr == &amp;amp;buffer[4])&lt;/span&gt;
&lt;span class="code-line"&gt;{&lt;/span&gt;
&lt;span class="code-line"&gt;printf(&amp;quot;Work well !\n&amp;quot;);&lt;/span&gt;
&lt;span class="code-line"&gt;break;&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;span class="code-line"&gt;*bufptr++ = *p++;&lt;/span&gt;
&lt;span class="code-line"&gt;n -= 1;&lt;/span&gt;
&lt;span class="code-line"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以上面的代码执行后，p，q共同指向字符串“XYz” 
- 当常量被转换为指针使用时，这个指针绝对不能解引用，即不能使用该指针所指向内存中的存储内容。ANSI规定：数组中实际不存在的溢界元素的地址位于数组所占用内存之后，这个地址可以用于进行赋值比较。但是不能引用该地址的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型提升：在表达式中，每个char类型都被转换为int，float都会转换为double。由于函数参数也是一个表达式，所以当参数传递给函数时也会发生类型转换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整型提升：char、short int和位段类型（signed，unsigned）以及枚举类型将被提升为int，前提是int类型能够完整地容纳原先的数据，否则讲会被转换为 unsigned int。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;X = Y&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Left Value（左值）: 表示存储结果的地方. X 代表存储的地址。&lt;/li&gt;
&lt;li&gt;Right Value（右值）:  Y中的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组名是不可修改的左值&lt;/strong&gt;，只有可修改的左值才能被赋值。&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;a+++++b;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于编译器的中最长匹配的原则，上式会被翻译为&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;a++++ + b;//即&lt;/span&gt;
&lt;span class="code-line"&gt;((a++)++) + b;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而&lt;strong&gt;a++&lt;/strong&gt;不能作为左值， 因为a++返回的是自身的值副本。因此上面的表达式是错误的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大端和小端 （数据在内存中的字节排列顺序）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大端：最低位置存放高位字节，高位优先。&lt;/li&gt;
&lt;li&gt;小端：最低位置存放低位字节，地位优先。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;'NUL'和'NULL'的区别 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个'L'的'NUL'用于结束一个ASCII字符串。&lt;/li&gt;
&lt;li&gt;两个'L'的'NULL'用于表示什么也不指向（空指针）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C中的关键字：&lt;ul&gt;
&lt;li&gt;extern：用于变量，表示在其他地方（文件）定义。用于函数定义，表示全局可见，即可被任意文件内的函数访问。&lt;/li&gt;
&lt;li&gt;const：相当于read only&lt;/li&gt;
&lt;li&gt;static：在函数内部，表示该变量的值在各个调用一直保持持续性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Tue, 03 Mar 2015 23:07:00 +0800</pubDate><guid>tag:,2015-03-03:www.houcj.net/blog/2015/03/03/the-basic-knowledge-in-c/</guid><category>C</category></item><item><title>Multi thread</title><link>www.houcj.net/blog/2015/02/27/multi-thread/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Fri, 27 Feb 2015 00:00:00 +0800</pubDate><guid>tag:,2015-02-27:www.houcj.net/blog/2015/02/27/multi-thread/</guid><category>多线程</category></item><item><title>Regular expression</title><link>www.houcj.net/blog/2015/02/07/regular-expression/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sat, 07 Feb 2015 00:00:00 +0800</pubDate><guid>tag:,2015-02-07:www.houcj.net/blog/2015/02/07/regular-expression/</guid><category>正则表达式</category></item><item><title>图像识别</title><link>www.houcj.net/blog/2014/12/22/tu-xiang-shi-bie/</link><description>&lt;p&gt;Author: ChaoJun Hou&lt;/p&gt;
&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Mon, 22 Dec 2014 00:00:00 +0800</pubDate><guid>tag:,2014-12-22:www.houcj.net/blog/2014/12/22/tu-xiang-shi-bie/</guid><category>图像</category></item><item><title>Introduction to Sublime</title><link>www.houcj.net/blog/2014/10/05/tool/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sun, 05 Oct 2014 00:00:00 +0800</pubDate><guid>tag:,2014-10-05:www.houcj.net/blog/2014/10/05/tool/</guid><category>工具</category></item><item><title>Introduction to Shell</title><link>www.houcj.net/blog/2014/07/19/introduction-to-shell/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sat, 19 Jul 2014 00:00:00 +0800</pubDate><guid>tag:,2014-07-19:www.houcj.net/blog/2014/07/19/introduction-to-shell/</guid><category>SHELL</category></item><item><title>Mysql</title><link>www.houcj.net/blog/2014/04/25/mysql/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Fri, 25 Apr 2014 00:00:00 +0800</pubDate><guid>tag:,2014-04-25:www.houcj.net/blog/2014/04/25/mysql/</guid><category>SQL</category></item><item><title>The crawl</title><link>www.houcj.net/blog/2014/03/08/the-crawl/</link><description>&lt;p&gt;to be continue...&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Sat, 08 Mar 2014 00:00:00 +0800</pubDate><guid>tag:,2014-03-08:www.houcj.net/blog/2014/03/08/the-crawl/</guid><category>爬虫</category></item><item><title>Mind trick</title><link>www.houcj.net/blog/2014/02/20/mind-trick/</link><description>&lt;p&gt;天平问题。（最少几次可以找到不平衡的那个。）最少几只小白鼠可以找到有药的瓶子。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Thu, 20 Feb 2014 00:00:00 +0800</pubDate><guid>tag:,2014-02-20:www.houcj.net/blog/2014/02/20/mind-trick/</guid><category>智力</category></item><item><title>Thanks for the memory</title><link>www.houcj.net/blog/2013/12/03/thanks-for-the-memory/</link><description>&lt;ul&gt;
&lt;li&gt;虚拟内存通过&lt;em&gt;Page&lt;/em&gt;的形式组织。Pages就是操作系统用于内存和磁盘之间移动或者进行保护的单位。Page in，Page out。磁盘上有个特殊的交换区来与内存进行交换。&lt;/li&gt;
&lt;li&gt;进程只能操作位于屋里内存中的页面。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// to see the memory available in this process.&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Allocated %d MB total &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;cache&lt;ul&gt;
&lt;li&gt;cache 的类型&lt;ul&gt;
&lt;li&gt;write-through cache : 每次写入cache时同时写入到内存，保持内存与cache的一致性。&lt;/li&gt;
&lt;li&gt;write-back cache ： 当第一次写入时，只写入cache。如果已经写入过的cache行再次需要写入时，此时第一次写入的结果尚未保存，所以要先把它写入到内存中。当内存切换进程时，cache中所有的数据都要先写入到内存中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;line： 内存读取以行（32 bytes）为单位，整行的数据也会被装入到cache中。每行由两部分组成：一个数据部分以及一个标签，用于指定它所代表的地址。&lt;/li&gt;
&lt;li&gt;block： 一个行内的数据块被称作块。块保存来回移动于Cache行和内存之间的字节数据。
-堆&lt;/li&gt;
&lt;li&gt;堆区域用于动态&lt;/li&gt;
&lt;li&gt;用于内存管理的调用是：&lt;ul&gt;
&lt;li&gt;malloc 和 free ------------从堆中获得内存以及把内存返回给堆&lt;/li&gt;
&lt;li&gt;brk 和 sbrk --------------调整数据端的大小至一个绝对值。 &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;堆中经常出现的两类问题：&lt;ul&gt;
&lt;li&gt;释放或改写仍在使用的内存；（内存损坏）&lt;/li&gt;
&lt;li&gt;未释放不再使用的内存；（内存泄露）&lt;ul&gt;
&lt;li&gt;内存泄露的的检测：&lt;ul&gt;
&lt;li&gt;swap 观察交换区&lt;/li&gt;
&lt;li&gt;netstat、vmstat等工具&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对齐（alignment）：数据项只能存储在地址是数据项大小整数倍的内存位置上。数据项不能跨越页面或者cache边界&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;段（segment）错误原因：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;dereference Null pointer. &lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;或者解引用一个包含非法值的指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;在未得到正确的权限时进行访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="code-line"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;    &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 表达式必须是可以修改的左值。&lt;/span&gt;&lt;/span&gt;
&lt;span class="code-line"&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;消耗完了堆栈或者堆空间。&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">ChaoJun Hou</dc:creator><pubDate>Tue, 03 Dec 2013 10:20:00 +0800</pubDate><guid>tag:,2013-12-03:www.houcj.net/blog/2013/12/03/thanks-for-the-memory/</guid><category>C</category></item></channel></rss>